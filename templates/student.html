<!DOCTYPE html>
<html>
<head>
    <title>Transport Tracker - Student View</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="preconnect" href="https://a.basemaps.cartocdn.com" crossorigin/>
    <link rel="preconnect" href="https://b.basemaps.cartocdn.com" crossorigin/>
    <link rel="preconnect" href="https://c.basemaps.cartocdn.com" crossorigin/>
    <link rel="preconnect" href="https://d.basemaps.cartocdn.com" crossorigin/>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #07070a; color: #e6eef8; min-height: 100vh; background-image:
            radial-gradient(circle at 20% 20%, rgba(99,102,241,0.12), transparent 40%),
            radial-gradient(circle at 80% 30%, rgba(236,72,153,0.10), transparent 40%);
            background-attachment: fixed; }

        .header { background: transparent; padding: 18px 12px; text-align: left; display:flex; align-items:center; justify-content:space-between; gap:12px }
        .header h1 { font-size: 20px; color: #e6eef8; margin-bottom: 4px; }
        .header p { color: #9aa4b2; font-size: 13px; margin-top: 2px }
        .icon { display:inline-block; font-size:16px; line-height:1; vertical-align:middle; opacity:0.9; margin-right:6px }

        .main-container { display:flex; gap:18px; max-width:1200px; margin: 12px auto; padding: 0 12px; }
        .sidebar { flex:1; min-width:260px; max-width:360px; }
        .map-container { flex:1.5; min-height:0; position: relative; }

        #map { height: 500px; border-radius: 16px; border: 2px solid rgba(255,255,255,0.06); box-shadow: 0 8px 28px rgba(0,0,0,0.45); background: #05060a; }

        .card { background: rgba(18, 24, 38, 0.55); border-radius: 16px; padding: 12px; margin-bottom: 12px; border: 1px solid rgba(255,255,255,0.06); backdrop-filter: blur(18px) saturate(140%); box-shadow: 0 8px 28px rgba(0,0,0,0.45); transition: all 0.25s ease; }
        .card h3 { color: #dbeafe; font-size:15px; margin-bottom:10px }

        .stats-grid { display:grid; grid-template-columns: 1fr 1fr; gap:8px }
        .stat-box { background: rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.05); border-radius: 8px; padding:8px; text-align:center }

        .empty-state { color: #7c8898; padding:16px; font-size:12px }
        .stat-number { font-size:18px; color:#cbd5e1 }
        .stat-label { font-size:11px; color:#9aa4b2 }

        /* Map overlays */
        .map-overlay { position:absolute; top:8px; left:8px; display:flex; gap:8px; z-index:500; }
        .overlay-pill { background: rgba(18, 24, 38, 0.55); border:1px solid rgba(255,255,255,0.06); color:#e6eef8; padding:8px 12px; border-radius:16px; font-size:12px; backdrop-filter: blur(18px) saturate(140%); box-shadow: 0 8px 28px rgba(0,0,0,0.45); transition: all 0.25s ease }
        .info-strip { position:absolute; top:8px; left:8px; right:8px; display:flex; gap:8px; flex-wrap:wrap; z-index:600 }
        .info-item { background: rgba(18, 24, 38, 0.55); border:1px solid rgba(255,255,255,0.06); color:#e6eef8; padding:8px 12px; border-radius:16px; font-size:12px; backdrop-filter: blur(18px) saturate(140%); box-shadow: 0 8px 28px rgba(0,0,0,0.45); transition: all 0.25s ease }
        .info-label { color:#9aa4b2; margin-right:6px }
        .info-eta { background: rgba(23,32,54,0.32); border-color:#304b8a; color:#cfe3ff; font-weight:600 }
        .overlay-right { position:absolute; top:8px; right:8px; z-index:500 }
        .eta-pill { background:#172036; border-color:#304b8a; color:#cfe3ff; font-weight:600 }

        /* Route chips */
        .route-chips { display:flex; flex-wrap:wrap; gap:8px }
        .route-chip { padding:8px 12px; border-radius:999px; font-size:12px; border:1px solid rgba(255,255,255,0.06); cursor:pointer; background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0)); color:#e6eef8; transition: all 0.25s ease }
        .route-chip.active { background: rgba(255,255,255,0.08); box-shadow: 0 0 0 2px rgba(255,255,255,0.12) }
            /* Glossy buttons */
            #locateMeBtn { background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0)) !important; border:1px solid rgba(255,255,255,0.06) !important; border-radius:16px !important; box-shadow: 0 8px 28px rgba(0,0,0,0.45); transition: all 0.25s ease }
        .route-chip:active { transform: scale(0.98) }

        /* Active buses smaller */
        .bus-item { display:flex; align-items:center; justify-content:space-between; padding:6px 8px; border-left:4px solid; margin-bottom:6px; font-size:12px; transition: transform 120ms ease, background 120ms ease }
        .bus-item.active-route { transform: scale(1.06); background: rgba(255,255,255,0.04) }
        .bus-info { display:flex; align-items:center; gap:8px }
        .bus-dot { width:20px; height:20px; border-radius:50%; display:flex; align-items:center; justify-content:center; color:#fff; font-size:11px }
        .bus-name { opacity:0.8 }
        .bus-item:hover .bus-name { opacity:1 }

        /* Tiny stop markers */
        .marker-wrapper { width:10px; height:10px }
        .tiny-marker { display:inline-block; width:10px; height:10px; border-radius:50%; border:1px solid rgba(0,0,0,0.6) }
        .tiny-hostel { background:#9C27B0 }
        .tiny-class { background:#2196F3 }

        /* Layer control */
        .layer-control { display:flex; gap:8px; flex-wrap:wrap }
        .toggle-item { display:flex; align-items:center; gap:8px; background: rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.06); padding:6px 8px; border-radius:8px }
        .toggle-label { font-size:12px; color:#e6eef8 }
        .layer-icon { width:16px; height:8px; border-radius:999px; display:inline-block; border:1px solid rgba(255,255,255,0.2) }

        /* Status pulse dot */
        .pulse { width:6px; height:6px; border-radius:50%; display:inline-block; margin-right:6px; background:#34d399; box-shadow:0 0 0 rgba(52,211,153,0.4); animation: pulse 2s infinite }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(52,211,153,0.4) } 70% { box-shadow: 0 0 0 6px rgba(52,211,153,0) } 100% { box-shadow: 0 0 0 0 rgba(52,211,153,0) } }

        .bus-icon { transition: transform 0.15s ease; }

        @media (max-width: 968px) {
            .main-container { flex-direction:column; padding:12px }
            .map-container { order: 2 }
            .sidebar { order: 1 }
            #map { height: 420px }
        }

        
        .stat-box {
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.18);
            background-image: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.03));
            backdrop-filter: blur(16px) saturate(140%);
            box-shadow: 0 6px 20px rgba(0,0,0,0.35), inset 0 0 0 1px rgba(255,255,255,0.08);
        }
        .info-item,
        .overlay-pill {
            border: 1px solid rgba(255,255,255,0.18);
            background-image: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.02));
            backdrop-filter: blur(16px) saturate(140%);
            box-shadow: 0 6px 20px rgba(0,0,0,0.35), inset 0 0 0 1px rgba(255,255,255,0.06);
        }
        .route-chip {
            border-color: rgba(255,255,255,0.18);
            background-image: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.02));
            box-shadow: 0 4px 16px rgba(0,0,0,0.30), inset 0 0 0 1px rgba(255,255,255,0.06);
        }
        /* Blur non-selected route stops */
        .marker-wrapper.stop-blur {
            filter: blur(1.6px) brightness(0.95);
            opacity: 0.6;
            transition: filter 150ms ease, opacity 150ms ease;
        }
    </style>
</head>
<body>
    <div class="header">
        <div>
            <h1><span class="icon">üöç</span>Campus Transport System</h1>
            <p>Powered by KIIT Transport Live tracking</p>
        </div>
        <div style="display:flex;align-items:center;gap:10px">
            <a href="/admin/login" target="_blank" rel="noopener noreferrer" style="color:#666;font-size:11px;text-decoration:none">Admin</a>
            <button id="locateMeBtn" style="padding:10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.1);background:#0f0f23;color:#e6eef8;cursor:pointer">üìç Locate me</button>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <div class="card">
                <h3><span class="icon">üìä</span> Live Statistics</h3>
                <div class="stats-grid">
                    <div class="stat-box"><div class="stat-number" id="activeBusCount">0</div><div class="stat-label">Active Transport</div></div>
                    <div class="stat-box"><div class="stat-number" id="totalTransportCount">100</div><div class="stat-label">Total Transport</div></div>
                </div>
            </div>

            <div class="card">
                <h3><span>üõ£Ô∏è</span> Routes</h3>
                <div class="route-chips" id="routesContainer"></div>
            </div>

            <div class="card" id="routeDetailsCard" style="display:none">
                <h3><span>üìç</span> Route Details</h3>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px">
                    <div style="text-align:center"><div style="font-size:12px; color:#9aa4b2">ETA</div><div id="etaValue" style="font-size:18px; font-weight:600; color:#34d399; margin-top:4px">--</div></div>
                    <div style="text-align:center"><div style="font-size:12px; color:#9aa4b2">Walk Distance</div><div id="walkDistance" style="font-size:18px; font-weight:600; color:#667eea; margin-top:4px">--</div></div>
                </div>
                <div id="busesOnRoute" style="margin-top:12px; font-size:12px; color:#9aa4b2">üöå Transports on route: <span id="busesOnRouteCount">-</span></div>
            </div>

            <div class="card">
                <h3><span>üöç</span> Active Transport</h3>
                <div class="active-buses" id="activeBuses"><div class="empty-state"><p>No Transports currently active</p></div></div>
                <div class="last-update">Last updated: <span id="lastUpdate">Loading...</span></div>
            </div>
        </div>

        <div class="map-container">
            <div class="info-strip">
                <div class="info-item"><span class="info-label">Route</span><span id="currentRouteOverlay">‚Äî</span></div>
                <div class="info-item info-eta">ETA <span id="etaOverlay">--</span></div>
                <div class="info-item"><span class="info-label">Active</span><span id="activeCountOverlay">0</span></div>
                <div class="info-item"><span class="info-label">Last</span><span id="lastUpdateOverlay">‚Äî</span></div>
            </div>
            <div id="map"></div>
            <div class="card" style="margin-top:10px">
                <h3><span>üìç</span> Map Layers</h3>
                <div class="layer-control">
                    <label class="toggle-item"><input type="checkbox" id="routesToggle" checked><span class="toggle-label">Routes</span><span class="layer-icon" style="background: #FF5722;"></span></label>
                    <label class="toggle-item"><input type="checkbox" id="hostelsToggle" checked><span class="toggle-label">Hostels</span><span class="layer-icon" style="background: #9C27B0;"></span></label>
                    <label class="toggle-item"><input type="checkbox" id="classesToggle" checked><span class="toggle-label">Classes</span><span class="layer-icon" style="background: #2196F3;"></span></label>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        let map;
        let busMarkers = {};
        let hostelMarkers = {};
        let classMarkers = {};
        let routePolylines = {};
        let selectedRouteId = null;
        let allRoutes = [];
        let userLocation = null;
        let walkingLine = null;
        let busRouteMap = {}; // Maps bus number to route ID
        let userMarker = null;
        let userWatchId = null;
        // Shared buses cache to avoid redundant /api/buses fetches
        let latestBuses = {};
        let sseConnected = false;
        let busesPollTimerId = null;
        const POLL_INTERVAL_MS = 2000;   // fast polling for responsiveness
        const RESYNC_INTERVAL_MS = 10000; // occasional full resync even with SSE
        const OFFLINE_MS = 30000; // mark bus offline after 30s of no updates
        const REMOVE_MS = 60000; // remove bus marker after 60s of no updates
        const colors = [
            '#FF3B30', '#34C759', '#007AFF', '#FF9500', '#AF52DE',
            '#5AC8FA', '#FF2D55', '#FFD60A', '#32D74B', '#5856D6',
            '#FF9F0A', '#00C7BE', '#E82D2D', '#00A8FF', '#9B59B6',
            '#F1C40F', '#2ECC71', '#E74C3C', '#3498DB', '#E67E22'
        ];

        let prevBusPositions = {};  // snapped positions for display
        let prevRawPositions = {};   // raw positions for status detection
        let prevBusTimes = {};
        let prevBusRotation = {};
        let prevTrackedState = {};
        let prevRouteSelState = {};
        let followEnabled = true;
        let busLastSeen = {};  // busNum -> Date.now() of last received update
        let busDirection = {};  // busNum -> 'up' | 'down' (direction along route stops)
        let busLastStopIdx = {}; // busNum -> last nearest stop index
        let busCurrentStop = {}; // busNum -> stop name if at a stop, null otherwise
        const AT_STOP_THRESHOLD = 50; // meters - consider bus "at stop" within this distance

        // --- Route snapping: snap bus position to nearest point on its route polyline if within SNAP_DIST_M ---
        const SNAP_DIST_M = 30; // meters ‚Äî snap threshold
        // Cache decoded route coords: routeId -> [[lat,lng], ...]
        const routeCoordsCache = {};

        function cacheRouteCoords(routeId, latlngs) {
            routeCoordsCache[routeId] = latlngs;
        }

        // Find closest point on a polyline segment AB to point P
        function closestPointOnSegment(px, py, ax, ay, bx, by) {
            const dx = bx - ax, dy = by - ay;
            const lenSq = dx * dx + dy * dy;
            if (lenSq === 0) return [ax, ay];
            let t = ((px - ax) * dx + (py - ay) * dy) / lenSq;
            t = Math.max(0, Math.min(1, t));
            return [ax + t * dx, ay + t * dy];
        }

        function snapToRoute(lat, lng, busNum) {
            // Determine which route this bus is on
            const rid = busRouteMap[busNum];
            if (!rid) return { pos: [lat, lng], segIdx: -1 };
            const coords = routeCoordsCache[rid];
            if (!coords || coords.length < 2) return { pos: [lat, lng], segIdx: -1 };

            let bestDist = Infinity;
            let bestPt = [lat, lng];
            let bestSeg = -1;
            for (let i = 0; i < coords.length - 1; i++) {
                const pt = closestPointOnSegment(lat, lng, coords[i][0], coords[i][1], coords[i+1][0], coords[i+1][1]);
                const d = calcDistance(lat, lng, pt[0], pt[1]);
                if (d < bestDist) { bestDist = d; bestPt = pt; bestSeg = i; }
            }
            // Only snap if within threshold
            if (bestDist <= SNAP_DIST_M) return { pos: bestPt, segIdx: bestSeg };
            return { pos: [lat, lng], segIdx: -1 };
        }

        // Extract sub-path along route between two snapped points
        function getRouteSubPath(rid, fromPos, fromSeg, toPos, toSeg) {
            const coords = routeCoordsCache[rid];
            if (!coords || fromSeg < 0 || toSeg < 0) return null;

            const path = [];
            // Determine direction (forward or backward along route)
            const forward = toSeg >= fromSeg;
            if (forward) {
                path.push(fromPos);
                for (let i = fromSeg + 1; i <= toSeg; i++) {
                    path.push(coords[i]);
                }
                path.push(toPos);
            } else {
                path.push(fromPos);
                for (let i = fromSeg; i >= toSeg + 1; i--) {
                    path.push(coords[i]);
                }
                path.push(toPos);
            }
            // Skip if path is too long (bus probably jumped routes) ‚Äî max ~80 segments
            if (path.length > 80) return null;
            return path;
        }

        // Compute cumulative distances along a path for proportional interpolation
        function computePathDistances(path) {
            const dists = [0];
            for (let i = 1; i < path.length; i++) {
                dists.push(dists[i-1] + calcDistance(path[i-1][0], path[i-1][1], path[i][0], path[i][1]));
            }
            return dists;
        }

        // Interpolate position along a multi-point path at fraction t (0..1)
        function interpAlongPath(path, dists, t) {
            if (path.length < 2) return path[0];
            const totalLen = dists[dists.length - 1];
            if (totalLen === 0) return path[0];
            const targetDist = t * totalLen;
            for (let i = 1; i < dists.length; i++) {
                if (dists[i] >= targetDist) {
                    const segLen = dists[i] - dists[i-1];
                    const segT = segLen > 0 ? (targetDist - dists[i-1]) / segLen : 0;
                    return [
                        path[i-1][0] + (path[i][0] - path[i-1][0]) * segT,
                        path[i-1][1] + (path[i][1] - path[i-1][1]) * segT
                    ];
                }
            }
            return path[path.length - 1];
        }

        // Tween state for smooth marker movement along route paths
        const busTweens = {}; // busNum -> { path, dists, start, dur } or { from, to, start, dur }
        const busSnapInfo = {}; // busNum -> { segIdx } ‚Äî last known segment index
        const TWEEN_MS = 800;
        function easeInOut(t){ return t<0.5 ? 2*t*t : -1+(4-2*t)*t; }

        function queueBusTween(busNum, toPos){
            try{
                const marker = busMarkers[busNum];
                const fromPos = marker ? [marker.getLatLng().lat, marker.getLatLng().lng] : toPos;
                const rid = busRouteMap[busNum];
                const fromSeg = busSnapInfo[busNum] ? busSnapInfo[busNum].segIdx : -1;

                // Try to get snap info for the destination
                const snapResult = snapToRoute(toPos[0], toPos[1], busNum);
                const snappedTo = snapResult.pos;
                const toSeg = snapResult.segIdx;
                busSnapInfo[busNum] = { segIdx: toSeg };

                // Try to build a route sub-path for curved animation
                let routePath = null;
                if (rid && fromSeg >= 0 && toSeg >= 0) {
                    routePath = getRouteSubPath(rid, fromPos, fromSeg, snappedTo, toSeg);
                }

                if (routePath && routePath.length >= 2) {
                    const dists = computePathDistances(routePath);
                    busTweens[busNum] = { path: routePath, dists: dists, start: Date.now(), dur: TWEEN_MS };
                } else {
                    // Fallback: straight-line tween
                    busTweens[busNum] = { from: fromPos, to: snappedTo, start: Date.now(), dur: TWEEN_MS };
                }
                requestAnimationFrame(animateBusTweens);
            }catch(e){ /* ignore */ }
        }

        function animateBusTweens(){
            let any = false;
            Object.entries(busTweens).forEach(([busNum, tw])=>{
                const marker = busMarkers[busNum]; if(!marker) return;
                const t = Math.min(1, (Date.now() - tw.start) / tw.dur);
                const k = easeInOut(t);
                let lat, lng;
                if (tw.path) {
                    // Animate along route path
                    const pos = interpAlongPath(tw.path, tw.dists, k);
                    lat = pos[0]; lng = pos[1];
                } else {
                    // Straight-line fallback
                    lat = tw.from[0] + (tw.to[0]-tw.from[0]) * k;
                    lng = tw.from[1] + (tw.to[1]-tw.from[1]) * k;
                }
                try{ marker.setLatLng([lat,lng]); any = any || (t<1); }catch(e){}
                // Follow tracked bus: pan when it nears viewport edge
                if (trackedBus && busNum === trackedBus && followEnabled && map) {
                    try {
                        const px = map.latLngToContainerPoint([lat, lng]);
                        const sz = map.getSize();
                        const margin = 80;
                        if (px.x < margin || px.x > sz.x - margin || px.y < margin || px.y > sz.y - margin) {
                            map.panTo([lat, lng], { animate: true, duration: 0.3 });
                        }
                    } catch(e) {}
                }
                if(t>=1){ delete busTweens[busNum]; }
            });
            if(any) requestAnimationFrame(animateBusTweens);
        }

        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition((pos) => {
                userLocation = [pos.coords.latitude, pos.coords.longitude];
                if (map) { updateUserMarker(userLocation); }
            }, (err) => console.log('Geolocation error:', err));
        }

        function updateUserMarker(latlng){
            try{
                if(!map) return;
                if(!userMarker){
                    userMarker = L.circleMarker(latlng, { radius: 6, color: '#ffffff', weight: 2, fillColor: '#34d399', fillOpacity: 1 }).addTo(map);
                }else{
                    userMarker.setLatLng(latlng);
                }
            }catch(e){ /* ignore */ }
        }

        async function loadBusRoutes() {
            try { const res = await fetch('/api/bus-routes'); busRouteMap = await res.json(); } catch(e) { console.error('Error loading bus routes:', e); }
        }

        function calcDistance(lat1, lng1, lat2, lng2) {
            const R = 6371; const dLat = (lat2 - lat1) * Math.PI / 180; const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); return R * c * 1000;
        }
        function calcBearing(from, to) { const rad = Math.atan2(to[1] - from[1], to[0] - from[0]); return (rad * 180 / Math.PI + 90) % 360; }

        // Zoom-responsive icon sizing
        let currentIconSize = 22;
        function getIconSizeForZoom(z) {
            if (z >= 18) return 28;
            if (z >= 17) return 26;
            if (z >= 16) return 22;
            if (z >= 15) return 20;
            return 18;
        }

        function createIcon(busNum, color, size, rotation = 0, glow = false) {
            size = size || currentIconSize;
            const half = Math.round(size / 2);
            const stroke = Math.max(1.5, Math.round(size * 0.1));
            const headR = Math.round(size * 0.34);
            const headCY = Math.round(size * 0.42);
            const tipY = size - 1;
            const fontSize = Math.max(8, Math.round(size * 0.40));
            const textY = headCY;
            const path = `M ${half} ${tipY} L ${Math.round(half - headR * 0.58)} ${Math.round(headCY + headR * 0.32)} A ${headR} ${headR} 0 1 1 ${Math.round(half + headR * 0.58)} ${Math.round(headCY + headR * 0.32)} L ${half} ${tipY} Z`;
            const pad = 4;
            const glowR = headR + 4;
            const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="-${pad} -${pad} ${size+pad*2} ${size+pad*2}" style="filter:drop-shadow(0 0 6px ${color}88) drop-shadow(0 2px 3px rgba(0,0,0,0.6))">
              ${glow ? `<circle cx="${half}" cy="${headCY}" r="${glowR}" fill="${color}" opacity="0.2"/>` : ''}
              <path d="${path}" fill="${color}" stroke="#fff" stroke-width="${stroke}"/>
              <circle cx="${half}" cy="${Math.round(headCY - headR * 0.15)}" r="${Math.round(headR * 0.55)}" fill="rgba(255,255,255,0.15)"/>
              <text x="${half}" y="${textY}" text-anchor="middle" dominant-baseline="central"
                fill="#fff" font-family="Segoe UI,Arial" font-weight="800" font-size="${fontSize}" style="text-shadow:0 1px 2px rgba(0,0,0,0.5)">${busNum}</text>
            </svg>`;
            return L.divIcon({ className: 'bus-icon', html: svg, iconSize: [size, size], iconAnchor: [half, tipY] });
        }

        function createLocationIcon(type) { const html = type === 'hostel' ? '<span class="tiny-marker tiny-hostel"></span>' : '<span class="tiny-marker tiny-class"></span>'; return L.divIcon({ className: 'marker-wrapper', html, iconSize: [10,10], iconAnchor: [5,5], popupAnchor: [0, -8] }); }

        let trackedBus = null;
        let visibleLayers = { routes: true, hostels: true, classes: true };

        function parseIsoTime(iso) { try { const t = new Date(iso).getTime(); return isNaN(t) ? null : t; } catch(e) { return null; } }
        function computeSpeed(busNum, position, lastUpdateIso) {
            const prevPos = prevRawPositions[busNum]; const prevTime = prevBusTimes[busNum]; const currTime = parseIsoTime(lastUpdateIso);
            if (!prevPos || !prevTime || !currTime) return null;
            const timeDelta = (currTime - prevTime) / 1000;
            // Need at least 1.5s between samples for meaningful speed
            if (timeDelta < 1.5) return null;
            const meters = calcDistance(prevPos[0], prevPos[1], position[0], position[1]);
            const kmh = (meters / 1000) / (timeDelta / 3600);
            // Cap at 120 km/h ‚Äî anything higher is GPS noise
            if (kmh > 120) return null;
            return Math.round(kmh);
        }
        // Check if bus is at any stop on its route, returns stop name or null
        function checkAtStop(busNum, rawPosition) {
            const routeId = busRouteMap[busNum];
            const route = routeId ? getRouteById(routeId) : null;
            if (!route || !route.waypoints) return null;
            for (let i = 0; i < route.waypoints.length; i++) {
                const wp = route.waypoints[i];
                const d = calcDistance(rawPosition[0], rawPosition[1], wp[0], wp[1]);
                if (d <= AT_STOP_THRESHOLD) {
                    return (route.stops && route.stops[i]) ? route.stops[i] : `Stop ${i + 1}`;
                }
            }
            return null;
        }
        function determineStatus(busNum, rawPosition, lastUpdateIso) {
            const nowMs = Date.now();
            const lastSeen = busLastSeen[busNum] || 0;
            const serverTime = parseIsoTime(lastUpdateIso);
            const effectiveTime = Math.max(lastSeen, serverTime || 0);
            if (!effectiveTime || (nowMs - effectiveTime) > OFFLINE_MS) return 'Offline';
            // Check if at a route stop
            const atStop = checkAtStop(busNum, rawPosition);
            if (atStop) { busCurrentStop[busNum] = atStop; return 'At Stop'; }
            busCurrentStop[busNum] = null;
            // Use raw positions for movement detection
            const prevRaw = prevRawPositions[busNum];
            if (prevRaw) {
                const moved = calcDistance(prevRaw[0], prevRaw[1], rawPosition[0], rawPosition[1]);
                if (moved < 5) return 'Idle';
            }
            return 'Moving';
        }
        // Update bus direction along route based on which stop index it's nearest to
        function updateBusDirection(busNum, rawPosition) {
            const routeId = busRouteMap[busNum];
            const route = routeId ? getRouteById(routeId) : null;
            if (!route || !route.waypoints || route.waypoints.length < 2) return;
            // Find nearest stop index
            let bestIdx = 0, bestD = Infinity;
            route.waypoints.forEach((wp, i) => {
                const d = calcDistance(rawPosition[0], rawPosition[1], wp[0], wp[1]);
                if (d < bestD) { bestD = d; bestIdx = i; }
            });
            const prevIdx = busLastStopIdx[busNum];
            if (prevIdx !== undefined && prevIdx !== bestIdx) {
                busDirection[busNum] = bestIdx > prevIdx ? 'down' : 'up';
            }
            busLastStopIdx[busNum] = bestIdx;
        }
        function getRouteById(id) { return allRoutes.find(r => r.id === id); }
        function getNextStopForRoute(route, position, busNum) {
            if (!route || !route.waypoints || route.waypoints.length === 0) return { name: null, index: 0 };
            // Find nearest stop
            let bestIdx = 0, bestD = Infinity;
            route.waypoints.forEach((wp, i) => {
                const d = calcDistance(position[0], position[1], wp[0], wp[1]);
                if (d < bestD) { bestD = d; bestIdx = i; }
            });
            // Use tracked direction to determine next stop
            const dir = busNum ? busDirection[busNum] : null;
            let nextIdx;
            if (dir === 'up') {
                // Moving toward index 0
                nextIdx = Math.max(0, bestIdx - 1);
                // If already at first stop, wrap or stay
                if (bestIdx === 0) nextIdx = 0;
            } else {
                // Default: moving toward last stop ('down' or unknown)
                nextIdx = Math.min(route.waypoints.length - 1, bestIdx + 1);
                if (bestIdx === route.waypoints.length - 1) nextIdx = route.waypoints.length - 1;
            }
            // If bus is AT the nearest stop, the next stop is the one in the direction of travel
            if (bestD <= AT_STOP_THRESHOLD) {
                if (dir === 'up') { nextIdx = Math.max(0, bestIdx - 1); }
                else { nextIdx = Math.min(route.waypoints.length - 1, bestIdx + 1); }
            }
            const nextName = (route.stops && route.stops[nextIdx]) ? route.stops[nextIdx] : `Stop ${nextIdx + 1}`;
            return { name: nextName, index: nextIdx };
        }
        function buildBusPopup(busNum, busData) {
            const routeId = busRouteMap[busNum]; const route = getRouteById(routeId); const position = [busData.lat, busData.lng]; const status = determineStatus(busNum, position, busData.lastUpdate); const speed = computeSpeed(busNum, position, busData.lastUpdate); const nextStop = route ? getNextStopForRoute(route, position, busNum).name : null; const routeName = route ? route.name : '‚Äî'; const last = busData.lastUpdate ? new Date(busData.lastUpdate).toLocaleTimeString() : '‚Äî';
            const statusColor = status==='Moving'?'#34d399':status==='At Stop'?'#5AC8FA':status==='Idle'?'#fbbf24':'#fb7185';
            const atStopName = busCurrentStop[busNum];
            const speedDisplay = (speed !== null && speed !== undefined) ? speed + ' km/h' : '‚Äî';
            let html = `<div style="min-width:220px;background:#0f1220;color:#e6eef8;border:1px solid rgba(255,255,255,0.08);border-radius:10px;padding:10px"><div style="font-weight:600;margin-bottom:6px">Transport ${busNum}</div><div style="font-size:13px;color:#9aa4b2">Route: <span style="color:#dbeafe">${routeName}</span></div><div style="font-size:13px;color:#9aa4b2">Status: <span style="color:${statusColor}">${status}${atStopName ? ' ‚Äî ' + atStopName : ''}</span></div><div style="font-size:13px;color:#9aa4b2">Last update: <span style="color:#dbeafe">${last}</span></div><div style="font-size:13px;color:#9aa4b2">Speed: <span style="color:#dbeafe">${speedDisplay}</span></div><div style="font-size:13px;color:#9aa4b2">Next stop: <span style="color:#dbeafe">${nextStop || '‚Äî'}</span></div></div>`;
            return html;
        }

        function updateLayerVisibility(layer, visible) {
            visibleLayers[layer] = visible;
            if (layer === 'hostels') { Object.values(hostelMarkers).forEach(m => { if (visible) map.addLayer(m); else map.removeLayer(m); }); }
            else if (layer === 'classes') { Object.values(classMarkers).forEach(m => { if (visible) map.addLayer(m); else map.removeLayer(m); }); }
            else if (layer === 'routes') { Object.values(routePolylines).forEach(p => { if (visible) map.addLayer(p); else map.removeLayer(p); }); }
        }

        function loadHostels() {
            fetch('/api/hostels').then(r => r.json()).then(hostels => { Object.values(hostelMarkers).forEach(m => map.removeLayer(m)); hostelMarkers = {}; hostels.forEach(hostel => { const marker = L.marker([hostel.lat, hostel.lng], { icon: createLocationIcon('hostel'), title: hostel.name }).addTo(map); marker.bindPopup(`<b>${hostel.name}</b><br>Capacity: ${hostel.capacity}`); hostelMarkers[hostel.id] = marker; if (!visibleLayers.hostels) map.removeLayer(marker); }); }).catch(e => console.error('Error loading hostels:', e));
        }
        function loadClasses() {
            fetch('/api/classes').then(r => r.json()).then(classes => { Object.values(classMarkers).forEach(m => map.removeLayer(m)); classMarkers = {}; classes.forEach(cls => { const marker = L.marker([cls.lat, cls.lng], { icon: createLocationIcon('class'), title: cls.name }).addTo(map); marker.bindPopup(`<b>${cls.name}</b><br>Dept: ${cls.department}`); classMarkers[cls.id] = marker; if (!visibleLayers.classes) map.removeLayer(marker); }); }).catch(e => console.error('Error loading classes:', e));
        }

        function loadRoutes() {
            fetch('/api/routes').then(r => r.json()).then(routes => {
                Object.values(routePolylines).forEach(p => map.removeLayer(p)); routePolylines = {}; allRoutes = routes;
                routes.forEach(route => { getOSRMRoute(route.waypoints).then(routeCoords => { const coords = routeCoords || route.waypoints; cacheRouteCoords(route.id, coords); const polyline = L.polyline(coords, { color: route.color, weight: 4, opacity: 0.8, dashArray: '5, 5' }).addTo(map); polyline.bindPopup(`<b>${route.name}</b>`); polyline.on('click', () => selectRoute(route.id)); route.waypoints.forEach((wp, idx) => { const stopName = (route.stops && route.stops[idx]) || `Stop ${idx + 1}`; const icon = L.divIcon({ className: 'marker-wrapper', html: `<span class=\"tiny-marker\" style=\"background:${route.color}\"></span>`, iconSize:[10,10], iconAnchor:[5,5] }); const marker = L.marker([wp[0], wp[1]], { icon }).addTo(map); marker.bindTooltip(stopName, { direction: 'top', offset: [0, -8] }); marker.on('click', () => selectRoute(route.id)); routePolylines[`${route.id}-stop-${idx}`] = marker; }); routePolylines[route.id] = polyline; if (!visibleLayers.routes) map.removeLayer(polyline); }).catch(()=>{ // Fallback: draw original waypoints
                    const coords = route.waypoints; cacheRouteCoords(route.id, coords); const polyline = L.polyline(coords, { color: route.color, weight: 4, opacity: 0.8, dashArray: '5, 5' }).addTo(map); polyline.bindPopup(`<b>${route.name}</b>`); polyline.on('click', () => selectRoute(route.id)); route.waypoints.forEach((wp, idx) => { const stopName = (route.stops && route.stops[idx]) || `Stop ${idx + 1}`; const icon = L.divIcon({ className: 'marker-wrapper', html: `<span class=\"tiny-marker\" style=\"background:${route.color}\"></span>`, iconSize:[10,10], iconAnchor:[5,5] }); const marker = L.marker([wp[0], wp[1]], { icon }).addTo(map); marker.bindTooltip(stopName, { direction: 'top', offset: [0, -8] }); marker.on('click', () => selectRoute(route.id)); routePolylines[`${route.id}-stop-${idx}`] = marker; }); routePolylines[route.id] = polyline; if (!visibleLayers.routes) map.removeLayer(polyline); }); }); renderRoutesList(routes); }).catch(e => console.error('Error loading routes:', e));
        }

        // OSRM helpers with timeout + graceful fallback
        async function osrmFetch(url, timeoutMs=5000){
            const ctrl = new AbortController(); const t = setTimeout(()=>ctrl.abort(), timeoutMs);
            try{ const res = await fetch(url, { signal: ctrl.signal }); clearTimeout(t); if(!res.ok) throw new Error(`HTTP ${res.status}`); return await res.json(); }catch(e){ clearTimeout(t); throw e; }
        }
        async function getOSRMRoute(waypoints) {
            try { if (waypoints.length < 2) return waypoints; const coords = waypoints.map(wp => `${wp[1]},${wp[0]}`).join(';'); const url = `https://router.project-osrm.org/route/v1/driving/${coords}?geometries=geojson`; const data = await osrmFetch(url, 5000); if (data.routes && data.routes[0]) { return data.routes[0].geometry.coordinates.map(c => [c[1], c[0]]); } return waypoints; } catch(e) { console.warn('OSRM route fallback:', e); return waypoints; }
        }

        async function getOSRMDuration(fromLatLng, toLatLng) {
            try { const coords = `${fromLatLng[1]},${fromLatLng[0]};${toLatLng[1]},${toLatLng[0]}`; const url = `https://router.project-osrm.org/route/v1/driving/${coords}?overview=false`; const data = await osrmFetch(url, 5000); if (data.routes && data.routes[0]) { return { distance: data.routes[0].distance, duration: data.routes[0].duration }; } } catch(e) { console.warn('OSRM duration fallback:', e); }
            // Fallback: straight-line distance and average speed
            const meters = calcDistance(fromLatLng[0], fromLatLng[1], toLatLng[0], toLatLng[1]); const avgKmh = 25; const duration = Math.ceil((meters/1000)/avgKmh * 3600); return { distance: meters, duration };
        }
        async function getOSRMMinDurationToStop(busPoints, stopPoint) { try { if (!busPoints || busPoints.length === 0 || !stopPoint) return null; const points = [...busPoints, stopPoint]; const destIndex = points.length - 1; const coords = points.map(p => `${p[1]},${p[0]}`).join(';'); const sources = busPoints.map((_, i) => i).join(';'); const url = `https://router.project-osrm.org/table/v1/driving/${coords}?sources=${sources}&destinations=${destIndex}`; const res = await fetch(url); const data = await res.json(); if (data && data.durations && Array.isArray(data.durations)) { const mins = data.durations.map(row => row && row.length ? row[0] : Infinity).reduce((a, b) => Math.min(a, b), Infinity); return isFinite(mins) ? mins : null; } } catch(e) { console.error('OSRM table error:', e); } return null; }

        function renderRoutesList(routes) {
            const container = document.getElementById('routesContainer'); if (routes.length === 0) { container.innerHTML = '<div style="text-align:center; color:#666; font-size:12px">No routes available</div>'; return; }
            container.innerHTML = '';
            routes.forEach(route => {
                const chip = document.createElement('button');
                const isActive = String(selectedRouteId) === String(route.id);
                chip.className = `route-chip ${isActive ? 'active' : ''}`;
                chip.style.borderColor = route.color;
                chip.textContent = isActive ? `‚úì ${route.name}` : route.name;
                chip.setAttribute('aria-selected', isActive ? 'true' : 'false');
                if (isActive) {
                    chip.style.boxShadow = `0 0 0 2px ${route.color}55`;
                    chip.style.background = 'rgba(255,255,255,0.08)';
                }
                chip.addEventListener('click', () => { selectRoute(route.id); });
                container.appendChild(chip);
            });
        }

        function selectRoute(routeId) {
            const newId = String(routeId);
            selectedRouteId = (selectedRouteId === newId) ? null : newId;
            Object.entries(routePolylines).forEach(([id, polyline]) => { if (!id.includes('-stop-')) { try { const opacity = selectedRouteId === String(id) ? 1 : 0.3; polyline.setStyle({ opacity }); } catch(e) {} } });
            renderRoutesList(allRoutes);
            if (selectedRouteId) {
                const routeObj = getRouteById(routeId);
                if (routeObj) { showRouteDetails(routeObj); const rEl = document.getElementById('currentRouteOverlay'); if(rEl) rEl.textContent = routeObj.name; computeAndShowStudentETA(); }
            } else {
                const card = document.getElementById('routeDetailsCard'); if (card) card.style.display = 'none';
                const etaOverlay = document.getElementById('etaOverlay'); if (etaOverlay) etaOverlay.textContent = '--';
                const etaValue = document.getElementById('etaValue'); if (etaValue) etaValue.textContent = '--';
                const rEl = document.getElementById('currentRouteOverlay'); if(rEl) rEl.textContent = '‚Äî';
                if (walkingLine) { try { map.removeLayer(walkingLine); } catch(e){} walkingLine = null; }
            }
            // Blur non-selected route stops
            try {
                Object.entries(routePolylines).forEach(([id, marker]) => {
                    if (!id.includes('-stop-')) return;
                    const routeKey = id.split('-stop-')[0];
                    const isSelectedRoute = selectedRouteId && String(routeKey) === String(selectedRouteId);
                    if (marker && marker.getElement && marker.getElement()) {
                        const el = marker.getElement();
                        if (isSelectedRoute || !selectedRouteId) {
                            el.classList.remove('stop-blur');
                        } else {
                            el.classList.add('stop-blur');
                        }
                    }
                });
            } catch(e) { /* ignore */ }
        }

        async function showRouteDetails(route) {
            const card = document.getElementById('routeDetailsCard'); card.style.display = 'block';
            const busesData = latestBuses || {};
            const busesOnRoute = Object.entries(busesData)
                .filter(([busNum, b]) => {
                    const rid = (b && b.routeId != null) ? b.routeId : busRouteMap[busNum];
                    return rid === route.id;
                })
                .map(([busNum]) => busNum);
            const borEl = document.getElementById('busesOnRouteCount'); if (borEl) borEl.textContent = busesOnRoute.length;
            let nearestStop = null; let minDist = Infinity; const refLocation = (userLocation && userLocation.length === 2) ? userLocation : (map ? [map.getCenter().lat, map.getCenter().lng] : null);
            if (refLocation && route.waypoints.length > 0) { route.waypoints.forEach((stop) => { const dist = calcDistance(refLocation[0], refLocation[1], stop[0], stop[1]); if (dist < minDist) { minDist = dist; nearestStop = stop; } }); if (nearestStop) { if (userLocation) { const distKm = (minDist / 1000).toFixed(2); const walkMin = Math.ceil(minDist / 1.4); document.getElementById('walkDistance').textContent = `${distKm} km (${walkMin}m)`; if (walkingLine) map.removeLayer(walkingLine); walkingLine = L.polyline([userLocation, nearestStop], { color: '#999999', weight: 2, opacity: 0.6, dashArray: '5, 5' }).addTo(map); } else { document.getElementById('walkDistance').textContent = '--'; } } } else { document.getElementById('walkDistance').textContent = '--'; }
            // ETA computed separately to simplify: distance / speed
            document.getElementById('etaValue').textContent = '--'; const etaOverlay = document.getElementById('etaOverlay'); if (etaOverlay) etaOverlay.textContent = '--';
            computeAndShowStudentETA();
        }
        function formatMinSec(totalSeconds){
            const m = Math.floor(totalSeconds/60);
            const s = totalSeconds % 60;
            return `${m}:${String(s).padStart(2,'0')}`;
        }

        // ETA smoothing to avoid flicker
        let studentEtaSmooth = null; let studentEtaLastTs = 0; const STUD_ETA_ALPHA = 0.35; const STUD_ETA_UPDATE_MS = 2500; const STUD_ETA_MIN_STEP = 3; let studentEtaLastHtml = null;
        function smoothStudentEta(secs){ if(!isFinite(secs)) return secs; if(studentEtaSmooth==null){ studentEtaSmooth = secs; return secs; } const sm = STUD_ETA_ALPHA*secs + (1-STUD_ETA_ALPHA)*studentEtaSmooth; if(Math.abs(sm-studentEtaSmooth) < STUD_ETA_MIN_STEP){ studentEtaSmooth = studentEtaSmooth + Math.sign(sm-studentEtaSmooth) * STUD_ETA_MIN_STEP; } else { studentEtaSmooth = sm; } return Math.max(0, Math.round(studentEtaSmooth)); }
        function formatHHMM(totalSeconds){ const mins = Math.max(0, Math.round(totalSeconds/60)); const h = Math.floor(mins/60); const m = mins % 60; return h>0 ? `${h}:${String(m).padStart(2,'0')}` : `${m}m`; }
        function maybeUpdateStudentEta(html){ const now = Date.now(); if(now - studentEtaLastTs >= STUD_ETA_UPDATE_MS && html !== studentEtaLastHtml){ const etaEl = document.getElementById('etaValue'); const etaOverlay = document.getElementById('etaOverlay'); if(etaEl) etaEl.innerHTML = html; if(etaOverlay) etaOverlay.innerHTML = html; studentEtaLastHtml = html; studentEtaLastTs = now; } }

        async function computeAndShowStudentETA(busesDataParam){
            const etaEl = document.getElementById('etaValue'); const etaOverlay = document.getElementById('etaOverlay');
            const busesData = busesDataParam || latestBuses || {};
            const nowMs = Date.now();
            const freshEntries = Object.entries(busesData).filter(([num,b])=>{ const t = b && b.lastUpdate ? parseIsoTime(b.lastUpdate) : null; const lastSeen = busLastSeen[num] || 0; const effectiveTime = Math.max(lastSeen, t || 0); return effectiveTime && (nowMs - effectiveTime) <= OFFLINE_MS; });
            const freshData = Object.fromEntries(freshEntries);

            // Determine active route context: tracked bus route first, else selected route
            let activeRoute = null; let nearestStop = null;
            let refLocation = (userLocation && userLocation.length === 2) ? userLocation : (map ? [map.getCenter().lat, map.getCenter().lng] : null);

            let chosenBusNum = trackedBus;
            let chosenBus = chosenBusNum ? freshData[chosenBusNum] : null;
            let routeId = chosenBus && chosenBus.routeId!=null ? chosenBus.routeId : (chosenBusNum ? busRouteMap[chosenBusNum] : null);

            if(routeId){ activeRoute = getRouteById(routeId); }
            if(!activeRoute && selectedRouteId){ activeRoute = getRouteById(selectedRouteId); }
            if(!activeRoute || !activeRoute.waypoints || activeRoute.waypoints.length===0){ return; }

            // Find nearest student stop
            if(refLocation){ let minD=Infinity; activeRoute.waypoints.forEach(stop=>{ const d = calcDistance(refLocation[0],refLocation[1], stop[0], stop[1]); if(d<minD){ minD=d; nearestStop=stop; } }); }
            if(!nearestStop){ nearestStop = activeRoute.waypoints[0]; }

            // Choose bus: if not tracked, pick bus on route nearest to that stop
            if(!chosenBusNum){
                const busesOnRoute = Object.entries(freshData).filter(([num,b])=>{ const rid = (b && b.routeId!=null) ? b.routeId : busRouteMap[num]; return rid === activeRoute.id; });
                if(busesOnRoute.length===0){ return; }
                let bestNum=null, bestB=null, bestDist=Infinity;
                for(const [num,b] of busesOnRoute){ if(!b || typeof b.lat!=='number' || typeof b.lng!=='number') continue; const d = calcDistance(b.lat,b.lng, nearestStop[0], nearestStop[1]); if(d<bestDist){ bestDist=d; bestNum=num; bestB=b; } }
                chosenBusNum = bestNum; chosenBus = bestB;
                if(!chosenBus){ return; }
            }

            // Compute speed and ETA with min-change smoothing and HH:MM display
            const speedKmh = computeSpeed(chosenBusNum, [chosenBus.lat, chosenBus.lng], chosenBus.lastUpdate);
            const distMeters = calcDistance(chosenBus.lat, chosenBus.lng, nearestStop[0], nearestStop[1]);
            const avgSpeed = 25; // km/h

            if (distMeters <= AT_STOP_THRESHOLD) { maybeUpdateStudentEta('At Stop'); return; }

            let seconds;
            if (speedKmh && speedKmh > 0.1) { seconds = Math.ceil(((distMeters/1000) / speedKmh) * 3600); }
            else { seconds = Math.ceil(((distMeters/1000) / avgSpeed) * 3600); }

            const smoothed = smoothStudentEta(seconds);
            const rounded = Math.round(smoothed/60)*60; // minute resolution
            maybeUpdateStudentEta(formatHHMM(rounded));
        }

        function estimateRouteDistance(waypoints) { let total = 0; for (let i = 0; i < waypoints.length - 1; i++) { total += calcDistance(waypoints[i][0], waypoints[i][1], waypoints[i+1][0], waypoints[i+1][1]); } return total / 1000; }

        function setTrackedBus(busNum) {
            trackedBus = busNum || null;
            Object.keys(busMarkers).forEach(num => { const marker = busMarkers[num]; const isTracked = trackedBus && num === trackedBus; const rawPos = prevRawPositions[num]; const busData = latestBuses[num]; const status = (rawPos && busData) ? determineStatus(num, rawPos, busData.lastUpdate) : 'Offline'; const isOffline = status === 'Offline'; try { marker.setOpacity(isOffline ? 0.3 : (isTracked ? 1 : 0.7)); } catch(e) {} const color = colors[(parseInt(num) - 1) % colors.length]; const rid = busRouteMap[num]; const onSelectedRoute = selectedRouteId && String(rid) === String(selectedRouteId); const newIcon = createIcon(num, color, currentIconSize, prevBusRotation[num] || 0, isTracked || onSelectedRoute); marker.setIcon(newIcon); prevTrackedState[num] = !!isTracked; prevRouteSelState[num] = !!onSelectedRoute; });
            const rid = busRouteMap[busNum]; if (rid) { selectRoute(rid); const routeObj = getRouteById(rid); if(routeObj) showRouteDetails(routeObj); }
            computeAndShowStudentETA();
        }

        async function loadMetrics(){
            try{
                const res = await fetch('/api/metrics');
                const data = await res.json();
                const el = document.getElementById('totalTransportCount');
                if(el && typeof data.total_transports === 'number') el.textContent = data.total_transports;
            }catch(e){ /* ignore */ }
        }

        function initMap() {
            const bounds = [[20.339920625677212, 85.7964659296332], [20.37210882553945, 85.83388810783698]];
            map = L.map('map', { zoomControl: true, maxBounds: bounds, minZoom: 14, preferCanvas: true }).setView([20.3549, 85.8161], 15);
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', { attribution: '&copy; CARTO', maxZoom: 19, updateWhenIdle: false, updateWhenZooming: false, keepBuffer: 6 }).addTo(map);
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}{r}.png', { attribution: '', maxZoom: 19, updateWhenIdle: false, updateWhenZooming: false, keepBuffer: 6 }).addTo(map);

            // Responsive icon sizing on zoom
            currentIconSize = getIconSizeForZoom(map.getZoom());
            map.on('zoomend', () => {
                const newSize = getIconSizeForZoom(map.getZoom());
                if (newSize !== currentIconSize) {
                    currentIconSize = newSize;
                    // Rebuild all bus icons at new size
                    Object.keys(busMarkers).forEach(busNum => {
                        const color = colors[(parseInt(busNum) - 1) % colors.length];
                        const rid = busRouteMap[busNum];
                        const onSelectedRoute = selectedRouteId && String(rid) === String(selectedRouteId);
                        const isTracked = trackedBus && busNum === trackedBus;
                        const icon = createIcon(busNum, color, currentIconSize, prevBusRotation[busNum] || 0, isTracked || onSelectedRoute);
                        busMarkers[busNum].setIcon(icon);
                    });
                }
            });
            if(userLocation){ updateUserMarker(userLocation); }
            updateBuses();
            busesPollTimerId = setInterval(updateBuses, POLL_INTERVAL_MS);
            initSSE();
            loadHostels(); loadClasses(); loadRoutes(); loadBusRoutes();
            loadMetrics();
            document.getElementById('hostelsToggle').addEventListener('change', (e) => { updateLayerVisibility('hostels', e.target.checked); });
            document.getElementById('classesToggle').addEventListener('change', (e) => { updateLayerVisibility('classes', e.target.checked); });
            document.getElementById('routesToggle').addEventListener('change', (e) => { updateLayerVisibility('routes', e.target.checked); });
            // Pause polling when tab hidden; resume on show if SSE not connected
            document.addEventListener('visibilitychange', ()=>{
                if(document.hidden){ if(busesPollTimerId){ try{ clearInterval(busesPollTimerId); }catch(e){} busesPollTimerId=null; }
                } else { if(!sseConnected && !busesPollTimerId){ busesPollTimerId = setInterval(updateBuses, POLL_INTERVAL_MS); } }
            });
        }

        function updateBuses() {
            fetch('/api/buses').then(response => response.json()).then(buses => {
                latestBuses = buses || {};
                const nowMs = Date.now();
                const busNumbers = Object.keys(buses);
                // Keep buses that have data ‚Äî don't filter by time here, let status handle it
                const visibleBusNumbers = busNumbers.filter(n => {
                    const b = buses[n];
                    if (!b || typeof b.lat !== 'number' || typeof b.lng !== 'number') return false;
                    const iso = b.lastUpdate; const t = iso ? parseIsoTime(iso) : null;
                    const lastSeen = busLastSeen[n] || 0;
                    const effectiveTime = Math.max(lastSeen, t || 0);
                    // Only fully remove after REMOVE_MS
                    return effectiveTime && (nowMs - effectiveTime) <= REMOVE_MS;
                });
                // Mark local receive time for all buses in this response
                visibleBusNumbers.forEach(n => { busLastSeen[n] = nowMs; });
                const freshBusNumbers = visibleBusNumbers;
                const activeCount = freshBusNumbers.filter(n => {
                    const status = determineStatus(n, [buses[n].lat, buses[n].lng], buses[n].lastUpdate);
                    return status !== 'Offline';
                }).length;
                const activeCountEl = document.getElementById('activeBusCount'); if (activeCountEl) activeCountEl.textContent = activeCount;
                const activeCountOverlay = document.getElementById('activeCountOverlay'); if (activeCountOverlay) activeCountOverlay.textContent = activeCount;
                // Remove markers for buses missing or fully stale (beyond REMOVE_MS)
                const existingBuses = Object.keys(busMarkers);
                existingBuses.forEach(busNum => { if (!freshBusNumbers.includes(busNum)) { map.removeLayer(busMarkers[busNum]); delete busMarkers[busNum]; delete prevRawPositions[busNum]; delete prevBusPositions[busNum]; delete prevBusTimes[busNum]; delete busLastSeen[busNum]; delete busDirection[busNum]; delete busLastStopIdx[busNum]; delete busCurrentStop[busNum]; } });
                freshBusNumbers.forEach(busNum => {
                    const bus = buses[busNum]; const rawPos = [bus.lat, bus.lng]; const color = colors[(parseInt(busNum) - 1) % colors.length];
                    // Snap to route if close enough
                    const snapResult = snapToRoute(rawPos[0], rawPos[1], busNum);
                    const position = snapResult.pos;
                    busSnapInfo[busNum] = { segIdx: snapResult.segIdx };
                    let rotation = 0; if (prevBusPositions[busNum]) { rotation = calcBearing(prevBusPositions[busNum], position); }
                    const isTracked = trackedBus && busNum === trackedBus;
                    const status = determineStatus(busNum, rawPos, bus.lastUpdate);
                    const isOffline = status === 'Offline';
                    updateBusDirection(busNum, rawPos);
                    prevRawPositions[busNum] = rawPos;
                    prevBusPositions[busNum] = position; if (bus.lastUpdate) prevBusTimes[busNum] = parseIsoTime(bus.lastUpdate);
                    if (busMarkers[busNum]) {
                        queueBusTween(busNum, rawPos);
                        const rid = (bus && bus.routeId != null) ? bus.routeId : busRouteMap[busNum];
                        const onSelectedRoute = selectedRouteId && String(rid) === String(selectedRouteId);
                        const rotationChanged = (prevBusRotation[busNum] === undefined) || (Math.abs(rotation - prevBusRotation[busNum]) > 5);
                        const trackingChanged = prevTrackedState[busNum] !== !!isTracked;
                        const routeSelChanged = prevRouteSelState[busNum] !== !!onSelectedRoute;
                        if (rotationChanged || trackingChanged || routeSelChanged) {
                            const newIcon = createIcon(busNum, color, currentIconSize, rotation, isTracked || onSelectedRoute);
                            busMarkers[busNum].setIcon(newIcon);
                            prevBusRotation[busNum] = rotation;
                            prevTrackedState[busNum] = !!isTracked;
                            prevRouteSelState[busNum] = !!onSelectedRoute;
                        }
                    } else {
                        const rid = (bus && bus.routeId != null) ? bus.routeId : busRouteMap[busNum];
                        const onSelectedRoute = selectedRouteId && String(rid) === String(selectedRouteId);
                        const icon = createIcon(busNum, color, currentIconSize, rotation, isTracked || onSelectedRoute);
                        busMarkers[busNum] = L.marker(position, { icon: icon, title: `Transport ${busNum}` }).addTo(map);
                        prevBusRotation[busNum] = rotation;
                        prevTrackedState[busNum] = !!isTracked;
                        prevRouteSelState[busNum] = !!onSelectedRoute;
                        busMarkers[busNum].bindPopup(() => buildBusPopup(busNum, bus));
                        busMarkers[busNum].on('click', () => { setTrackedBus(busNum); if (followEnabled) map.setView(position, 17); busMarkers[busNum].openPopup(); });
                        busMarkers[busNum].on('mouseover', () => { followEnabled = false; }); busMarkers[busNum].on('mouseout', () => { followEnabled = true; });
                    }
                    const marker = busMarkers[busNum]; const isTrackedNow = trackedBus && busNum === trackedBus;
                    // Dim offline buses instead of removing
                    try { marker.setOpacity(isOffline ? 0.3 : (isTrackedNow ? 1 : 0.7)); } catch(e) {}
                    if (isTrackedNow && followEnabled && !isOffline) { map.panTo(position); }
                });
                updateActiveBusList(freshBusNumbers, buses);
                computeAndShowStudentETA(latestBuses);
                const now = new Date().toLocaleTimeString(); const luSidebar = document.getElementById('lastUpdate'); if (luSidebar) luSidebar.textContent = now; const luOverlay = document.getElementById('lastUpdateOverlay'); if (luOverlay) luOverlay.textContent = now;
            }).catch(error => console.error('Error:', error));
        }

        function updateActiveBusList(busNumbers, buses) {
            const container = document.getElementById('activeBuses'); if (busNumbers.length === 0) { container.innerHTML = `<div class="empty-state"><p>No Transports currently active</p></div>`; return; }
            container.innerHTML = '';
            busNumbers.sort((a, b) => parseInt(a) - parseInt(b));
            busNumbers.forEach(busNum => {
                const color = colors[(parseInt(busNum) - 1) % colors.length];
                const rid = (buses[busNum] && buses[busNum].routeId != null) ? buses[busNum].routeId : busRouteMap[busNum];
                const onSelectedRoute = selectedRouteId && String(rid) === String(selectedRouteId);
                const item = document.createElement('div');
                item.className = `bus-item ${onSelectedRoute ? 'active-route' : ''}`;
                item.style.borderLeftColor = color;
                item.onclick = () => { const position = [buses[busNum].lat, buses[busNum].lng]; map.setView(position, 17); };
                const rawPos = [buses[busNum].lat, buses[busNum].lng];
                const status = determineStatus(busNum, rawPos, buses[busNum].lastUpdate);
                const statusColor = status==='Moving'?'#34d399':status==='At Stop'?'#5AC8FA':status==='Idle'?'#fbbf24':'#fb7185';
                const atStopName = busCurrentStop[busNum];
                const route = getRouteById(rid);
                const nextStop = route ? getNextStopForRoute(route, rawPos, busNum).name : null;
                let statusHtml = `<div class="bus-status" style="color:${statusColor}"><div class="pulse" style="background:${statusColor}"></div>${status}</div>`;
                let stopRow = '';
                if (atStopName) {
                    stopRow = `<div style="font-size:11px;color:#5AC8FA;padding:2px 0 0 36px;font-weight:500">AT: ${atStopName}</div>`;
                } else if (nextStop) {
                    stopRow = `<div style="font-size:11px;color:#9aa4b2;padding:2px 0 0 36px">Next: ${nextStop}</div>`;
                }
                item.innerHTML = `<div class="bus-info"><div class="bus-dot" style="background-color: ${color}; transform:${onSelectedRoute ? 'scale(1.08)' : 'scale(1)'}">${busNum}</div><div class="bus-name">Transport ${busNum}</div></div>${statusHtml}${stopRow}`;
                container.appendChild(item);
            });
        }

        // Live updates via SSE for smooth animation
        function initSSE(){
            try{
                const es = new EventSource('/events');
                es.onopen = ()=>{
                    sseConnected = true;
                    if(busesPollTimerId){ try{ clearInterval(busesPollTimerId); }catch(e){} busesPollTimerId=null; }
                    // Light resync every RESYNC_INTERVAL_MS to prune stale buses
                    if(!window.__resyncTimer){ window.__resyncTimer = setInterval(()=>{ if(!document.hidden) updateBuses(); }, RESYNC_INTERVAL_MS); }
                };
                es.onmessage = (ev)=>{
                    try{
                        const msg = JSON.parse(ev.data);
                        if(msg.type === 'bus_update'){
                            const busNum = String(msg.bus);
                            const b = msg.data||{};
                            if(typeof b.lat !== 'number' || typeof b.lng !== 'number') return;
                            // update route mapping if provided
                            if(b.routeId != null) busRouteMap[busNum] = b.routeId;
                            // Track last seen time, direction, and raw position for status
                            busLastSeen[busNum] = Date.now();
                            updateBusDirection(busNum, [b.lat, b.lng]);
                            prevRawPositions[busNum] = [b.lat, b.lng];
                            if(b.lastUpdate) prevBusTimes[busNum] = parseIsoTime(b.lastUpdate);
                            // update cache and animate
                            latestBuses[busNum] = { ...(latestBuses[busNum]||{}), ...b };
                            if(!busMarkers[busNum]){
                                const color = colors[(parseInt(busNum) - 1) % colors.length];
                                const icon = createIcon(busNum, color, currentIconSize, 0, false);
                                busMarkers[busNum] = L.marker([b.lat,b.lng], { icon, title: `Transport ${busNum}` }).addTo(map);
                                busMarkers[busNum].bindPopup(() => buildBusPopup(busNum, b));
                            } else {
                                queueBusTween(busNum, [b.lat, b.lng]);
                            }
                            const now = new Date().toLocaleTimeString();
                            const luSidebar = document.getElementById('lastUpdate'); if (luSidebar) luSidebar.textContent = now;
                            const luOverlay = document.getElementById('lastUpdateOverlay'); if (luOverlay) luOverlay.textContent = now;
                            computeAndShowStudentETA(latestBuses);
                        } else if(msg.type === 'bus_stop'){
                            const busNum = String(msg.bus);
                            delete latestBuses[busNum];
                            delete busLastSeen[busNum];
                            delete prevRawPositions[busNum];
                            delete prevBusPositions[busNum];
                            delete prevBusTimes[busNum];
                            delete busDirection[busNum];
                            delete busLastStopIdx[busNum];
                            delete busCurrentStop[busNum];
                            const m = busMarkers[busNum]; if(m){ try{ map.removeLayer(m); }catch(e){} delete busMarkers[busNum]; }
                        } else if(msg.type === 'buses_clear'){
                            latestBuses = {};
                            Object.values(busMarkers).forEach(m=>{ try{ map.removeLayer(m); }catch(e){} }); busMarkers = {};
                        }
                    }catch(e){ /* ignore */ }
                };
                es.onerror = ()=>{
                    // If SSE fails, ensure polling is running
                    sseConnected = false;
                    if(!busesPollTimerId){ busesPollTimerId = setInterval(updateBuses, POLL_INTERVAL_MS); }
                };
            }catch(e){ /* SSE not available, keep polling */ }
        }

        async function locateMe() {
            if (!navigator.geolocation) return alert('Geolocation not supported');
            navigator.geolocation.getCurrentPosition((pos) => {
                userLocation = [pos.coords.latitude, pos.coords.longitude]; map.setView(userLocation, 16);
                updateUserMarker(userLocation);
                let best = { route: null, stop: null, dist: Infinity };
                allRoutes.forEach(route => { route.waypoints.forEach((wp) => { const d = calcDistance(userLocation[0], userLocation[1], wp[0], wp[1]); if (d < best.dist) best = { route, stop: wp, dist: d }; }); });
                if (best.route) { selectRoute(best.route.id); if (walkingLine) map.removeLayer(walkingLine); walkingLine = L.polyline([userLocation, best.stop], { color:'#999', weight:2, opacity:0.7, dashArray:'5,5' }).addTo(map); showRouteDetails(best.route); computeAndShowStudentETA(); }
                if(!userWatchId){
                    userWatchId = navigator.geolocation.watchPosition((p)=>{
                        userLocation = [p.coords.latitude, p.coords.longitude];
                        updateUserMarker(userLocation);
                    }, ()=>{}, { enableHighAccuracy:true, maximumAge:8000, timeout:12000 });
                }
            }, () => alert('Unable to get location'));
        }

        document.addEventListener('DOMContentLoaded', () => { const btn = document.getElementById('locateMeBtn'); if (btn) btn.addEventListener('click', locateMe); });
        window.addEventListener('load', initMap);
    </script>
</body>
</html>