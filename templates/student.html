<!DOCTYPE html>
<html>
<head>
    <title>Transport Tracker - Student View</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="preconnect" href="https://a.basemaps.cartocdn.com" crossorigin/>
    <link rel="preconnect" href="https://b.basemaps.cartocdn.com" crossorigin/>
    <link rel="preconnect" href="https://c.basemaps.cartocdn.com" crossorigin/>
    <link rel="preconnect" href="https://d.basemaps.cartocdn.com" crossorigin/>
    <style>
        :root {
            --bg: #07070a;
            --bg-gradient1: rgba(99,102,241,0.12);
            --bg-gradient2: rgba(236,72,153,0.10);
            --text: #e6eef8;
            --text-sub: #9aa4b2;
            --text-heading: #dbeafe;
            --card-bg: rgba(22, 20, 42, 0.55);
            --card-border: rgba(130,100,255,0.10);
            --card-shadow: rgba(0,0,0,0.45);
            --stat-bg: rgba(255,255,255,0.06);
            --stat-border: rgba(255,255,255,0.18);
            --stat-gradient: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.03));
            --stat-inner: rgba(255,255,255,0.08);
            --input-bg: #0f0f23;
            --input-border: rgba(255,255,255,0.1);
            --chip-border: rgba(255,255,255,0.18);
            --chip-gradient: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.02));
            --chip-shadow: 0 4px 16px rgba(0,0,0,0.30), inset 0 0 0 1px rgba(255,255,255,0.06);
            --map-border: rgba(255,255,255,0.06);
            --map-bg: #05060a;
        }
        body.light-mode {
            --bg: #f0f2f5;
            --bg-gradient1: rgba(99,102,241,0.06);
            --bg-gradient2: rgba(236,72,153,0.05);
            --text: #1a1a2e;
            --text-sub: #555e6e;
            --text-heading: #1e293b;
            --card-bg: rgba(255, 255, 255, 0.85);
            --card-border: rgba(100,80,200,0.10);
            --card-shadow: rgba(0,0,0,0.10);
            --stat-bg: rgba(0,0,0,0.03);
            --stat-border: rgba(0,0,0,0.10);
            --stat-gradient: linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,255,255,0.5));
            --stat-inner: rgba(0,0,0,0.04);
            --input-bg: #fff;
            --input-border: rgba(0,0,0,0.12);
            --chip-border: rgba(0,0,0,0.12);
            --chip-gradient: linear-gradient(180deg, rgba(255,255,255,0.95), rgba(240,242,245,0.8));
            --chip-shadow: 0 2px 8px rgba(0,0,0,0.08), inset 0 0 0 1px rgba(0,0,0,0.04);
            --map-border: rgba(0,0,0,0.10);
            --map-bg: #e8e8e8;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; background-image:
            radial-gradient(circle at 20% 20%, var(--bg-gradient1), transparent 40%),
            radial-gradient(circle at 80% 30%, var(--bg-gradient2), transparent 40%);
            background-attachment: fixed; transition: background 0.3s, color 0.3s; }

        .header { background: transparent; padding: 18px 12px; text-align: left; display:flex; align-items:center; justify-content:space-between; gap:12px }
        .header h1 { font-size: 20px; color: var(--text); margin-bottom: 4px; }
        .header p { color: var(--text-sub); font-size: 13px; margin-top: 2px }
        .icon { display:inline-block; font-size:16px; line-height:1; vertical-align:middle; opacity:0.9; margin-right:6px }

        .main-container { display:flex; gap:18px; max-width:1200px; margin: 12px auto; padding: 0 12px; }
        .sidebar { flex:1; min-width:260px; max-width:360px; }
        .map-container { flex:1.5; min-height:0; position: relative; }

        #map { height: 500px; border-radius: 16px; border: 2px solid rgba(255,255,255,0.18); box-shadow: 0 0 0 1px rgba(130,100,255,0.12), 0 8px 28px var(--card-shadow); background: var(--map-bg); }

        .card { background: var(--card-bg); border-radius: 16px; padding: 12px; margin-bottom: 12px; border: 1px solid var(--card-border); backdrop-filter: blur(18px) saturate(140%); box-shadow: 0 8px 28px var(--card-shadow); transition: all 0.25s ease; }
        .card h3 { color: var(--text-heading); font-size:15px; margin-bottom:10px }

        .stats-grid { display:grid; grid-template-columns: 1fr 1fr; gap:8px }
        .stat-box { background: var(--stat-bg); border:1px solid rgba(255,255,255,0.05); border-radius: 8px; padding:8px; text-align:center }

        .empty-state { color: var(--text-sub); padding:16px; font-size:12px }
        .stat-number { font-size:18px; color: var(--text) }
        .stat-label { font-size:11px; color: var(--text-sub) }

        /* Map overlays */
        .map-overlay { position:absolute; top:8px; left:8px; display:flex; gap:8px; z-index:500; }
        .overlay-pill { background: rgba(18, 24, 38, 0.55); border:1px solid rgba(255,255,255,0.06); color:#e6eef8; padding:8px 12px; border-radius:16px; font-size:12px; backdrop-filter: blur(18px) saturate(140%); box-shadow: 0 8px 28px rgba(0,0,0,0.45); transition: all 0.25s ease }
        .info-strip { position:absolute; top:8px; left:8px; right:8px; display:flex; gap:8px; flex-wrap:wrap; z-index:600 }
        .info-item { background: var(--card-bg); border:1px solid var(--card-border); color: var(--text); padding:8px 12px; border-radius:16px; font-size:12px; backdrop-filter: blur(18px) saturate(140%); box-shadow: 0 8px 28px var(--card-shadow); transition: all 0.25s ease }
        .info-label { color: var(--text-sub); margin-right:6px }
        .info-eta { background: rgba(23,32,54,0.32); border-color:#304b8a; color:#cfe3ff; font-weight:600 }
        .overlay-right { position:absolute; top:8px; right:8px; z-index:500 }
        .eta-pill { background:#172036; border-color:#304b8a; color:#cfe3ff; font-weight:600 }

        /* Route chips */
        .route-chips { display:flex; flex-wrap:wrap; gap:8px }
        .route-chip { padding:8px 12px; border-radius:999px; font-size:12px; border:1px solid var(--chip-border); cursor:pointer; background: var(--chip-gradient); color: var(--text); transition: all 0.25s ease }
        .route-chip.active { background: rgba(255,255,255,0.08); box-shadow: 0 0 0 2px rgba(255,255,255,0.12) }
            /* Glossy buttons */
            #locateMeBtn { background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0)) !important; border:1px solid rgba(255,255,255,0.06) !important; border-radius:16px !important; box-shadow: 0 8px 28px rgba(0,0,0,0.45); transition: all 0.25s ease }
        .route-chip:active { transform: scale(0.98) }

        /* Active buses smaller */
        .bus-item { display:flex; align-items:center; justify-content:space-between; padding:6px 8px; border-left:4px solid; margin-bottom:6px; font-size:12px; transition: transform 120ms ease, background 120ms ease }
        .bus-item.active-route { transform: scale(1.06); background: rgba(255,255,255,0.04) }
        .bus-info { display:flex; align-items:center; gap:8px }
        .bus-dot { width:20px; height:20px; border-radius:50%; display:flex; align-items:center; justify-content:center; color:#fff; font-size:11px }
        .bus-name { opacity:0.8 }
        .bus-item:hover .bus-name { opacity:1 }

        /* Tiny stop markers */
        .marker-wrapper { width:10px; height:10px }
        .tiny-marker { display:inline-block; width:10px; height:10px; border-radius:50%; border:1px solid rgba(0,0,0,0.6) }
        .tiny-hostel { background:#9C27B0 }
        .tiny-class { background:#2196F3 }

        /* Layer control */
        .layer-control { display:flex; gap:8px; flex-wrap:wrap }
        .toggle-item { display:flex; align-items:center; gap:8px; background: rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.06); padding:6px 8px; border-radius:8px }
        .toggle-label { font-size:12px; color: var(--text) }
        .layer-icon { width:16px; height:8px; border-radius:999px; display:inline-block; border:1px solid rgba(255,255,255,0.2) }

        /* Status pulse dot */
        .pulse { width:6px; height:6px; border-radius:50%; display:inline-block; margin-right:6px; background:#34d399; box-shadow:0 0 0 rgba(52,211,153,0.4); animation: pulse 2s infinite }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(52,211,153,0.4) } 70% { box-shadow: 0 0 0 6px rgba(52,211,153,0) } 100% { box-shadow: 0 0 0 0 rgba(52,211,153,0) } }

        .bus-icon { transition: transform 0.15s ease; }
        @keyframes spin { 0%{transform:rotate(0deg)} 100%{transform:rotate(360deg)} }
        .eta-spinner { display:inline-block;width:10px;height:10px;border:1.5px solid rgba(52,211,153,0.3);border-top-color:#34d399;border-radius:50%;animation:spin 0.8s linear infinite;vertical-align:middle;margin-right:4px }

        @media (max-width: 968px) {
            .main-container { flex-direction:column; padding:12px }
            .map-container { order: 2 }
            .sidebar { order: 1 }
            #map { height: 420px }
        }

        
        .stat-box {
            background: var(--stat-bg);
            border: 1px solid var(--stat-border);
            background-image: var(--stat-gradient);
            backdrop-filter: blur(16px) saturate(140%);
            box-shadow: 0 6px 20px var(--card-shadow), inset 0 0 0 1px var(--stat-inner);
        }
        .info-item,
        .overlay-pill {
            border: 1px solid var(--stat-border);
            background-image: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.02));
            backdrop-filter: blur(16px) saturate(140%);
            box-shadow: 0 6px 20px var(--card-shadow), inset 0 0 0 1px var(--stat-inner);
        }
        .route-chip {
            border-color: var(--chip-border);
            background-image: var(--chip-gradient);
            box-shadow: var(--chip-shadow);
        }
        /* Blur non-selected route stops */
        .marker-wrapper.stop-blur {
            filter: blur(1.6px) brightness(0.95);
            opacity: 0.6;
            transition: filter 150ms ease, opacity 150ms ease;
        }
        /* Theme toggle buttons */
        .theme-btn { padding:8px 10px; border-radius:10px; border:1px solid var(--input-border); background: var(--card-bg); color: var(--text); cursor:pointer; font-size:14px; line-height:1; transition: all 0.2s; backdrop-filter:blur(8px); }
        .theme-btn:hover { opacity:0.85; }
        .map-theme-btn { position:absolute; bottom:12px; right:12px; z-index:600; padding:7px 9px; border-radius:8px; border:1px solid rgba(255,255,255,0.15); background:rgba(18,24,38,0.8); color:#e6eef8; cursor:pointer; font-size:14px; line-height:1; backdrop-filter:blur(8px); transition:all 0.2s; box-shadow:0 2px 8px rgba(0,0,0,0.3); }
        .map-theme-btn:hover { opacity:0.85; }
    </style>
</head>
<body>
    <div class="header">
        <div>
            <h1><span class="icon">üöç</span>Campus Transport System</h1>
            <p>Powered by KIIT Transport Live tracking-Ami</p>
        </div>
        <div style="display:flex;align-items:center;gap:10px">
            <button id="globalThemeBtn" class="theme-btn" onclick="toggleGlobalTheme()" title="Toggle light/dark mode">üåô</button>
            <a href="/admin/login" target="_blank" rel="noopener noreferrer" style="color:#666;font-size:11px;text-decoration:none">Admin</a>
            <button id="locateMeBtn" style="padding:10px 12px;border-radius:10px;border:1px solid var(--input-border);background:var(--input-bg);color:var(--text);cursor:pointer">üìç Locate me</button>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <div class="card">
                <h3><span class="icon">üìä</span> Live Statistics</h3>
                <div class="stats-grid">
                    <div class="stat-box"><div class="stat-number" id="activeBusCount">0</div><div class="stat-label">Active Transport</div></div>
                    <div class="stat-box"><div class="stat-number" id="totalTransportCount">100</div><div class="stat-label">Total Transport</div></div>
                </div>
            </div>

            <div class="card">
                <h3><span>üõ£Ô∏è</span> Routes</h3>
                <div class="route-chips" id="routesContainer"></div>
                <div id="routeBusList" style="margin-top:10px"></div>
            </div>

            <div class="card" id="routeDetailsCard" style="display:none">
                <h3><span>üìç</span> Route Details</h3>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px">
                    <div style="text-align:center"><div style="font-size:12px; color:#9aa4b2">Arriving In</div><div id="etaValue" style="font-size:18px; font-weight:600; color:#34d399; margin-top:4px">--</div></div>
                    <div style="text-align:center">
                        <div style="font-size:12px; color:#9aa4b2">Nearest Stop</div>
                        <div id="walkDistance" style="font-size:18px; font-weight:600; color:#667eea; margin-top:4px">--</div>
                        <div id="nextStop" style="font-size:13px; color:#9aa4b2; margin-top:2px"></div>
                    </div>
                </div>
                <div id="busesOnRoute" style="margin-top:12px; font-size:12px; color:#9aa4b2">üöå Transports on route: <span id="busesOnRouteCount">-</span></div>
            </div>

            <div class="card">
                <h3><span>üöç</span> Active Transport</h3>
                <div class="active-buses" id="activeBuses"><div class="empty-state"><p>No Transports currently active</p></div></div>
                <div class="last-update">Last updated: <span id="lastUpdate">Loading...</span></div>
            </div>
        </div>

        <div class="map-container">
            <div class="info-strip">
                <div class="info-item"><span class="info-label">Route</span><span id="currentRouteOverlay">‚Äî</span></div>
                <div class="info-item info-eta">Arriving In: <span id="etaOverlay">--</span></div>
                <div class="info-item"><span class="info-label">Active</span><span id="activeCountOverlay">0</span></div>
                <div class="info-item"><span class="info-label">Last</span><span id="lastUpdateOverlay">‚Äî</span></div>
            </div>
            <div id="map"></div>
            <button id="mapThemeBtn" class="map-theme-btn" onclick="toggleMapTheme()" title="Toggle map light/dark">üó∫Ô∏è‚òÄÔ∏è</button>
            <div class="card" style="margin-top:10px">
                <h3><span>üìç</span> Map Layers</h3>
                <div class="layer-control">
                    <label class="toggle-item"><input type="checkbox" id="routesToggle" checked><span class="toggle-label">Routes</span><span class="layer-icon" style="background: #FF5722;"></span></label>
                    <label class="toggle-item"><input type="checkbox" id="hostelsToggle" checked><span class="toggle-label">Hostels</span><span class="layer-icon" style="background: #9C27B0;"></span></label>
                    <label class="toggle-item"><input type="checkbox" id="classesToggle" checked><span class="toggle-label">Classes</span><span class="layer-icon" style="background: #2196F3;"></span></label>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        let map;
        let busMarkers = {};
        let hostelMarkers = {};
        let classMarkers = {};
        let routePolylines = {};
        let selectedRouteId = null;
        let allRoutes = [];
        let userLocation = null;
        let walkingLine = null;
        let busRouteMap = {}; // Maps bus number to route ID
        let userMarker = null;
        let userWatchId = null;
        // Shared buses cache to avoid redundant /api/buses fetches
        let latestBuses = {};
        let sseConnected = false;
        let _eventSource = null;
        let busesPollTimerId = null;
        const POLL_INTERVAL_MS = 2000;   // fast polling fallback when SSE is down
        const RESYNC_INTERVAL_MS = 30000; // light cleanup resync every 30s
        const OFFLINE_MS = 30000; // mark bus offline after 30s of no updates
        const REMOVE_MS = 60000; // remove bus marker after 60s of no updates
        const colors = [
            '#FF3B30', '#34C759', '#007AFF', '#FF9500', '#AF52DE',
            '#5AC8FA', '#FF2D55', '#FFD60A', '#32D74B', '#5856D6',
            '#FF9F0A', '#00C7BE', '#E82D2D', '#00A8FF', '#9B59B6',
            '#F1C40F', '#2ECC71', '#E74C3C', '#3498DB', '#E67E22'
        ];

        let prevBusPositions = {};  // snapped positions for display
        let prevRawPositions = {};   // raw positions for status detection
        let prevBusTimes = {};
        let prevBusRotation = {};
        let prevTrackedState = {};
        let prevRouteSelState = {};
        let followEnabled = true;
        let busLastSeen = {};  // busNum -> Date.now() of last received update
        let busLastSSEUpdate = {};  // busNum -> Date.now() of last SSE-driven update (to skip redundant polls)
        let busDirection = {};  // busNum -> 'up' | 'down' (direction along route stops)
        let busLastStopIdx = {}; // busNum -> last nearest stop index
        let busCurrentStop = {}; // busNum -> stop name if at a stop, null otherwise
        const AT_STOP_THRESHOLD = 80; // meters - consider bus "at stop" within this distance (accounts for GPS lag)
        const busNearestStopCache = {}; // busNum -> { idx, dist, atStopName }
        const busStatusCache = {}; // busNum -> last computed status string
        const busSpeedCache = {};  // busNum -> last computed speed (km/h) or null
        const busMovedCache = {};  // busNum -> distance moved (meters) since last update
        let busTerminalStatus = {}; // busNum -> 'at_start' | 'at_destination' | 'waiting' | null
        const routeCumulDistCache = {}; // routeId -> cumulative distances array

        // Cached DOM element refs ‚Äî populated once in initMap, avoids getElementById in hot paths
        const _dom = {};
        function cacheDom() {
            _dom.activeBusCount = document.getElementById('activeBusCount');
            _dom.activeCountOverlay = document.getElementById('activeCountOverlay');
            _dom.activeBuses = document.getElementById('activeBuses');
            _dom.lastUpdate = document.getElementById('lastUpdate');
            _dom.lastUpdateOverlay = document.getElementById('lastUpdateOverlay');
            _dom.etaValue = document.getElementById('etaValue');
            _dom.etaOverlay = document.getElementById('etaOverlay');
            _dom.currentRouteOverlay = document.getElementById('currentRouteOverlay');
            _dom.busesOnRouteCount = document.getElementById('busesOnRouteCount');
            _dom.walkDistance = document.getElementById('walkDistance');
            _dom.routeDetailsCard = document.getElementById('routeDetailsCard');
            _dom.routesContainer = document.getElementById('routesContainer');
            _dom.routeBusList = document.getElementById('routeBusList');
            _dom.totalTransportCount = document.getElementById('totalTransportCount');
        }

        // Throttled time string ‚Äî toLocaleTimeString is expensive, limit to 1/sec
        let _cachedTimeStr = ''; let _cachedTimeMs = 0;
        function getTimeString() {
            const now = Date.now();
            if (now - _cachedTimeMs < 1000) return _cachedTimeStr;
            _cachedTimeMs = now;
            _cachedTimeStr = new Date(now).toLocaleTimeString();
            return _cachedTimeStr;
        }

        // Route lookup map for O(1) access (built in loadRoutes)
        const routeMap = {};

        // --- Route snapping: snap bus position to nearest point on its route polyline if within SNAP_DIST_M ---
        const SNAP_DIST_M = 30; // meters ‚Äî snap threshold
        // Cache decoded route coords: routeId -> [[lat,lng], ...]
        const routeCoordsCache = {};

        function cacheRouteCoords(routeId, latlngs) {
            routeCoordsCache[routeId] = latlngs;
        }

        // Find closest point on a polyline segment AB to point P
        function closestPointOnSegment(px, py, ax, ay, bx, by) {
            const dx = bx - ax, dy = by - ay;
            const lenSq = dx * dx + dy * dy;
            if (lenSq === 0) return [ax, ay];
            let t = ((px - ax) * dx + (py - ay) * dy) / lenSq;
            t = Math.max(0, Math.min(1, t));
            return [ax + t * dx, ay + t * dy];
        }

        function snapToRoute(lat, lng, busNum) {
            const rid = busRouteMap[busNum];
            if (!rid) return { pos: [lat, lng], segIdx: -1 };
            const coords = routeCoordsCache[rid];
            if (!coords || coords.length < 2) return { pos: [lat, lng], segIdx: -1 };

            const n = coords.length - 1;
            let bestDist = Infinity, bestPt = [lat, lng], bestSeg = -1;
            const lastSeg = (busSnapInfo[busNum] && busSnapInfo[busNum].segIdx >= 0) ? busSnapInfo[busNum].segIdx : -1;

            // Local search from last known segment (¬±30) ‚Äî fast path
            if (lastSeg >= 0) {
                const lo = Math.max(0, lastSeg - 30), hi = Math.min(n - 1, lastSeg + 30);
                for (let i = lo; i <= hi; i++) {
                    const pt = closestPointOnSegment(lat, lng, coords[i][0], coords[i][1], coords[i+1][0], coords[i+1][1]);
                    const d = calcDistance(lat, lng, pt[0], pt[1]);
                    if (d < bestDist) { bestDist = d; bestPt = pt; bestSeg = i; }
                }
                if (bestDist <= SNAP_DIST_M) return { pos: bestPt, segIdx: bestSeg };
            }
            // Full scan fallback
            for (let i = 0; i < n; i++) {
                const pt = closestPointOnSegment(lat, lng, coords[i][0], coords[i][1], coords[i+1][0], coords[i+1][1]);
                const d = calcDistance(lat, lng, pt[0], pt[1]);
                if (d < bestDist) { bestDist = d; bestPt = pt; bestSeg = i; }
            }
            if (bestDist <= SNAP_DIST_M) return { pos: bestPt, segIdx: bestSeg };
            return { pos: [lat, lng], segIdx: -1 };
        }

        // Extract sub-path along route between two snapped points
        function getRouteSubPath(rid, fromPos, fromSeg, toPos, toSeg) {
            const coords = routeCoordsCache[rid];
            if (!coords || fromSeg < 0 || toSeg < 0) return null;

            const path = [];
            // Determine direction (forward or backward along route)
            const forward = toSeg >= fromSeg;
            if (forward) {
                path.push(fromPos);
                for (let i = fromSeg + 1; i <= toSeg; i++) {
                    path.push(coords[i]);
                }
                path.push(toPos);
            } else {
                path.push(fromPos);
                for (let i = fromSeg; i >= toSeg + 1; i--) {
                    path.push(coords[i]);
                }
                path.push(toPos);
            }
            // Skip if path is too long (bus probably jumped routes) ‚Äî max ~80 segments
            if (path.length > 80) return null;
            return path;
        }

        // Compute cumulative distances along a path for proportional interpolation
        function computePathDistances(path) {
            const dists = [0];
            for (let i = 1; i < path.length; i++) {
                dists.push(dists[i-1] + calcDistance(path[i-1][0], path[i-1][1], path[i][0], path[i][1]));
            }
            return dists;
        }

        // Interpolate position along a multi-point path at fraction t (0..1)
        function interpAlongPath(path, dists, t) {
            if (path.length < 2) return path[0];
            const totalLen = dists[dists.length - 1];
            if (totalLen === 0) return path[0];
            const targetDist = t * totalLen;
            for (let i = 1; i < dists.length; i++) {
                if (dists[i] >= targetDist) {
                    const segLen = dists[i] - dists[i-1];
                    const segT = segLen > 0 ? (targetDist - dists[i-1]) / segLen : 0;
                    return [
                        path[i-1][0] + (path[i][0] - path[i-1][0]) * segT,
                        path[i-1][1] + (path[i][1] - path[i-1][1]) * segT
                    ];
                }
            }
            return path[path.length - 1];
        }

        // Tween state for smooth marker movement along route paths
        const busTweens = {}; // busNum -> { path, dists, start, dur } or { from, to, start, dur }
        const busSnapInfo = {}; // busNum -> { segIdx } ‚Äî last known segment index
        const TWEEN_MS = 800; // base tween ‚Äî overridden dynamically based on distance & 12km/h
        const BUS_SPEED_MPS = 12 / 3.6; // 12 km/h in m/s for tween timing
        function easeInOut(t){ return t<0.5 ? 2*t*t : -1+(4-2*t)*t; }

        // --- Prediction animation state ---
        // When no SSE update received, buses keep moving along route at predicted speed
        const busPrediction = {}; // busNum -> { active, segIdx, t, lastRealPos, lastRealTime, routeId }
        const PREDICTION_TIMEOUT_MS = 3000; // start predicting after 3s with no update
        const PREDICTION_MAX_MS = 30000; // stop predicting after 30s
        let _predAnimRunning = false;

        // Server-sent heading cache
        const busServerHeading = {}; // busNum -> heading degrees from server

        function queueBusTween(busNum, toPos){
            try{
                const marker = busMarkers[busNum];
                const fromPos = marker ? [marker.getLatLng().lat, marker.getLatLng().lng] : toPos;
                const rid = busRouteMap[busNum];

                // Cancel any active prediction ‚Äî real data arrived
                if (busPrediction[busNum]) { busPrediction[busNum].active = false; }

                // Skip tween if position hasn't meaningfully changed (<1m)
                const tweenDist = calcDistance(fromPos[0], fromPos[1], toPos[0], toPos[1]);
                if (tweenDist < 1) {
                    // Store real position for prediction system
                    updatePredictionState(busNum, toPos);
                    return;
                }

                // Anti-teleport: if jump > 500m, snap instantly instead of tweening
                if (tweenDist > 500) {
                    const snapResult = snapToRoute(toPos[0], toPos[1], busNum);
                    busSnapInfo[busNum] = { segIdx: snapResult.segIdx };
                    marker.setLatLng(snapResult.pos);
                    prevBusPositions[busNum] = snapResult.pos;
                    updatePredictionState(busNum, toPos);
                    return;
                }

                const fromSeg = busSnapInfo[busNum] ? busSnapInfo[busNum].segIdx : -1;

                // Try to get snap info for the destination
                const snapResult = snapToRoute(toPos[0], toPos[1], busNum);
                const snappedTo = snapResult.pos;
                const toSeg = snapResult.segIdx;
                busSnapInfo[busNum] = { segIdx: toSeg };

                // Try to build a route sub-path for curved animation
                let routePath = null;
                if (rid && fromSeg >= 0 && toSeg >= 0) {
                    routePath = getRouteSubPath(rid, fromPos, fromSeg, snappedTo, toSeg);
                }

                // Calculate tween duration proportional to distance at 12km/h (clamped)
                const dur = Math.max(TWEEN_MS, Math.min(3000, (tweenDist / BUS_SPEED_MPS) * 1000));

                if (routePath && routePath.length >= 2) {
                    const dists = computePathDistances(routePath);
                    busTweens[busNum] = { path: routePath, dists: dists, start: Date.now(), dur: dur };
                } else {
                    // Fallback: straight-line tween
                    busTweens[busNum] = { from: fromPos, to: snappedTo, start: Date.now(), dur: dur };
                }
                // Store real position for prediction system
                updatePredictionState(busNum, toPos);
                requestAnimationFrame(animateBusTweens);
            }catch(e){ /* ignore */ }
        }

        // --- Prediction animation helpers ---
        function updatePredictionState(busNum, realPos) {
            const rid = busRouteMap[busNum];
            const snapInfo = busSnapInfo[busNum];
            busPrediction[busNum] = {
                active: false,
                segIdx: snapInfo ? snapInfo.segIdx : -1,
                t: 0,
                lastRealPos: realPos,
                lastRealTime: Date.now(),
                routeId: rid || null
            };
        }

        function startPredictionLoop() {
            if (_predAnimRunning) return;
            _predAnimRunning = true;
            requestAnimationFrame(predictionTick);
        }

        function predictionTick(now) {
            let anyActive = false;
            const nowMs = Date.now();
            for (const busNum in busPrediction) {
                const pred = busPrediction[busNum];
                if (!pred || !pred.routeId) continue;
                const marker = busMarkers[busNum];
                if (!marker) continue;
                const timeSinceReal = nowMs - pred.lastRealTime;
                const status = busStatusCache[busNum];

                // Don't predict for idle/offline/at-stop buses
                if (status && (status === 'Idle' || status === 'Offline' || status === 'At Stop' ||
                    status === 'Reached Destination' || status === 'At Start' || status === 'Waiting for Update')) {
                    pred.active = false;
                    continue;
                }

                // Start predicting after PREDICTION_TIMEOUT_MS of no update
                if (timeSinceReal >= PREDICTION_TIMEOUT_MS && timeSinceReal <= PREDICTION_MAX_MS && !pred.active) {
                    // Activate prediction: initialize from current snap position
                    pred.active = true;
                    pred.predStartTime = nowMs;
                    const coords = routeCoordsCache[pred.routeId];
                    if (!coords || coords.length < 2 || pred.segIdx < 0) { pred.active = false; continue; }
                    // Find fractional position on segment
                    const curLL = marker.getLatLng();
                    const a = coords[pred.segIdx], b = coords[Math.min(pred.segIdx + 1, coords.length - 1)];
                    const dx = b[0] - a[0], dy = b[1] - a[1];
                    const lenSq = dx * dx + dy * dy;
                    pred.t = lenSq > 0 ? Math.max(0, Math.min(1, ((curLL.lat - a[0]) * dx + (curLL.lng - a[1]) * dy) / lenSq)) : 0;
                }

                if (!pred.active) continue;
                if (timeSinceReal > PREDICTION_MAX_MS) { pred.active = false; continue; }

                anyActive = true;
                const coords = routeCoordsCache[pred.routeId];
                if (!coords || coords.length < 2) { pred.active = false; continue; }

                // Move along route at 12km/h
                const dir = busDirection[busNum];
                const forward = dir !== 'up'; // default forward = down (increasing index)
                const speedDegPerSec = BUS_SPEED_MPS / 111320;
                const dt = 1 / 60; // assume ~60fps frame time
                let remaining = speedDegPerSec * dt;

                if (forward) {
                    while (remaining > 0 && pred.segIdx < coords.length - 1) {
                        const a = coords[pred.segIdx], b = coords[pred.segIdx + 1];
                        const segDx = b[0] - a[0], segDy = b[1] - a[1];
                        const segLen = Math.sqrt(segDx * segDx + segDy * segDy);
                        if (segLen === 0) { pred.segIdx++; pred.t = 0; continue; }
                        const left = (1 - pred.t) * segLen;
                        if (remaining >= left) { remaining -= left; pred.segIdx++; pred.t = 0; }
                        else { pred.t += remaining / segLen; remaining = 0; }
                    }
                    if (pred.segIdx >= coords.length - 1) { pred.segIdx = coords.length - 2; pred.t = 1; pred.active = false; }
                } else {
                    while (remaining > 0 && (pred.segIdx > 0 || pred.t > 0)) {
                        const a = coords[pred.segIdx], b = coords[pred.segIdx + 1];
                        const segDx = b[0] - a[0], segDy = b[1] - a[1];
                        const segLen = Math.sqrt(segDx * segDx + segDy * segDy);
                        if (segLen === 0) { if (pred.segIdx > 0) { pred.segIdx--; pred.t = 1; } else { pred.t = 0; } continue; }
                        const left = pred.t * segLen;
                        if (remaining >= left) { remaining -= left; if (pred.segIdx > 0) { pred.segIdx--; pred.t = 1; } else { pred.t = 0; pred.active = false; } }
                        else { pred.t -= remaining / segLen; remaining = 0; }
                    }
                }

                // Set marker position
                const sa = coords[pred.segIdx], sb = coords[Math.min(pred.segIdx + 1, coords.length - 1)];
                const pLat = sa[0] + pred.t * (sb[0] - sa[0]);
                const pLng = sa[1] + pred.t * (sb[1] - sa[1]);
                try { marker.setLatLng([pLat, pLng]); } catch(e) {}

                // Update snap info for when real data arrives (so tween routes correctly)
                busSnapInfo[busNum] = { segIdx: pred.segIdx };
            }
            if (anyActive) requestAnimationFrame(predictionTick);
            else _predAnimRunning = false;
        }

        function animateBusTweens(){
            let any = false;
            const now = Date.now();
            for (const busNum in busTweens) {
                const tw = busTweens[busNum];
                const marker = busMarkers[busNum]; if(!marker) continue;
                const t = Math.min(1, (now - tw.start) / tw.dur);
                const k = easeInOut(t);
                let lat, lng;
                if (tw.path) {
                    const pos = interpAlongPath(tw.path, tw.dists, k);
                    lat = pos[0]; lng = pos[1];
                } else {
                    lat = tw.from[0] + (tw.to[0]-tw.from[0]) * k;
                    lng = tw.from[1] + (tw.to[1]-tw.from[1]) * k;
                }
                try{ marker.setLatLng([lat,lng]); if(t<1) any = true; }catch(e){}
                if (trackedBus && busNum === trackedBus && followEnabled && map) {
                    try {
                        const px = map.latLngToContainerPoint([lat, lng]);
                        const sz = map.getSize();
                        const margin = 80;
                        if (px.x < margin || px.x > sz.x - margin || px.y < margin || px.y > sz.y - margin) {
                            map.panTo([lat, lng], { animate: true, duration: 0.3 });
                        }
                    } catch(e) {}
                }
                if(t>=1){ delete busTweens[busNum]; }
            }
            if(any) requestAnimationFrame(animateBusTweens);
        }

        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition((pos) => {
                userLocation = [pos.coords.latitude, pos.coords.longitude];
                if (map) { updateUserMarker(userLocation); }
            }, (err) => console.log('Geolocation error:', err));
        }

        function updateUserMarker(latlng){
            try{
                if(!map) return;
                if(!userMarker){
                    userMarker = L.circleMarker(latlng, { radius: 6, color: '#ffffff', weight: 2, fillColor: '#34d399', fillOpacity: 1 }).addTo(map);
                }else{
                    userMarker.setLatLng(latlng);
                }
            }catch(e){ /* ignore */ }
        }

        async function loadBusRoutes() {
            try { const res = await fetch('/api/bus-routes'); busRouteMap = await res.json(); } catch(e) { console.error('Error loading bus routes:', e); }
        }

        // Fast equirectangular distance ‚Äî accurate within 0.1% at campus scale
        const _DEG2RAD = Math.PI / 180;
        function calcDistance(lat1, lng1, lat2, lng2) {
            const dLat = (lat2 - lat1) * _DEG2RAD;
            const dLng = (lng2 - lng1) * _DEG2RAD;
            const x = dLng * Math.cos((lat1 + lat2) * 0.5 * _DEG2RAD);
            return 6371000 * Math.sqrt(dLat * dLat + x * x);
        }
        // Geographic bearing: 0¬∞=north, clockwise. Input: [lat,lng] pairs.
        function calcBearing(from, to) {
            const dLng = (to[1] - from[1]) * _DEG2RAD;
            const lat1 = from[0] * _DEG2RAD, lat2 = to[0] * _DEG2RAD;
            const y = Math.sin(dLng) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLng);
            return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360; // 0-360¬∞
        }

        // --- Route distance computation (along polyline) ---
        function ensureRouteCumulDist(routeId) {
            if (routeCumulDistCache[routeId]) return routeCumulDistCache[routeId];
            const coords = routeCoordsCache[routeId];
            if (!coords || coords.length < 2) return null;
            const cumul = [0];
            for (let i = 1; i < coords.length; i++) {
                cumul.push(cumul[i-1] + calcDistance(coords[i-1][0], coords[i-1][1], coords[i][0], coords[i][1]));
            }
            routeCumulDistCache[routeId] = cumul;
            return cumul;
        }
        function getDistAlongRoute(routeId, pos) {
            const coords = routeCoordsCache[routeId];
            const cumul = ensureRouteCumulDist(routeId);
            if (!coords || !cumul || coords.length < 2) return null;
            let bestDist = Infinity, bestSeg = 0, bestT = 0;
            for (let i = 0; i < coords.length - 1; i++) {
                const ax = coords[i][0], ay = coords[i][1], bx = coords[i+1][0], by = coords[i+1][1];
                const dx = bx - ax, dy = by - ay;
                const lenSq = dx * dx + dy * dy;
                let t = lenSq > 0 ? ((pos[0] - ax) * dx + (pos[1] - ay) * dy) / lenSq : 0;
                t = Math.max(0, Math.min(1, t));
                const px = ax + t * dx, py = ay + t * dy;
                const d = calcDistance(pos[0], pos[1], px, py);
                if (d < bestDist) { bestDist = d; bestSeg = i; bestT = t; }
            }
            const segLen = cumul[bestSeg + 1] - cumul[bestSeg];
            return cumul[bestSeg] + bestT * segLen;
        }
        function getRouteDistanceBetween(routeId, posA, posB) {
            if (!routeId) return null;
            const d1 = getDistAlongRoute(routeId, posA);
            const d2 = getDistAlongRoute(routeId, posB);
            if (d1 === null || d2 === null) return null;
            return Math.abs(d2 - d1);
        }

        // Get bearing for bus icon rotation.
        // Returns CSS rotation degrees (0¬∞ = arrow pointing right/east).
        // SVG arrow points right, so we subtract 90¬∞ from geographic bearing (0¬∞=north).
        function getRouteBearing(busNum) {
            let geoBearing;
            // Use server-sent heading if available (from driver's device) ‚Äî already geographic
            if (busServerHeading[busNum] !== undefined && busServerHeading[busNum] !== null) {
                geoBearing = busServerHeading[busNum];
            } else {
                const rid = busRouteMap[busNum];
                if (!rid) return prevBusRotation[busNum] || 0;
                const coords = routeCoordsCache[rid];
                const snapInfo = busSnapInfo[busNum];
                if (!coords || !snapInfo || snapInfo.segIdx < 0 || snapInfo.segIdx >= coords.length - 1) return prevBusRotation[busNum] || 0;
                const i = snapInfo.segIdx;
                // Geographic bearing of this route segment (forward direction = 'down')
                const fwd = calcBearing(coords[i], coords[i + 1]);
                // If bus is going 'up' (toward index 0), flip 180¬∞
                const dir = busDirection[busNum];
                geoBearing = dir === 'up' ? (fwd + 180) % 360 : fwd;
            }
            // Convert geographic bearing (0¬∞=north) to CSS rotation (0¬∞=right/east)
            return (geoBearing - 90 + 360) % 360;
        }

        // Zoom-responsive icon sizing (~55% of original)
        let currentIconSize = 12;
        function getIconSizeForZoom(z) {
            if (z >= 18) return 16;
            if (z >= 17) return 14;
            if (z >= 16) return 12;
            if (z >= 15) return 11;
            return 10;
        }

        const _iconSvgCache = {};
        function createIcon(busNum, color, size, rotation = 0, glow = false) {
            size = size || currentIconSize;
            const cacheKey = `${busNum}_${color}_${size}_${glow ? 1 : 0}`;
            let cached = _iconSvgCache[cacheKey];
            if (!cached) {
                const h = size;
                const bodyW = Math.round(size * 1.2);
                const arrowW = Math.round(size * 0.5);
                const w = bodyW + arrowW;
                const r = Math.round(h * 0.38);
                const mid = Math.round(h / 2);
                const fontSize = Math.max(8, Math.round(h * 0.44));
                const shape = `M${r},0 H${bodyW} L${w},${mid} L${bodyW},${h} H${r} A${r},${r} 0 0,1 0,${h-r} V${r} A${r},${r} 0 0,1 ${r},0Z`;
                const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" style="filter:drop-shadow(0 1px 4px rgba(0,0,0,0.5))">
${glow ? `<path d="${shape}" fill="none" stroke="${color}" stroke-width="6" opacity="0.35"/>` : ''}
<path d="${shape}" fill="${color}" stroke="#fff" stroke-width="1.5" stroke-linejoin="round"/>
<text x="${Math.round(bodyW * 0.45)}" y="${mid}" text-anchor="middle" dominant-baseline="central" fill="#fff" font-family="Segoe UI,Arial" font-weight="800" font-size="${fontSize}" style="text-shadow:0 1px 2px rgba(0,0,0,0.6)">${busNum}</text></svg>`;
                const anchorX = Math.round(bodyW / 2);
                cached = { svg, w, h, anchorX, anchorY: mid };
                _iconSvgCache[cacheKey] = cached;
            }
            const rot = Math.round(rotation);
            return L.divIcon({
                className: 'bus-icon',
                html: `<div style="transform:rotate(${rot}deg);transform-origin:${cached.anchorX}px ${cached.anchorY}px">${cached.svg}</div>`,
                iconSize: [cached.w, cached.h],
                iconAnchor: [cached.anchorX, cached.anchorY],
                popupAnchor: [0, -cached.anchorY - 4]
            });
        }

        function createLocationIcon(type) { const html = type === 'hostel' ? '<span class="tiny-marker tiny-hostel"></span>' : '<span class="tiny-marker tiny-class"></span>'; return L.divIcon({ className: 'marker-wrapper', html, iconSize: [10,10], iconAnchor: [5,5], popupAnchor: [0, -8] }); }

        let trackedBus = null;
        let visibleLayers = { routes: true, hostels: true, classes: true };

        function parseIsoTime(iso) { try { const t = new Date(iso).getTime(); return isNaN(t) ? null : t; } catch(e) { return null; } }
        function computeSpeed(busNum, position, lastUpdateIso) {
            const prevPos = prevRawPositions[busNum]; const prevTime = prevBusTimes[busNum]; const currTime = parseIsoTime(lastUpdateIso);
            if (!prevPos || !prevTime || !currTime) return null;
            const timeDelta = (currTime - prevTime) / 1000;
            // Need at least 1.5s between samples for meaningful speed
            if (timeDelta < 1.5) return null;
            const meters = calcDistance(prevPos[0], prevPos[1], position[0], position[1]);
            const kmh = (meters / 1000) / (timeDelta / 3600);
            // Cap at 120 km/h ‚Äî anything higher is GPS noise
            if (kmh > 120) return null;
            return Math.round(kmh);
        }
        // Cache speed and movement BEFORE overwriting prevRawPositions ‚Äî fixes race condition
        function cacheSpeedAndMovement(busNum, newLat, newLng, lastUpdateIso) {
            const pRaw = prevRawPositions[busNum];
            const pTime = prevBusTimes[busNum];
            const cTime = parseIsoTime(lastUpdateIso);
            if (pRaw && pTime && cTime) {
                const dt = (cTime - pTime) / 1000;
                const dist = calcDistance(pRaw[0], pRaw[1], newLat, newLng);
                busMovedCache[busNum] = dist;
                if (dt >= 1.5) {
                    const kmh = (dist / 1000) / (dt / 3600);
                    busSpeedCache[busNum] = (kmh <= 120 && kmh > 0.1) ? Math.round(kmh) : (busSpeedCache[busNum] || null);
                }
            }
        }
        // Combined stop/direction update ‚Äî prefer server-sent data, fallback to client computation
        function updateBusStopInfo(busNum, rawPosition, serverStopData) {
            const routeId = busRouteMap[busNum];
            const route = routeId ? getRouteById(routeId) : null;

            // If server sent stop info, use it directly (avoids redundant N-client computation)
            if (serverStopData && serverStopData.nearestStopIdx !== undefined && serverStopData.nearestStopIdx !== null) {
                const bestIdx = serverStopData.nearestStopIdx;
                const atStopName = serverStopData.atStop || null;
                const dir = serverStopData.direction || busDirection[busNum];
                if (dir) busDirection[busNum] = dir;
                busLastStopIdx[busNum] = bestIdx;
                busCurrentStop[busNum] = atStopName;
                // Terminal status detection
                const len = (route && route.waypoints) ? route.waypoints.length : 0;
                if (atStopName && len > 0) {
                    if (dir === 'down' && bestIdx === len - 1) { busTerminalStatus[busNum] = 'at_destination'; }
                    else if (dir === 'up' && bestIdx === 0) { busTerminalStatus[busNum] = 'at_destination'; }
                    else if (dir === 'down' && bestIdx === 0) { busTerminalStatus[busNum] = 'at_start'; }
                    else if (dir === 'up' && bestIdx === len - 1) { busTerminalStatus[busNum] = 'at_start'; }
                    else if (!dir && (bestIdx === 0 || bestIdx === len - 1)) { busTerminalStatus[busNum] = 'waiting'; }
                    else { busTerminalStatus[busNum] = null; }
                } else { busTerminalStatus[busNum] = null; }
                const bestD = route ? calcDistance(rawPosition[0], rawPosition[1], route.waypoints[bestIdx][0], route.waypoints[bestIdx][1]) : 0;
                busNearestStopCache[busNum] = { idx: bestIdx, dist: bestD, atStopName };
                return;
            }

            // Fallback: client-side computation (for polling responses without stop data)
            if (!route || !route.waypoints || route.waypoints.length < 2) return;
            const wps = route.waypoints, len = wps.length;
            let bestIdx = 0, bestD = Infinity;
            for (let i = 0; i < len; i++) {
                const d = calcDistance(rawPosition[0], rawPosition[1], wps[i][0], wps[i][1]);
                if (d < bestD) { bestD = d; bestIdx = i; }
            }
            // Direction
            const prevIdx = busLastStopIdx[busNum];
            if (prevIdx !== undefined && prevIdx !== bestIdx) {
                busDirection[busNum] = bestIdx > prevIdx ? 'down' : 'up';
            }
            busLastStopIdx[busNum] = bestIdx;
            // At-stop check
            const atStopName = bestD <= AT_STOP_THRESHOLD
                ? ((route.stops && route.stops[bestIdx]) ? route.stops[bestIdx] : `Stop ${bestIdx + 1}`)
                : null;
            if (atStopName) { busCurrentStop[busNum] = atStopName; } else { busCurrentStop[busNum] = null; }
            // Terminal status detection (first/last stop based on direction)
            const dir = busDirection[busNum];
            if (atStopName) {
                if (dir === 'down' && bestIdx === len - 1) { busTerminalStatus[busNum] = 'at_destination'; }
                else if (dir === 'up' && bestIdx === 0) { busTerminalStatus[busNum] = 'at_destination'; }
                else if (dir === 'down' && bestIdx === 0) { busTerminalStatus[busNum] = 'at_start'; }
                else if (dir === 'up' && bestIdx === len - 1) { busTerminalStatus[busNum] = 'at_start'; }
                else if (!dir && (bestIdx === 0 || bestIdx === len - 1)) { busTerminalStatus[busNum] = 'waiting'; }
                else { busTerminalStatus[busNum] = null; }
            } else { busTerminalStatus[busNum] = null; }
            busNearestStopCache[busNum] = { idx: bestIdx, dist: bestD, atStopName };
        }
        function determineStatus(busNum, rawPosition, lastUpdateIso) {
            const nowMs = Date.now();
            const lastSeen = busLastSeen[busNum] || 0;
            const serverTime = parseIsoTime(lastUpdateIso);
            const effectiveTime = Math.max(lastSeen, serverTime || 0);
            if (!effectiveTime || (nowMs - effectiveTime) > OFFLINE_MS) { busStatusCache[busNum] = 'Offline'; return 'Offline'; }
            // Terminal status from updateBusStopInfo
            const terminal = busTerminalStatus[busNum];
            if (terminal === 'at_destination') { busStatusCache[busNum] = 'Reached Destination'; return 'Reached Destination'; }
            if (terminal === 'at_start') { busStatusCache[busNum] = 'At Start'; return 'At Start'; }
            if (terminal === 'waiting') { busStatusCache[busNum] = 'Waiting for Update'; return 'Waiting for Update'; }
            // Use cached at-stop result from updateBusStopInfo
            if (busCurrentStop[busNum]) { busStatusCache[busNum] = 'At Stop'; return 'At Stop'; }
            // Use cached movement distance (computed BEFORE prevRawPositions was overwritten)
            const moved = busMovedCache[busNum];
            if (moved !== undefined && moved < 5) { busStatusCache[busNum] = 'Idle'; return 'Idle'; }
            busStatusCache[busNum] = 'Moving'; return 'Moving';
        }
        function getRouteById(id) { return routeMap[id] || allRoutes.find(r => r.id === id); }
        function getStopsForBus(route, position, busNum) {
            if (!route || !route.waypoints || route.waypoints.length === 0) return { last: null, next: null };
            // Terminal status handling
            const terminal = busNum ? busTerminalStatus[busNum] : null;
            const getName = (idx) => (route.stops && route.stops[idx]) ? route.stops[idx] : `Stop ${idx + 1}`;
            if (terminal === 'at_destination') {
                return { last: busCurrentStop[busNum] || 'Destination', next: null };
            }
            if (terminal === 'at_start') {
                const dirS = busDirection[busNum];
                const curIdx = busNearestStopCache[busNum] ? busNearestStopCache[busNum].idx : 0;
                const nextIdx = dirS === 'up' ? Math.max(0, curIdx - 1) : Math.min(route.waypoints.length - 1, curIdx + 1);
                return { last: null, next: nextIdx !== curIdx ? getName(nextIdx) : null };
            }
            // Use cached nearest stop from updateBusStopInfo if available
            const cached = busNum ? busNearestStopCache[busNum] : null;
            let bestIdx, bestD;
            if (cached) { bestIdx = cached.idx; bestD = cached.dist; }
            else { bestIdx = 0; bestD = Infinity; for (let i = 0; i < route.waypoints.length; i++) { const d = calcDistance(position[0], position[1], route.waypoints[i][0], route.waypoints[i][1]); if (d < bestD) { bestD = d; bestIdx = i; } } }
            const dir = busNum ? busDirection[busNum] : null;
            let lastIdx, nextIdx;
            if (dir === 'up') {
                // Moving toward index 0
                lastIdx = Math.min(route.waypoints.length - 1, bestIdx + 1);
                nextIdx = Math.max(0, bestIdx - 1);
                if (bestIdx === 0) { lastIdx = 1; nextIdx = 0; }
                if (bestIdx === route.waypoints.length - 1) { lastIdx = bestIdx; }
            } else {
                // Moving toward last stop ('down' or unknown)
                lastIdx = Math.max(0, bestIdx - 1);
                nextIdx = Math.min(route.waypoints.length - 1, bestIdx + 1);
                if (bestIdx === 0) { lastIdx = 0; }
                if (bestIdx === route.waypoints.length - 1) { lastIdx = bestIdx - 1; nextIdx = bestIdx; }
            }
            // If bus is AT the nearest stop, last=current stop, next=the one ahead in direction
            if (bestD <= AT_STOP_THRESHOLD) {
                lastIdx = bestIdx;
                if (dir === 'up') { nextIdx = Math.max(0, bestIdx - 1); }
                else { nextIdx = Math.min(route.waypoints.length - 1, bestIdx + 1); }
                // If at terminal, next is same as current
                if (nextIdx === bestIdx) nextIdx = bestIdx;
            }
            return {
                last: getName(lastIdx),
                next: (nextIdx !== lastIdx) ? getName(nextIdx) : null
            };
        }
        function buildBusPopup(busNum, busData) {
            const routeId = busRouteMap[busNum]; const route = getRouteById(routeId); const position = [busData.lat, busData.lng]; const status = determineStatus(busNum, position, busData.lastUpdate); const speed = busSpeedCache[busNum] || null; const routeName = route ? route.name : '‚Äî'; const last = busData.lastUpdate ? new Date(busData.lastUpdate).toLocaleTimeString() : '‚Äî';
            const statusColor = status==='Moving'?'#34d399':status==='At Stop'?'#5AC8FA':status==='Idle'?'#fbbf24':status==='Reached Destination'?'#a78bfa':status==='At Start'?'#60a5fa':status==='Waiting for Update'?'#fbbf24':'#fb7185';
            const atStopName = busCurrentStop[busNum];
            const speedDisplay = (speed !== null && speed !== undefined) ? speed + ' km/h' : '‚Äî';
            const stops = route ? getStopsForBus(route, position, busNum) : { last: null, next: null };
            const statusText = (status === 'Reached Destination' && atStopName) ? `Reached: ${atStopName}` : (status === 'At Start' && atStopName) ? `At Start: ${atStopName}` : (status === 'At Stop' && atStopName) ? `At Stop: ${atStopName}` : status;
            let html = `<div style="min-width:220px;background:#0f1220;color:#e6eef8;border:1px solid rgba(255,255,255,0.08);border-radius:10px;padding:10px">`;
            html += `<div style="font-weight:600;margin-bottom:6px">Transport ${busNum}</div>`;
            html += `<div style="font-size:13px;color:#9aa4b2">Route: <span style="color:#dbeafe">${routeName}</span></div>`;
            html += `<div style="font-size:13px;color:#9aa4b2">Status: <span style="color:${statusColor}">${statusText}</span></div>`;
            html += `<div style="font-size:13px;color:#9aa4b2">Speed: <span style="color:#dbeafe">${speedDisplay}</span></div>`;
            html += `<div style="font-size:13px;color:#9aa4b2">Last stop: <span style="color:#dbeafe">${stops.last || '‚Äî'}</span></div>`;
            html += `<div style="font-size:13px;color:#9aa4b2">Next stop: <span style="color:#dbeafe">${stops.next || '‚Äî'}</span></div>`;
            html += `<div style="font-size:11px;color:#667;margin-top:4px">Updated: ${last}</div>`;
            html += `</div>`;
            return html;
        }

        function updateLayerVisibility(layer, visible) {
            visibleLayers[layer] = visible;
            if (layer === 'hostels') { Object.values(hostelMarkers).forEach(m => { if (visible) map.addLayer(m); else map.removeLayer(m); }); }
            else if (layer === 'classes') { Object.values(classMarkers).forEach(m => { if (visible) map.addLayer(m); else map.removeLayer(m); }); }
            else if (layer === 'routes') { Object.values(routePolylines).forEach(p => { if (visible) map.addLayer(p); else map.removeLayer(p); }); }
        }

        function loadHostels() {
            fetch('/api/hostels').then(r => r.json()).then(hostels => { Object.values(hostelMarkers).forEach(m => map.removeLayer(m)); hostelMarkers = {}; hostels.forEach(hostel => { const marker = L.marker([hostel.lat, hostel.lng], { icon: createLocationIcon('hostel'), title: hostel.name }).addTo(map); marker.bindPopup(`<b>${hostel.name}</b><br>Capacity: ${hostel.capacity}`); hostelMarkers[hostel.id] = marker; if (!visibleLayers.hostels) map.removeLayer(marker); }); }).catch(e => console.error('Error loading hostels:', e));
        }
        function loadClasses() {
            fetch('/api/classes').then(r => r.json()).then(classes => { Object.values(classMarkers).forEach(m => map.removeLayer(m)); classMarkers = {}; classes.forEach(cls => { const marker = L.marker([cls.lat, cls.lng], { icon: createLocationIcon('class'), title: cls.name }).addTo(map); marker.bindPopup(`<b>${cls.name}</b><br>Dept: ${cls.department}`); classMarkers[cls.id] = marker; if (!visibleLayers.classes) map.removeLayer(marker); }); }).catch(e => console.error('Error loading classes:', e));
        }

        function loadRoutes() {
            fetch('/api/routes').then(r => r.json()).then(routes => {
                Object.values(routePolylines).forEach(p => map.removeLayer(p)); routePolylines = {}; allRoutes = routes;
                // Build O(1) lookup map
                for (let i = 0; i < routes.length; i++) routeMap[routes[i].id] = routes[i];
                routes.forEach(route => { getOSRMRoute(route.waypoints).then(routeCoords => { const coords = routeCoords || route.waypoints; cacheRouteCoords(route.id, coords); const polyline = L.polyline(coords, { color: route.color, weight: 4, opacity: 0.8, dashArray: '5, 5' }).addTo(map); polyline.bindPopup(`<b>${route.name}</b>`); polyline.on('click', () => selectRoute(route.id)); route.waypoints.forEach((wp, idx) => { const stopName = (route.stops && route.stops[idx]) || `Stop ${idx + 1}`; const icon = L.divIcon({ className: 'marker-wrapper', html: `<span class=\"tiny-marker\" style=\"background:${route.color}\"></span>`, iconSize:[10,10], iconAnchor:[5,5] }); const marker = L.marker([wp[0], wp[1]], { icon }).addTo(map); marker.bindTooltip(stopName, { direction: 'top', offset: [0, -8] }); marker.on('click', () => selectRoute(route.id)); routePolylines[`${route.id}-stop-${idx}`] = marker; }); routePolylines[route.id] = polyline; if (!visibleLayers.routes) map.removeLayer(polyline); }).catch(()=>{ // Fallback: draw original waypoints
                    const coords = route.waypoints; cacheRouteCoords(route.id, coords); const polyline = L.polyline(coords, { color: route.color, weight: 4, opacity: 0.8, dashArray: '5, 5' }).addTo(map); polyline.bindPopup(`<b>${route.name}</b>`); polyline.on('click', () => selectRoute(route.id)); route.waypoints.forEach((wp, idx) => { const stopName = (route.stops && route.stops[idx]) || `Stop ${idx + 1}`; const icon = L.divIcon({ className: 'marker-wrapper', html: `<span class=\"tiny-marker\" style=\"background:${route.color}\"></span>`, iconSize:[10,10], iconAnchor:[5,5] }); const marker = L.marker([wp[0], wp[1]], { icon }).addTo(map); marker.bindTooltip(stopName, { direction: 'top', offset: [0, -8] }); marker.on('click', () => selectRoute(route.id)); routePolylines[`${route.id}-stop-${idx}`] = marker; }); routePolylines[route.id] = polyline; if (!visibleLayers.routes) map.removeLayer(polyline); }); }); renderRoutesList(routes); }).catch(e => console.error('Error loading routes:', e));
        }

        // OSRM helpers with timeout + graceful fallback
        async function osrmFetch(url, timeoutMs=5000){
            const ctrl = new AbortController(); const t = setTimeout(()=>ctrl.abort(), timeoutMs);
            try{ const res = await fetch(url, { signal: ctrl.signal }); clearTimeout(t); if(!res.ok) throw new Error(`HTTP ${res.status}`); return await res.json(); }catch(e){ clearTimeout(t); throw e; }
        }
        async function getOSRMRoute(waypoints) {
            try { if (waypoints.length < 2) return waypoints; const coords = waypoints.map(wp => `${wp[1]},${wp[0]}`).join(';'); const url = `https://router.project-osrm.org/route/v1/driving/${coords}?geometries=geojson`; const data = await osrmFetch(url, 5000); if (data.routes && data.routes[0]) { return data.routes[0].geometry.coordinates.map(c => [c[1], c[0]]); } return waypoints; } catch(e) { console.warn('OSRM route fallback:', e); return waypoints; }
        }

        async function getOSRMDuration(fromLatLng, toLatLng) {
            try { const coords = `${fromLatLng[1]},${fromLatLng[0]};${toLatLng[1]},${toLatLng[0]}`; const url = `https://router.project-osrm.org/route/v1/driving/${coords}?overview=false`; const data = await osrmFetch(url, 5000); if (data.routes && data.routes[0]) { return { distance: data.routes[0].distance, duration: data.routes[0].duration }; } } catch(e) { console.warn('OSRM duration fallback:', e); }
            // Fallback: straight-line distance and average speed
            const meters = calcDistance(fromLatLng[0], fromLatLng[1], toLatLng[0], toLatLng[1]); const avgKmh = 25; const duration = Math.ceil((meters/1000)/avgKmh * 3600); return { distance: meters, duration };
        }
        async function getOSRMMinDurationToStop(busPoints, stopPoint) { try { if (!busPoints || busPoints.length === 0 || !stopPoint) return null; const points = [...busPoints, stopPoint]; const destIndex = points.length - 1; const coords = points.map(p => `${p[1]},${p[0]}`).join(';'); const sources = busPoints.map((_, i) => i).join(';'); const url = `https://router.project-osrm.org/table/v1/driving/${coords}?sources=${sources}&destinations=${destIndex}`; const res = await fetch(url); const data = await res.json(); if (data && data.durations && Array.isArray(data.durations)) { const mins = data.durations.map(row => row && row.length ? row[0] : Infinity).reduce((a, b) => Math.min(a, b), Infinity); return isFinite(mins) ? mins : null; } } catch(e) { console.error('OSRM table error:', e); } return null; }

        function renderRoutesList(routes) {
            const container = _dom.routesContainer || document.getElementById('routesContainer'); if (routes.length === 0) { container.innerHTML = '<div style="text-align:center; color:#666; font-size:12px">No routes available</div>'; return; }
            container.innerHTML = '';
            routes.forEach(route => {
                const chip = document.createElement('button');
                const isActive = String(selectedRouteId) === String(route.id);
                chip.className = `route-chip ${isActive ? 'active' : ''}`;
                chip.style.borderColor = route.color;
                chip.textContent = isActive ? `‚úì ${route.name}` : route.name;
                chip.setAttribute('aria-selected', isActive ? 'true' : 'false');
                if (isActive) {
                    chip.style.boxShadow = `0 0 0 2px ${route.color}55`;
                    chip.style.background = 'rgba(255,255,255,0.08)';
                }
                chip.addEventListener('click', () => { selectRoute(route.id); });
                container.appendChild(chip);
            });
        }

        function renderRouteBusByETA() {
            const container = _dom.routeBusList || document.getElementById('routeBusList');
            if (!container) return;
            if (!selectedRouteId) { container.innerHTML = ''; return; }
            const route = getRouteById(selectedRouteId);
            if (!route || !route.waypoints || route.waypoints.length === 0) { container.innerHTML = ''; return; }
            const refLocation = (userLocation && userLocation.length === 2) ? userLocation : (map ? [map.getCenter().lat, map.getCenter().lng] : null);
            let nearestStop = route.waypoints[0], nearestStopIdx = 0;
            if (refLocation) {
                let minD = Infinity;
                route.waypoints.forEach((wp, idx) => { const d = calcDistance(refLocation[0], refLocation[1], wp[0], wp[1]); if (d < minD) { minD = d; nearestStop = wp; nearestStopIdx = idx; } });
            }
            const nowMs = Date.now();
            const busesOnRoute = [];
            Object.entries(latestBuses).forEach(([busNum, b]) => {
                if (!b || typeof b.lat !== 'number' || typeof b.lng !== 'number') return;
                const rid = (b.routeId != null) ? String(b.routeId) : (busRouteMap[busNum] != null ? String(busRouteMap[busNum]) : null);
                if (rid !== String(selectedRouteId)) return;
                const t = b.lastUpdate ? parseIsoTime(b.lastUpdate) : null;
                const lastSeen = busLastSeen[busNum] || 0;
                const effectiveTime = Math.max(lastSeen, t || 0);
                if (!effectiveTime || (nowMs - effectiveTime) > OFFLINE_MS) return;
                const rdId = rid;
                const distM = getRouteDistanceBetween(rdId, [b.lat, b.lng], nearestStop) || calcDistance(b.lat, b.lng, nearestStop[0], nearestStop[1]);
                const chosenTerminal = busTerminalStatus[busNum];
                let etaSec;
                if (chosenTerminal === 'at_destination') { etaSec = -1; }
                else if (distM <= AT_STOP_THRESHOLD) { etaSec = 0; }
                else { etaSec = Math.ceil(((distM / 1000) / 12) * 3600); }
                busesOnRoute.push({ busNum, etaSec, distM, status: busStatusCache[busNum] || determineStatus(busNum, [b.lat, b.lng], b.lastUpdate) });
            });
            busesOnRoute.sort((a, b) => a.etaSec - b.etaSec);
            if (busesOnRoute.length === 0) { container.innerHTML = '<div style="color:var(--text-sub);font-size:12px;padding:6px 0">No active transports on this route</div>'; return; }
            const nearestStopName = (route.stops && route.stops[nearestStopIdx]) || ('Stop ' + (nearestStopIdx + 1));
            const nextStopName = (route.stops && route.stops[nearestStopIdx + 1]) || (nearestStopIdx + 1 < route.waypoints.length ? ('Stop ' + (nearestStopIdx + 2)) : null);
            const frag = document.createDocumentFragment();
            const header = document.createElement('div');
            header.style.cssText = 'font-size:11px;color:var(--text-sub);margin-bottom:2px;padding:2px 0';
            header.textContent = 'Arriving at ' + nearestStopName;
            frag.appendChild(header);
            if (nextStopName) {
                const nextHeader = document.createElement('div');
                nextHeader.style.cssText = 'font-size:11px;color:var(--text-sub);margin-bottom:8px;padding:2px 0';
                nextHeader.textContent = 'Next stop: ' + nextStopName;
                frag.appendChild(nextHeader);
            }
            busesOnRoute.forEach(bus => {
                const colorIdx = (parseInt(bus.busNum) || 0);
                const color = colors[(colorIdx > 0 ? colorIdx - 1 : 0) % colors.length];
                const etaDisplay = bus.etaSec === -1 ? 'Reached' : bus.etaSec === 0 ? 'At Stop' : formatMinSec(bus.etaSec);
                const statusColor = bus.status==='Moving'?'#34d399':bus.status==='At Stop'?'#5AC8FA':bus.status==='Idle'?'#fbbf24':bus.status==='Reached Destination'?'#a78bfa':bus.status==='At Start'?'#60a5fa':bus.status==='Waiting for Update'?'#fbbf24':'#fb7185';
                const isTracked = trackedBus && trackedBus === bus.busNum;
                const item = document.createElement('div');
                item.style.cssText = 'display:flex;align-items:center;justify-content:space-between;padding:6px 10px;margin-bottom:4px;font-size:12px;cursor:pointer;border-radius:8px;border:1px solid var(--chip-border);background:var(--chip-gradient);box-shadow:var(--chip-shadow);transition:all 0.25s ease';
                if (isTracked) {
                    item.style.boxShadow = '0 0 0 2px ' + color + '55';
                    item.style.background = 'rgba(255,255,255,0.08)';
                    item.style.borderColor = color;
                }
                item.addEventListener('click', () => { setTrackedBus(bus.busNum); const bd = latestBuses[bus.busNum]; if (bd) map.setView([bd.lat, bd.lng], 17); });
                const left = document.createElement('div');
                left.style.cssText = 'display:flex;align-items:center;gap:8px';
                const dot = document.createElement('div');
                dot.style.cssText = 'width:20px;height:20px;border-radius:50%;background:' + color + ';display:flex;align-items:center;justify-content:center;color:#fff;font-size:11px;font-weight:600';
                dot.textContent = bus.busNum;
                const name = document.createElement('span');
                name.style.cssText = 'color:var(--text)';
                name.textContent = isTracked ? '\u2713 Transport ' + bus.busNum : 'Transport ' + bus.busNum;
                left.appendChild(dot); left.appendChild(name);
                const right = document.createElement('div');
                right.style.cssText = 'text-align:right';
                const etaEl = document.createElement('div');
                etaEl.style.cssText = 'color:#34d399;font-weight:600;font-size:12px';
                etaEl.textContent = etaDisplay;
                const statusEl = document.createElement('div');
                statusEl.style.cssText = 'color:' + statusColor + ';font-size:10px';
                statusEl.textContent = bus.status;
                right.appendChild(etaEl); right.appendChild(statusEl);
                item.appendChild(left); item.appendChild(right);
                frag.appendChild(item);
            });
            container.textContent = '';
            container.appendChild(frag);
        }

        function selectRoute(routeId) {
            const newId = String(routeId);
            selectedRouteId = (selectedRouteId === newId) ? null : newId;
            Object.entries(routePolylines).forEach(([id, polyline]) => { if (!id.includes('-stop-')) { try { const opacity = selectedRouteId === String(id) ? 1 : 0.3; polyline.setStyle({ opacity }); } catch(e) {} } });
            renderRoutesList(allRoutes);
            renderRouteBusByETA();
            if (selectedRouteId) {
                const routeObj = getRouteById(routeId);
                if (routeObj) { showRouteDetails(routeObj); if(_dom.currentRouteOverlay) _dom.currentRouteOverlay.textContent = routeObj.name; computeAndShowStudentETA(); }
            } else {
                if (_dom.routeDetailsCard) _dom.routeDetailsCard.style.display = 'none';
                if (_dom.etaOverlay) _dom.etaOverlay.textContent = '--';
                if (_dom.etaValue) _dom.etaValue.textContent = '--';
                if (_dom.currentRouteOverlay) _dom.currentRouteOverlay.textContent = '‚Äî';
                if (walkingLine) { try { map.removeLayer(walkingLine); } catch(e){} walkingLine = null; }
            }
            // Blur non-selected route stops
            try {
                Object.entries(routePolylines).forEach(([id, marker]) => {
                    if (!id.includes('-stop-')) return;
                    const routeKey = id.split('-stop-')[0];
                    const isSelectedRoute = selectedRouteId && String(routeKey) === String(selectedRouteId);
                    if (marker && marker.getElement && marker.getElement()) {
                        const el = marker.getElement();
                        if (isSelectedRoute || !selectedRouteId) {
                            el.classList.remove('stop-blur');
                        } else {
                            el.classList.add('stop-blur');
                        }
                    }
                });
            } catch(e) { /* ignore */ }
        }

        async function showRouteDetails(route) {
            if(_dom.routeDetailsCard) _dom.routeDetailsCard.style.display = 'block'; const card = _dom.routeDetailsCard;
            const busesData = latestBuses || {};
            const busesOnRoute = Object.entries(busesData)
                .filter(([busNum, b]) => {
                    const rid = (b && b.routeId != null) ? b.routeId : busRouteMap[busNum];
                    return String(rid) === String(route.id);
                })
                .map(([busNum]) => busNum);
            if (_dom.busesOnRouteCount) _dom.busesOnRouteCount.textContent = busesOnRoute.length;
            let nearestStop = null; let minDist = Infinity; let nearestStopIdx = 0; const refLocation = (userLocation && userLocation.length === 2) ? userLocation : (map ? [map.getCenter().lat, map.getCenter().lng] : null);
            if (refLocation && route.waypoints.length > 0) {
                route.waypoints.forEach((stop, idx) => { const dist = calcDistance(refLocation[0], refLocation[1], stop[0], stop[1]); if (dist < minDist) { minDist = dist; nearestStop = stop; nearestStopIdx = idx; } });
                if (nearestStop) {
                    if (userLocation) {
                        const distKm = (minDist / 1000).toFixed(2);
                        const walkMin = Math.ceil(minDist / 1.4);
                        if(_dom.walkDistance) _dom.walkDistance.textContent = `${distKm} km (${walkMin}m)`;
                        if (walkingLine) map.removeLayer(walkingLine);
                        walkingLine = L.polyline([userLocation, nearestStop], { color: '#999999', weight: 2, opacity: 0.6, dashArray: '5, 5' }).addTo(map);
                    } else {
                        if(_dom.walkDistance) _dom.walkDistance.textContent = '--';
                    }
                    // Set nearest stop name and next stop name
                    const nearestStopName = (route.stops && route.stops[nearestStopIdx]) || (`Stop ${nearestStopIdx + 1}`);
                    const nextStopName = (route.stops && route.stops[nearestStopIdx + 1]) || (nearestStopIdx + 1 < route.waypoints.length ? `Stop ${nearestStopIdx + 2}` : null);
                    if(document.getElementById('walkDistance')) document.getElementById('walkDistance').textContent = nearestStopName;
                    if(document.getElementById('nextStop')) document.getElementById('nextStop').textContent = nextStopName ? `Next stop: ${nextStopName}` : '';
                }
            } else {
                if(_dom.walkDistance) _dom.walkDistance.textContent = '--';
                if(document.getElementById('nextStop')) document.getElementById('nextStop').textContent = '';
            }
            // ETA computed separately to simplify: distance / speed
            if(_dom.etaValue) _dom.etaValue.innerHTML = '<span class="eta-spinner"></span>Updating'; if(_dom.etaOverlay) _dom.etaOverlay.innerHTML = '<span class="eta-spinner"></span>';
            studentEtaLastHtml = null; studentEtaLastTs = 0;
            computeAndShowStudentETA();
        }
        function formatMinSec(totalSeconds){
            const m = Math.floor(totalSeconds/60);
            const s = totalSeconds % 60;
            return `${m}:${String(s).padStart(2,'0')}`;
        }

        // ETA smoothing to avoid flicker
        let studentEtaSmooth = null; let studentEtaLastTs = 0; const STUD_ETA_ALPHA = 0.35; const STUD_ETA_UPDATE_MS = 2500; const STUD_ETA_MIN_STEP = 3; let studentEtaLastHtml = null;
        function smoothStudentEta(secs){ if(!isFinite(secs)) return secs; if(studentEtaSmooth==null){ studentEtaSmooth = secs; return secs; } const sm = STUD_ETA_ALPHA*secs + (1-STUD_ETA_ALPHA)*studentEtaSmooth; if(Math.abs(sm-studentEtaSmooth) < STUD_ETA_MIN_STEP){ studentEtaSmooth = studentEtaSmooth + Math.sign(sm-studentEtaSmooth) * STUD_ETA_MIN_STEP; } else { studentEtaSmooth = sm; } return Math.max(0, Math.round(studentEtaSmooth)); }
        function formatHHMM(totalSeconds){ const mins = Math.max(0, Math.round(totalSeconds/60)); const h = Math.floor(mins/60); const m = mins % 60; return h>0 ? `${h}:${String(m).padStart(2,'0')}` : `${m}m`; }
        function maybeUpdateStudentEta(html){ const now = Date.now(); const isFirst = studentEtaLastHtml === null; if((isFirst || now - studentEtaLastTs >= STUD_ETA_UPDATE_MS) && html !== studentEtaLastHtml){ if(_dom.etaValue) _dom.etaValue.innerHTML = html; if(_dom.etaOverlay) _dom.etaOverlay.innerHTML = html; studentEtaLastHtml = html; studentEtaLastTs = now; } }

        async function computeAndShowStudentETA(busesDataParam){
            const busesData = busesDataParam || latestBuses || {};
            const nowMs = Date.now();
            const freshEntries = Object.entries(busesData).filter(([num,b])=>{ const t = b && b.lastUpdate ? parseIsoTime(b.lastUpdate) : null; const lastSeen = busLastSeen[num] || 0; const effectiveTime = Math.max(lastSeen, t || 0); return effectiveTime && (nowMs - effectiveTime) <= OFFLINE_MS; });
            const freshData = Object.fromEntries(freshEntries);

            // Determine active route context: tracked bus route first, else selected route
            let activeRoute = null; let nearestStop = null;
            let refLocation = (userLocation && userLocation.length === 2) ? userLocation : (map ? [map.getCenter().lat, map.getCenter().lng] : null);

            let chosenBusNum = trackedBus;
            let chosenBus = chosenBusNum ? freshData[chosenBusNum] : null;
            let routeId = chosenBus && chosenBus.routeId!=null ? chosenBus.routeId : (chosenBusNum ? busRouteMap[chosenBusNum] : null);

            if(routeId){ activeRoute = getRouteById(routeId); }
            if(!activeRoute && selectedRouteId){ activeRoute = getRouteById(selectedRouteId); }
            if(!activeRoute || !activeRoute.waypoints || activeRoute.waypoints.length===0){ maybeUpdateStudentEta('--'); return; }

            // Find nearest student stop
            if(refLocation){ let minD=Infinity; activeRoute.waypoints.forEach(stop=>{ const d = calcDistance(refLocation[0],refLocation[1], stop[0], stop[1]); if(d<minD){ minD=d; nearestStop=stop; } }); }
            if(!nearestStop){ nearestStop = activeRoute.waypoints[0]; }

            // Choose bus: if not tracked, pick bus on route nearest to that stop
            if(!chosenBusNum){
                const busesOnRoute = Object.entries(freshData).filter(([num,b])=>{ const rid = (b && b.routeId!=null) ? b.routeId : busRouteMap[num]; return String(rid) === String(activeRoute.id); });
                if(busesOnRoute.length===0){ maybeUpdateStudentEta('<span class="eta-spinner"></span>Updating'); return; }
                let bestNum=null, bestB=null, bestDist=Infinity;
                for(const [num,b] of busesOnRoute){ if(!b || typeof b.lat!=='number' || typeof b.lng!=='number') continue; const d = calcDistance(b.lat,b.lng, nearestStop[0], nearestStop[1]); if(d<bestDist){ bestDist=d; bestNum=num; bestB=b; } }
                chosenBusNum = bestNum; chosenBus = bestB;
                if(!chosenBus){ maybeUpdateStudentEta('<span class="eta-spinner"></span>Updating'); return; }
            }

            // Check terminal status
            const chosenTerminal = busTerminalStatus[chosenBusNum];
            if (chosenTerminal === 'at_destination') { maybeUpdateStudentEta('Reached'); return; }
            if (chosenTerminal === 'at_start') { maybeUpdateStudentEta('At Start'); return; }
            if (chosenTerminal === 'waiting') { maybeUpdateStudentEta('Waiting'); return; }

            // Route distance instead of straight-line, always 12 km/h
            const routeIdForDist = chosenBus.routeId || busRouteMap[chosenBusNum];
            const distMeters = getRouteDistanceBetween(routeIdForDist, [chosenBus.lat, chosenBus.lng], nearestStop) || calcDistance(chosenBus.lat, chosenBus.lng, nearestStop[0], nearestStop[1]);

            if (distMeters <= AT_STOP_THRESHOLD) { maybeUpdateStudentEta('At Stop'); return; }

            const seconds = Math.ceil(((distMeters/1000) / 12) * 3600);
            const smoothed = smoothStudentEta(seconds);
            const etaStr = formatMinSec(Math.round(smoothed));
            maybeUpdateStudentEta(etaStr);
        }

        function estimateRouteDistance(waypoints) { let total = 0; for (let i = 0; i < waypoints.length - 1; i++) { total += calcDistance(waypoints[i][0], waypoints[i][1], waypoints[i+1][0], waypoints[i+1][1]); } return total / 1000; }

        function setTrackedBus(busNum) {
            trackedBus = busNum || null;
            Object.keys(busMarkers).forEach(num => { const marker = busMarkers[num]; const isTracked = trackedBus && num === trackedBus; const rawPos = prevRawPositions[num]; const busData = latestBuses[num]; const status = (rawPos && busData) ? determineStatus(num, rawPos, busData.lastUpdate) : 'Offline'; const isOffline = status === 'Offline'; try { marker.setOpacity(isOffline ? 0.3 : (isTracked ? 1 : 0.7)); } catch(e) {} const color = colors[(parseInt(num) - 1) % colors.length]; const rid = busRouteMap[num]; const onSelectedRoute = selectedRouteId && String(rid) === String(selectedRouteId); const newIcon = createIcon(num, color, currentIconSize, prevBusRotation[num] || 0, isTracked || onSelectedRoute); marker.setIcon(newIcon); prevTrackedState[num] = !!isTracked; prevRouteSelState[num] = !!onSelectedRoute; });
            const rid = busRouteMap[busNum]; if (rid) { if (String(rid) !== String(selectedRouteId)) { selectRoute(rid); } const routeObj = getRouteById(rid); if(routeObj) showRouteDetails(routeObj); }
            computeAndShowStudentETA();
            renderRouteBusByETA();
        }

        async function loadMetrics(){
            try{
                const res = await fetch('/api/metrics');
                const data = await res.json();
                if(_dom.totalTransportCount && typeof data.total_transports === 'number') _dom.totalTransportCount.textContent = data.total_transports;
            }catch(e){ /* ignore */ }
        }

        let mapTileBase = null;
        let mapTileLabels = null;
        let mapIsDark = true;
        const DARK_TILES = 'https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png';
        const DARK_LABELS = 'https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}{r}.png';
        const LIGHT_TILES = 'https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png';
        const LIGHT_LABELS = 'https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png';
        const TILE_OPTS = { attribution: '&copy; CARTO', maxZoom: 19, updateWhenIdle: true, updateWhenZooming: false, keepBuffer: 4, detectRetina: false };

        function setMapTiles(dark) {
            mapIsDark = dark;
            if (mapTileBase) { map.removeLayer(mapTileBase); }
            if (mapTileLabels) { map.removeLayer(mapTileLabels); }
            mapTileBase = L.tileLayer(dark ? DARK_TILES : LIGHT_TILES, TILE_OPTS).addTo(map);
            mapTileLabels = L.tileLayer(dark ? DARK_LABELS : LIGHT_LABELS, { ...TILE_OPTS, attribution: '' }).addTo(map);
            // Keep tiles behind markers
            mapTileBase.setZIndex(0);
            mapTileLabels.setZIndex(1);
            const btn = document.getElementById('mapThemeBtn');
            if (btn) btn.textContent = dark ? 'üó∫Ô∏è‚òÄÔ∏è' : 'üó∫Ô∏èüåô';
        }

        function toggleMapTheme() {
            setMapTiles(!mapIsDark);
        }

        function toggleGlobalTheme() {
            const body = document.body;
            const goingLight = !body.classList.contains('light-mode');
            body.classList.toggle('light-mode');
            const btn = document.getElementById('globalThemeBtn');
            if (btn) btn.textContent = goingLight ? '‚òÄÔ∏è' : 'üåô';
            // Global toggle also sets map to match
            setMapTiles(!goingLight);
        }

        function initMap() {
            cacheDom();
            const bounds = [[20.339920625677212, 85.7964659296332], [20.37210882553945, 85.83388810783698]];
            map = L.map('map', { zoomControl: true, maxBounds: bounds, minZoom: 14, preferCanvas: true }).setView([20.3549, 85.8161], 15);
            setMapTiles(true);

            // Responsive icon sizing on zoom
            currentIconSize = getIconSizeForZoom(map.getZoom());
            map.on('zoomend', () => {
                const newSize = getIconSizeForZoom(map.getZoom());
                if (newSize !== currentIconSize) {
                    currentIconSize = newSize;
                    // Rebuild all bus icons at new size
                    Object.keys(busMarkers).forEach(busNum => {
                        const color = colors[(parseInt(busNum) - 1) % colors.length];
                        const rid = busRouteMap[busNum];
                        const onSelectedRoute = selectedRouteId && String(rid) === String(selectedRouteId);
                        const isTracked = trackedBus && busNum === trackedBus;
                        const icon = createIcon(busNum, color, currentIconSize, prevBusRotation[busNum] || 0, isTracked || onSelectedRoute);
                        busMarkers[busNum].setIcon(icon);
                    });
                }
            });
            if(userLocation){ updateUserMarker(userLocation); }
            updateBuses();
            busesPollTimerId = setInterval(updateBuses, POLL_INTERVAL_MS);
            initSSE();
            // Start prediction animation loop
            startPredictionLoop();
            setInterval(() => { if (!_predAnimRunning) startPredictionLoop(); }, 5000);
            // Defer non-critical loads slightly to speed up initial render
            setTimeout(() => { loadHostels(); loadClasses(); loadBusRoutes(); loadMetrics(); }, 100);
            loadRoutes();
            document.getElementById('hostelsToggle').addEventListener('change', (e) => { updateLayerVisibility('hostels', e.target.checked); });
            document.getElementById('classesToggle').addEventListener('change', (e) => { updateLayerVisibility('classes', e.target.checked); });
            document.getElementById('routesToggle').addEventListener('change', (e) => { updateLayerVisibility('routes', e.target.checked); });
            // Pause polling when tab hidden; resume and force resync on show
            window.addEventListener('beforeunload', () => { if (_eventSource) { try { _eventSource.close(); } catch(e) {} } });
            document.addEventListener('visibilitychange', ()=>{
                if(document.hidden){
                    if(busesPollTimerId){ try{ clearInterval(busesPollTimerId); }catch(e){} busesPollTimerId=null; }
                } else {
                    // Immediate resync on tab refocus
                    updateBuses();
                    // If SSE died while hidden, restart it
                    if(_eventSource && _eventSource.readyState === 2){ initSSE(); }
                    // Always ensure polling is running as fallback
                    if(!busesPollTimerId){ busesPollTimerId = setInterval(updateBuses, POLL_INTERVAL_MS); }
                }
            });
        }

        function updateBuses() {
            fetch('/api/buses').then(response => response.json()).then(buses => {
                latestBuses = buses || {};
                const nowMs = Date.now();
                const busNumbers = Object.keys(buses);
                // Keep buses that have data ‚Äî don't filter by time here, let status handle it
                const visibleBusNumbers = busNumbers.filter(n => {
                    const b = buses[n];
                    if (!b || typeof b.lat !== 'number' || typeof b.lng !== 'number') return false;
                    const iso = b.lastUpdate; const t = iso ? parseIsoTime(iso) : null;
                    const lastSeen = busLastSeen[n] || 0;
                    const effectiveTime = Math.max(lastSeen, t || 0);
                    // Only fully remove after REMOVE_MS
                    return effectiveTime && (nowMs - effectiveTime) <= REMOVE_MS;
                });
                // Mark local receive time for all buses in this response
                visibleBusNumbers.forEach(n => { busLastSeen[n] = nowMs; });
                const freshBusNumbers = visibleBusNumbers;
                const freshBusSet = new Set(freshBusNumbers);
                let activeCount = 0;
                // Remove markers for buses missing or fully stale (beyond REMOVE_MS)
                const existingBuses = Object.keys(busMarkers);
                existingBuses.forEach(busNum => { if (!freshBusSet.has(busNum)) { map.removeLayer(busMarkers[busNum]); delete busMarkers[busNum]; delete prevRawPositions[busNum]; delete prevBusPositions[busNum]; delete prevBusTimes[busNum]; delete busLastSeen[busNum]; delete busLastSSEUpdate[busNum]; delete busDirection[busNum]; delete busLastStopIdx[busNum]; delete busCurrentStop[busNum]; delete busSpeedCache[busNum]; delete busMovedCache[busNum]; delete busTerminalStatus[busNum]; } });
                freshBusNumbers.forEach(busNum => {
                    const bus = buses[busNum]; const rawPos = [bus.lat, bus.lng]; const color = colors[(parseInt(busNum) - 1) % colors.length];
                    // If SSE already updated this bus recently, skip poll processing to avoid teleporting
                    const lastSSE = busLastSSEUpdate[busNum] || 0;
                    if (sseConnected && (nowMs - lastSSE) < 10000 && busMarkers[busNum]) {
                        busLastSeen[busNum] = nowMs;
                        updateBusStopInfo(busNum, rawPos);
                        const status = determineStatus(busNum, rawPos, bus.lastUpdate);
                        if (status !== 'Offline') activeCount++;
                        const isTrackedNow = trackedBus && busNum === trackedBus;
                        try { busMarkers[busNum].setOpacity(status === 'Offline' ? 0.3 : (isTrackedNow ? 1 : 0.7)); } catch(e) {}
                        return;
                    }
                    // Snap to route if close enough
                    const snapResult = snapToRoute(rawPos[0], rawPos[1], busNum);
                    const position = snapResult.pos;
                    busSnapInfo[busNum] = { segIdx: snapResult.segIdx };
                    const isTracked = trackedBus && busNum === trackedBus;
                    updateBusStopInfo(busNum, rawPos);
                    // Cache speed/movement BEFORE overwriting prev positions
                    cacheSpeedAndMovement(busNum, rawPos[0], rawPos[1], bus.lastUpdate);
                    const status = determineStatus(busNum, rawPos, bus.lastUpdate);
                    const isOffline = status === 'Offline';
                    if (!isOffline) activeCount++;
                    const rotation = getRouteBearing(busNum);
                    prevRawPositions[busNum] = rawPos;
                    prevBusPositions[busNum] = position; if (bus.lastUpdate) prevBusTimes[busNum] = parseIsoTime(bus.lastUpdate);
                    if (busMarkers[busNum]) {
                        queueBusTween(busNum, rawPos);
                        const rid = (bus && bus.routeId != null) ? bus.routeId : busRouteMap[busNum];
                        const onSelectedRoute = selectedRouteId && String(rid) === String(selectedRouteId);
                        const rotationChanged = (prevBusRotation[busNum] === undefined) || (Math.abs(rotation - prevBusRotation[busNum]) > 5);
                        const trackingChanged = prevTrackedState[busNum] !== !!isTracked;
                        const routeSelChanged = prevRouteSelState[busNum] !== !!onSelectedRoute;
                        if (rotationChanged || trackingChanged || routeSelChanged) {
                            const newIcon = createIcon(busNum, color, currentIconSize, rotation, isTracked || onSelectedRoute);
                            busMarkers[busNum].setIcon(newIcon);
                            prevBusRotation[busNum] = rotation;
                            prevTrackedState[busNum] = !!isTracked;
                            prevRouteSelState[busNum] = !!onSelectedRoute;
                        }
                    } else {
                        const rid = (bus && bus.routeId != null) ? bus.routeId : busRouteMap[busNum];
                        const onSelectedRoute = selectedRouteId && String(rid) === String(selectedRouteId);
                        const icon = createIcon(busNum, color, currentIconSize, rotation, isTracked || onSelectedRoute);
                        busMarkers[busNum] = L.marker(position, { icon: icon, title: `Transport ${busNum}` }).addTo(map);
                        prevBusRotation[busNum] = rotation;
                        prevTrackedState[busNum] = !!isTracked;
                        prevRouteSelState[busNum] = !!onSelectedRoute;
                        busMarkers[busNum].bindPopup(() => buildBusPopup(busNum, bus));
                        busMarkers[busNum].on('click', () => { setTrackedBus(busNum); if (followEnabled) map.setView(position, 17); busMarkers[busNum].openPopup(); });
                        busMarkers[busNum].on('mouseover', () => { followEnabled = false; }); busMarkers[busNum].on('mouseout', () => { followEnabled = true; });
                    }
                    const marker = busMarkers[busNum]; const isTrackedNow = trackedBus && busNum === trackedBus;
                    // Dim offline buses instead of removing
                    try { marker.setOpacity(isOffline ? 0.3 : (isTrackedNow ? 1 : 0.7)); } catch(e) {}
                    if (isTrackedNow && followEnabled && !isOffline) { map.panTo(position); }
                });
                if (_dom.activeBusCount) _dom.activeBusCount.textContent = activeCount;
                if (_dom.activeCountOverlay) _dom.activeCountOverlay.textContent = activeCount;
                updateActiveBusList(freshBusNumbers, buses);
                computeAndShowStudentETA(latestBuses);
                renderRouteBusByETA();
                const now = getTimeString(); if (_dom.lastUpdate) _dom.lastUpdate.textContent = now; if (_dom.lastUpdateOverlay) _dom.lastUpdateOverlay.textContent = now;
            }).catch(error => console.error('Error:', error));
        }

        let _lastBusListHash = '';
        function updateActiveBusList(busNumbers, buses) {
            const container = _dom.activeBuses || document.getElementById('activeBuses');
            if (busNumbers.length === 0) { if (_lastBusListHash !== 'empty') { container.innerHTML = `<div class="empty-state"><p>No Transports currently active</p></div>`; _lastBusListHash = 'empty'; } return; }
            // Build hash to skip DOM rebuild if nothing changed
            let hash = '';
            for (let i = 0; i < busNumbers.length; i++) { hash += busNumbers[i] + (busStatusCache[busNumbers[i]] || '') + (busCurrentStop[busNumbers[i]] || ''); }
            if (hash === _lastBusListHash) return;
            _lastBusListHash = hash;
            const frag = document.createDocumentFragment();
            const sorted = busNumbers.slice().sort((a, b) => parseInt(a) - parseInt(b));
            for (let ni = 0; ni < sorted.length; ni++) {
                const busNum = sorted[ni];
                const color = colors[(parseInt(busNum) - 1) % colors.length];
                const rid = (buses[busNum] && buses[busNum].routeId != null) ? buses[busNum].routeId : busRouteMap[busNum];
                const onSelectedRoute = selectedRouteId && String(rid) === String(selectedRouteId);
                const item = document.createElement('div');
                item.className = `bus-item ${onSelectedRoute ? 'active-route' : ''}`;
                item.style.borderLeftColor = color;
                item.onclick = () => { const position = [buses[busNum].lat, buses[busNum].lng]; map.setView(position, 17); };
                const rawPos = [buses[busNum].lat, buses[busNum].lng];
                const status = busStatusCache[busNum] || determineStatus(busNum, rawPos, buses[busNum].lastUpdate);
                const statusColor = status==='Moving'?'#34d399':status==='At Stop'?'#5AC8FA':status==='Idle'?'#fbbf24':status==='Reached Destination'?'#a78bfa':status==='At Start'?'#60a5fa':status==='Waiting for Update'?'#fbbf24':'#fb7185';
                const atStopName = busCurrentStop[busNum];
                const route = getRouteById(rid);
                const stops = route ? getStopsForBus(route, rawPos, busNum) : { last: null, next: null };
                const statusText = (status === 'Reached Destination' && atStopName) ? `Reached: ${atStopName}` : (status === 'At Start' && atStopName) ? `At Start: ${atStopName}` : (status === 'At Stop' && atStopName) ? `At Stop: ${atStopName}` : status;
                let statusHtml = `<div class="bus-status" style="color:${statusColor}"><div class="pulse" style="background:${statusColor}"></div>${statusText}</div>`;
                let detailRows = '';
                if (stops.last) {
                    detailRows += `<div style="font-size:11px;color:#9aa4b2;padding:1px 0 0 36px">Last: ${stops.last}</div>`;
                }
                if (stops.next) {
                    detailRows += `<div style="font-size:11px;color:#5AC8FA;padding:1px 0 0 36px;font-weight:500">Next: ${stops.next}</div>`;
                }
                item.innerHTML = `<div class="bus-info"><div class="bus-dot" style="background-color: ${color}; transform:${onSelectedRoute ? 'scale(1.08)' : 'scale(1)'}">${busNum}</div><div class="bus-name">Transport ${busNum}</div></div>${statusHtml}${detailRows}`;
                frag.appendChild(item);
            }
            container.textContent = '';
            container.appendChild(frag);
        }

        // Live updates via SSE for smooth animation
        let _sseLastMsg = 0; // timestamp of last SSE message for health check
        function initSSE(routeId){
            if (_eventSource) { try { _eventSource.close(); } catch(e) {} _eventSource = null; sseConnected = false; }
            const sseUrl = routeId ? '/events?routeId=' + encodeURIComponent(routeId) : '/events';
            try{
                const es = new EventSource(sseUrl);
                _eventSource = es;
                _sseLastMsg = Date.now();
                es.onopen = ()=>{
                    sseConnected = true;
                    _sseLastMsg = Date.now();
                    if(busesPollTimerId){ try{ clearInterval(busesPollTimerId); }catch(e){} busesPollTimerId=null; }
                    // Light resync every RESYNC_INTERVAL_MS to prune stale buses + SSE health check
                    if(window.__resyncTimer){ clearInterval(window.__resyncTimer); }
                    window.__resyncTimer = setInterval(()=>{
                        if(!document.hidden) updateBuses();
                        // SSE health: if no message in 45s (heartbeat should be 20s), reconnect
                        if(sseConnected && (Date.now() - _sseLastMsg) > 45000){
                            sseConnected = false;
                            try { _eventSource.close(); } catch(e){}
                            _eventSource = null;
                            initSSE(selectedRouteId);
                        }
                    }, RESYNC_INTERVAL_MS);
                };
                es.onmessage = (ev)=>{
                    _sseLastMsg = Date.now();
                    try{
                        const msg = JSON.parse(ev.data);
                        if(msg.type === 'bus_update'){
                            const busNum = String(msg.bus);
                            const b = msg.data||{};
                            if(typeof b.lat !== 'number' || typeof b.lng !== 'number') return;
                            // update route mapping if provided
                            if(b.routeId != null) busRouteMap[busNum] = b.routeId;
                            // Use server-sent heading if provided
                            if(b.heading !== undefined && b.heading !== null) busServerHeading[busNum] = b.heading;
                            // Track last seen time, direction, and raw position for status
                            busLastSeen[busNum] = Date.now();
                            busLastSSEUpdate[busNum] = Date.now();
                            // Use server-sent stop data (atStop, direction, nearestStopIdx)
                            const srvStop = { atStop: b.atStop, direction: b.direction, nearestStopIdx: b.nearestStopIdx, nearestStopName: b.nearestStopName };
                            updateBusStopInfo(busNum, [b.lat, b.lng], srvStop);
                            // Cache speed/movement BEFORE overwriting prev positions
                            cacheSpeedAndMovement(busNum, b.lat, b.lng, b.lastUpdate);
                            prevRawPositions[busNum] = [b.lat, b.lng];
                            if(b.lastUpdate) prevBusTimes[busNum] = parseIsoTime(b.lastUpdate);
                            // update cache and animate
                            latestBuses[busNum] = { ...(latestBuses[busNum]||{}), ...b };
                            if(!busMarkers[busNum]){
                                const color = colors[(parseInt(busNum) - 1) % colors.length];
                                const icon = createIcon(busNum, color, currentIconSize, 0, false);
                                busMarkers[busNum] = L.marker([b.lat,b.lng], { icon, title: `Transport ${busNum}` }).addTo(map);
                                busMarkers[busNum].bindPopup(() => buildBusPopup(busNum, latestBuses[busNum] || b));
                                busMarkers[busNum].on('click', () => { setTrackedBus(busNum); if (followEnabled) map.setView([b.lat,b.lng], 17); busMarkers[busNum].openPopup(); });
                                busMarkers[busNum].on('mouseover', () => { followEnabled = false; }); busMarkers[busNum].on('mouseout', () => { followEnabled = true; });
                            } else {
                                // Snap to route and get route-locked bearing
                                const _snap = snapToRoute(b.lat, b.lng, busNum);
                                busSnapInfo[busNum] = { segIdx: _snap.segIdx };
                                const _newRot = getRouteBearing(busNum);
                                if (prevBusRotation[busNum] === undefined || Math.abs(_newRot - (prevBusRotation[busNum]||0)) > 5) {
                                    const _c = colors[(parseInt(busNum) - 1) % colors.length];
                                    const _rid = busRouteMap[busNum]; const _onR = selectedRouteId && String(_rid) === String(selectedRouteId);
                                    const _tr = trackedBus && busNum === trackedBus;
                                    busMarkers[busNum].setIcon(createIcon(busNum, _c, currentIconSize, _newRot, _tr || _onR));
                                    prevBusRotation[busNum] = _newRot;
                                }
                                queueBusTween(busNum, [b.lat, b.lng]);
                            }
                            const now = getTimeString();
                            if (_dom.lastUpdate) _dom.lastUpdate.textContent = now;
                            if (_dom.lastUpdateOverlay) _dom.lastUpdateOverlay.textContent = now;
                            // Throttle ETA recomputation from SSE ‚Äî at most once per second
                            if (!window._etaThrottle) { window._etaThrottle = setTimeout(() => { window._etaThrottle = null; computeAndShowStudentETA(latestBuses); renderRouteBusByETA(); }, 1000); }
                        } else if(msg.type === 'bus_stop'){
                            const busNum = String(msg.bus);
                            delete latestBuses[busNum];
                            delete busLastSeen[busNum];
                            delete busLastSSEUpdate[busNum];
                            delete prevRawPositions[busNum];
                            delete prevBusPositions[busNum];
                            delete prevBusTimes[busNum];
                            delete busDirection[busNum];
                            delete busLastStopIdx[busNum];
                            delete busCurrentStop[busNum];
                            delete busSpeedCache[busNum];
                            delete busMovedCache[busNum];
                            delete busTerminalStatus[busNum];
                            const m = busMarkers[busNum]; if(m){ try{ map.removeLayer(m); }catch(e){} delete busMarkers[busNum]; }
                        } else if(msg.type === 'route_set'){
                            const busNum = String(msg.bus);
                            if(msg.routeId != null) busRouteMap[busNum] = msg.routeId;
                            if(latestBuses[busNum]) latestBuses[busNum].routeId = msg.routeId;
                        } else if(msg.type === 'buses_clear'){
                            latestBuses = {};
                            Object.values(busMarkers).forEach(m=>{ try{ map.removeLayer(m); }catch(e){} }); busMarkers = {};
                            prevRawPositions = {}; prevBusPositions = {}; prevBusTimes = {}; busLastSeen = {}; busLastSSEUpdate = {};
                            busDirection = {}; busLastStopIdx = {}; busCurrentStop = {}; busTerminalStatus = {};
                        }
                    }catch(e){ /* ignore */ }
                };
                es.onerror = ()=>{
                    // If SSE fails, ensure polling is running
                    sseConnected = false;
                    if(!busesPollTimerId){ busesPollTimerId = setInterval(updateBuses, POLL_INTERVAL_MS); }
                };
            }catch(e){ /* SSE not available, keep polling */ }
        }

        async function locateMe() {
            if (!navigator.geolocation) return alert('Geolocation not supported');
            navigator.geolocation.getCurrentPosition((pos) => {
                userLocation = [pos.coords.latitude, pos.coords.longitude]; map.setView(userLocation, 16);
                updateUserMarker(userLocation);
                let best = { route: null, stop: null, dist: Infinity };
                allRoutes.forEach(route => { route.waypoints.forEach((wp) => { const d = calcDistance(userLocation[0], userLocation[1], wp[0], wp[1]); if (d < best.dist) best = { route, stop: wp, dist: d }; }); });
                if (best.route) { selectRoute(best.route.id); if (walkingLine) map.removeLayer(walkingLine); walkingLine = L.polyline([userLocation, best.stop], { color:'#999', weight:2, opacity:0.7, dashArray:'5,5' }).addTo(map); showRouteDetails(best.route); computeAndShowStudentETA(); }
                if(!userWatchId){
                    userWatchId = navigator.geolocation.watchPosition((p)=>{
                        userLocation = [p.coords.latitude, p.coords.longitude];
                        updateUserMarker(userLocation);
                    }, ()=>{}, { enableHighAccuracy:true, maximumAge:8000, timeout:12000 });
                }
            }, () => alert('Unable to get location'));
        }

        document.addEventListener('DOMContentLoaded', () => { const btn = document.getElementById('locateMeBtn'); if (btn) btn.addEventListener('click', locateMe); });
        window.addEventListener('load', initMap);
    </script>
</body>
</html>