<!DOCTYPE html>
<html>
<head>
    <title>Transport Tracker - Student View</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg+xml" href="{{ url_for('static', filename='favicons/favicon-student.svg') }}">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="preconnect" href="https://a.basemaps.cartocdn.com" crossorigin/>
    <link rel="preconnect" href="https://b.basemaps.cartocdn.com" crossorigin/>
    <link rel="preconnect" href="https://c.basemaps.cartocdn.com" crossorigin/>
    <link rel="preconnect" href="https://d.basemaps.cartocdn.com" crossorigin/>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script>
        (function() {
            try {
                if (localStorage.getItem('ui_perf_mode') === 'low') {
                    document.documentElement.classList.add('low-perf');
                }
            } catch (e) {}
        })();
    </script>
    <style>
        :root {
            --font-ui: "Helvetica Neue", Helvetica, "SF Pro Text", "Segoe UI", Arial, sans-serif;
            --font-classic: "Apple Garamond", Garamond, "Times New Roman", serif;
            --font-display: "Cormorant Garamond", "Apple Garamond", Garamond, serif;
            --font-script: "Blacksword", "Snell Roundhand", "Apple Chancery", "Segoe Script", cursive;
            --bg: #07070a;
            --bg-gradient1: rgba(99,102,241,0.12);
            --bg-gradient2: rgba(236,72,153,0.10);
            --text: #e6eef8;
            --text-sub: #9aa4b2;
            --text-heading: #dbeafe;
            --card-bg: rgba(22, 20, 42, 0.55);
            --card-border: rgba(130,100,255,0.10);
            --card-shadow: rgba(0,0,0,0.45);
            --stat-bg: rgba(255,255,255,0.06);
            --stat-border: rgba(255,255,255,0.18);
            --stat-gradient: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.03));
            --stat-inner: rgba(255,255,255,0.08);
            --input-bg: #0f0f23;
            --input-border: rgba(255,255,255,0.1);
            --chip-border: rgba(255,255,255,0.18);
            --chip-gradient: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.02));
            --chip-shadow: 0 4px 16px rgba(0,0,0,0.30), inset 0 0 0 1px rgba(255,255,255,0.06);
            --map-border: rgba(255,255,255,0.06);
            --map-bg: #05060a;
        }
        body.light-mode {
            --bg: #f0f2f5;
            --bg-gradient1: rgba(99,102,241,0.06);
            --bg-gradient2: rgba(236,72,153,0.05);
            --text: #1a1a2e;
            --text-sub: #555e6e;
            --text-heading: #1e293b;
            --card-bg: rgba(255, 255, 255, 0.85);
            --card-border: rgba(100,80,200,0.10);
            --card-shadow: rgba(0,0,0,0.10);
            --stat-bg: rgba(0,0,0,0.03);
            --stat-border: rgba(0,0,0,0.10);
            --stat-gradient: linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,255,255,0.5));
            --stat-inner: rgba(0,0,0,0.04);
            --input-bg: #fff;
            --input-border: rgba(0,0,0,0.12);
            --chip-border: rgba(0,0,0,0.12);
            --chip-gradient: linear-gradient(180deg, rgba(255,255,255,0.95), rgba(240,242,245,0.8));
            --chip-shadow: 0 2px 8px rgba(0,0,0,0.08), inset 0 0 0 1px rgba(0,0,0,0.04);
            --map-border: rgba(0,0,0,0.10);
            --map-bg: #e8e8e8;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: var(--font-ui); background: var(--bg); color: var(--text); min-height: 100vh; background-image:
            radial-gradient(circle at 20% 20%, var(--bg-gradient1), transparent 40%),
            radial-gradient(circle at 80% 30%, var(--bg-gradient2), transparent 40%);
            background-attachment: fixed; transition: background 0.3s, color 0.3s; }

        .header { background: transparent; padding: 18px 12px; text-align: left; display:flex; align-items:center; justify-content:space-between; gap:12px }
        .header h1 { font-size: 20px; color: var(--text); margin-bottom: 4px; }
        .header p { color: var(--text-sub); font-size: 13px; margin-top: 2px }
        .icon { display:inline-block; font-size:16px; line-height:1; vertical-align:middle; opacity:0.9; margin-right:6px }

        .main-container { display:flex; gap:18px; max-width:1200px; margin: 12px auto; padding: 0 12px; }
        .sidebar { flex:1; min-width:260px; max-width:360px; }
        .map-container { flex:1.5; min-height:0; position: relative; }

        #map { height: 500px; border-radius: 16px; border: 2px solid rgba(255,255,255,0.18); box-shadow: 0 0 0 1px rgba(130,100,255,0.12), 0 8px 28px var(--card-shadow); background: var(--map-bg); }

        .card { background: var(--card-bg); border-radius: 16px; padding: 12px; margin-bottom: 12px; border: 1px solid var(--card-border); backdrop-filter: blur(18px) saturate(140%); box-shadow: 0 8px 28px var(--card-shadow); transition: all 0.25s ease; }
        .card h3 { color: var(--text-heading); font-size:15px; margin-bottom:10px; font-family: var(--font-display); }

        .stats-grid { display:grid; grid-template-columns: 1fr 1fr; gap:8px }
        .stat-box { background: var(--stat-bg); border:1px solid rgba(255,255,255,0.05); border-radius: 8px; padding:8px; text-align:center }

        .empty-state { color: var(--text-sub); padding:16px; font-size:12px }
        .stat-number { font-size:18px; color: var(--text) }
        .stat-label { font-size:11px; color: var(--text-sub) }

        /* Map overlays */
        .map-overlay { position:absolute; top:8px; left:8px; display:flex; gap:8px; z-index:500; }
        .overlay-pill { background: rgba(18, 24, 38, 0.55); border:1px solid rgba(255,255,255,0.06); color:var(--text); padding:8px 12px; border-radius:16px; font-size:12px; backdrop-filter: blur(18px) saturate(140%); box-shadow: 0 8px 28px rgba(0,0,0,0.45); transition: all 0.25s ease }
        .info-strip { position:absolute; top:8px; left:8px; right:8px; display:flex; gap:8px; flex-wrap:wrap; z-index:600 }
        .info-item { background: var(--card-bg); border:1px solid var(--card-border); color: var(--text); padding:8px 12px; border-radius:16px; font-size:12px; backdrop-filter: blur(18px) saturate(140%); box-shadow: 0 8px 28px var(--card-shadow); transition: all 0.25s ease }
        .info-label { color: var(--text-sub); margin-right:6px }
        .info-eta { background: rgba(23,32,54,0.32); border-color:#304b8a; color:#cfe3ff; font-weight:600 }
        .overlay-right { position:absolute; top:8px; right:8px; z-index:500 }
        .eta-pill { background:#172036; border-color:#304b8a; color:#cfe3ff; font-weight:600 }

        /* Route chips */
        .route-chips { display:flex; flex-wrap:wrap; gap:8px }
        .route-chip { padding:8px 12px; border-radius:999px; font-size:12px; border:1px solid var(--chip-border); cursor:pointer; background: var(--chip-gradient); color: var(--text); transition: all 0.25s ease }
        .route-chip.active { background: rgba(255,255,255,0.08); box-shadow: 0 0 0 2px rgba(255,255,255,0.12) }
            /* Glossy buttons */
            #locateMeBtn { background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0)) !important; border:1px solid rgba(255,255,255,0.06) !important; border-radius:16px !important; box-shadow: 0 8px 28px rgba(0,0,0,0.45); transition: all 0.25s ease }
        .route-chip:active { transform: scale(0.98) }

        /* Active buses smaller */
        .bus-item { display:flex; align-items:center; justify-content:space-between; padding:6px 8px; border-left:4px solid; margin-bottom:6px; font-size:12px; transition: transform 120ms ease, background 120ms ease }
        .bus-item.active-route { transform: scale(1.06); background: rgba(255,255,255,0.04) }
        .bus-info { display:flex; align-items:center; gap:8px }
        .bus-dot { width:20px; height:20px; border-radius:50%; display:flex; align-items:center; justify-content:center; color:#fff; font-size:11px }
        .bus-name { opacity:0.8 }
        .bus-item:hover .bus-name { opacity:1 }

        /* Tiny stop markers */
        .marker-wrapper { width:10px; height:10px; filter: saturate(var(--theme-icon-saturation, 1.42)) brightness(var(--theme-icon-brightness, 1.12)) }
        .tiny-marker { display:inline-block; width:10px; height:10px; border-radius:50%; border:1px solid rgba(0,0,0,0.6) }
        .tiny-hostel { background:#9C27B0 }
        .tiny-class { background:#2196F3 }

        /* Layer control */
        .layer-control { display:flex; gap:8px; flex-wrap:wrap }
        .toggle-item { display:flex; align-items:center; gap:8px; background: rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.06); padding:6px 8px; border-radius:8px }
        .toggle-label { font-size:12px; color: var(--text) }
        .layer-icon { width:16px; height:8px; border-radius:999px; display:inline-block; border:1px solid rgba(255,255,255,0.2) }

        /* Status pulse dot */
        .pulse { width:6px; height:6px; border-radius:50%; display:inline-block; margin-right:6px; background:#34d399; box-shadow:0 0 0 rgba(52,211,153,0.4); animation: pulse 2s infinite }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(52,211,153,0.4) } 70% { box-shadow: 0 0 0 6px rgba(52,211,153,0) } 100% { box-shadow: 0 0 0 0 rgba(52,211,153,0) } }

        .bus-icon { transition: transform 0.15s ease; }
        @keyframes spin { 0%{transform:rotate(0deg)} 100%{transform:rotate(360deg)} }
        .eta-spinner { display:inline-block;width:10px;height:10px;border:1.5px solid rgba(52,211,153,0.3);border-top-color:#34d399;border-radius:50%;animation:spin 0.8s linear infinite;vertical-align:middle;margin-right:4px }

        @media (max-width: 968px) {
            .main-container { flex-direction:column; padding:12px }
            .map-container { order: 2 }
            .sidebar { order: 1 }
            #map { height: 420px }
        }

        
        .stat-box {
            background: var(--stat-bg);
            border: 1px solid var(--stat-border);
            background-image: var(--stat-gradient);
            backdrop-filter: blur(16px) saturate(140%);
            box-shadow: 0 6px 20px var(--card-shadow), inset 0 0 0 1px var(--stat-inner);
        }
        .info-item,
        .overlay-pill {
            border: 1px solid var(--stat-border);
            background-image: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.02));
            backdrop-filter: blur(16px) saturate(140%);
            box-shadow: 0 6px 20px var(--card-shadow), inset 0 0 0 1px var(--stat-inner);
        }
        .route-chip {
            border-color: var(--chip-border);
            background-image: var(--chip-gradient);
            box-shadow: var(--chip-shadow);
        }
        /* Blur non-selected route stops */
        .marker-wrapper.stop-blur {
            filter: blur(1.6px) brightness(0.95);
            opacity: 0.6;
            transition: filter 150ms ease, opacity 150ms ease;
        }
        /* Theme toggle buttons */
        .theme-btn { padding:8px 10px; border-radius:10px; border:1px solid var(--input-border); background: var(--card-bg); color: var(--text); cursor:pointer; font-size:14px; line-height:1; transition: all 0.2s; backdrop-filter:blur(8px); }
        .theme-btn:hover { opacity:0.85; }
        .map-theme-btn { position:absolute; bottom:12px; right:12px; z-index:600; padding:7px 9px; border-radius:8px; border:1px solid rgba(255,255,255,0.15); background:rgba(18,24,38,0.8); color:var(--text); cursor:pointer; font-size:14px; line-height:1; backdrop-filter:blur(8px); transition:all 0.2s; box-shadow:0 2px 8px rgba(0,0,0,0.3); }
        .map-theme-btn:hover { opacity:0.85; }

        /* UI refactor overrides */
        :root {
            --space-1: 8px;
            --space-2: 16px;
            --space-3: 24px;
            --space-4: 32px;
            --apple-radius-xl: 30px;
            --apple-radius-lg: 24px;
            --apple-radius-md: 18px;
            --apple-radius-sm: 14px;
            --accent-blue: #8b64ff;
            --accent-cyan: #c38aff;
            --bg: #0b0c14;
            --bg-gradient1: rgba(132, 78, 255, 0.48);
            --bg-gradient2: rgba(118, 66, 255, 0.36);
            --ai-grid: rgba(164, 150, 255, 0.04);
            --ai-glow: rgba(142, 92, 255, 0.46);
            --text: #e6eef8;
            --text-sub: #a6acc4;
            --text-heading: #f5f8ff;
            --card-bg: rgba(24, 22, 44, 0.68);
            --card-border: rgba(172, 132, 255, 0.50);
            --card-shadow: 0 12px 30px rgba(2, 8, 20, 0.30);
            --stat-bg: rgba(255, 255, 255, 0.11);
            --stat-border: rgba(176, 136, 255, 0.52);
            --stat-gradient: linear-gradient(160deg, rgba(255,255,255,0.18), rgba(255,255,255,0.04));
            --stat-inner: rgba(255, 255, 255, 0.08);
            --input-bg: rgba(19, 22, 36, 0.84);
            --input-border: rgba(176, 136, 255, 0.56);
            --chip-border: rgba(176, 136, 255, 0.54);
            --chip-gradient: linear-gradient(160deg, rgba(255,255,255,0.24), rgba(255,255,255,0.08));
            --chip-shadow: inset 0 1px 0 rgba(255,255,255,0.14), 0 6px 14px rgba(0,0,0,0.16);
            --map-border: rgba(176, 136, 255, 0.52);
            --map-bg: #0a0d18;
            --glass-blur: 7px;
            --glass-blur-sidebar: 5px;
            --glass-blur-panel: 6px;
            --glass-blur-map: 14px;
            --glass-sat: 122%;
            --glass-highlight: linear-gradient(165deg, rgba(255,255,255,0.18), rgba(255,255,255,0.06) 46%, rgba(255,255,255,0.02));
            --liquid-edge: rgba(196, 146, 255, 0.52);
            --liquid-fill: linear-gradient(165deg, rgba(224, 196, 255, 0.26), rgba(178, 134, 255, 0.12) 52%, rgba(255,255,255,0.02));
            --liquid-fill-soft: linear-gradient(165deg, rgba(218, 190, 255, 0.17), rgba(175, 132, 255, 0.08));
            --liquid-shadow-sm: 0 10px 20px rgba(6, 12, 30, 0.24), inset 0 1px 0 rgba(255,255,255,0.14);
            --liquid-shadow-lg: 0 18px 38px rgba(4, 10, 24, 0.34), inset 0 1px 0 rgba(255,255,255,0.16);
            --ui-theme-accent: #8b64ff;
            --ui-theme-accent-rgb: 139, 100, 255;
            --ui-theme-hue: 0deg;
            --ui-theme-saturation: 120%;
            --theme-icon-saturation: 1.42;
            --theme-icon-brightness: 1.12;
        }
        body.light-mode {
            --bg: #eef0f8;
            --bg-gradient1: rgba(132, 87, 255, 0.30);
            --bg-gradient2: rgba(153, 108, 255, 0.22);
            --ai-grid: rgba(111, 101, 174, 0.04);
            --ai-glow: rgba(136, 90, 255, 0.30);
            --text: #1c2238;
            --text-sub: #5c6480;
            --text-heading: #242d46;
            --card-bg: rgba(255, 255, 255, 0.78);
            --card-border: rgba(135, 94, 205, 0.44);
            --card-shadow: 0 10px 22px rgba(62, 65, 105, 0.12);
            --stat-bg: rgba(255, 255, 255, 0.84);
            --stat-border: rgba(135, 94, 205, 0.40);
            --stat-gradient: linear-gradient(160deg, rgba(255,255,255,0.90), rgba(241,247,255,0.72));
            --stat-inner: rgba(141, 121, 192, 0.09);
            --input-bg: rgba(255,255,255,0.78);
            --input-border: rgba(135, 94, 205, 0.50);
            --chip-border: rgba(135, 94, 205, 0.50);
            --chip-gradient: linear-gradient(160deg, rgba(255,255,255,0.98), rgba(241,247,255,0.82));
            --chip-shadow: inset 0 1px 0 rgba(255,255,255,0.92), 0 6px 14px rgba(65,58,106,0.10);
            --map-border: rgba(135, 94, 205, 0.44);
            --map-bg: #eceffd;
            --glass-blur: 5px;
            --glass-blur-sidebar: 4px;
            --glass-blur-panel: 5px;
            --glass-blur-map: 11px;
            --glass-sat: 114%;
            --glass-highlight: linear-gradient(165deg, rgba(255,255,255,0.92), rgba(255,255,255,0.72) 52%, rgba(242,247,255,0.54));
            --liquid-edge: rgba(136, 95, 206, 0.46);
            --liquid-fill: linear-gradient(165deg, rgba(240, 230, 255, 0.98), rgba(228, 212, 255, 0.80) 56%, rgba(242,236,255,0.64));
            --liquid-fill-soft: linear-gradient(165deg, rgba(248, 243, 255, 0.94), rgba(234, 221, 255, 0.76));
            --liquid-shadow-sm: 0 8px 16px rgba(70, 74, 112, 0.10), inset 0 1px 0 rgba(255,255,255,0.94);
            --liquid-shadow-lg: 0 16px 28px rgba(74, 76, 116, 0.12), inset 0 1px 0 rgba(255,255,255,0.95);
        }
        html {
            height: 100%;
            overflow: hidden;
        }
        body {
            font-family: var(--font-ui);
            font-weight: 400;
            height: 100vh;
            height: 100dvh;
            min-height: 100vh;
            min-height: 100dvh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative;
            background-image:
                radial-gradient(circle at 12% 8%, var(--bg-gradient1), transparent 44%),
                radial-gradient(circle at 88% 18%, var(--bg-gradient2), transparent 40%);
            filter: hue-rotate(var(--ui-theme-hue, 0deg)) saturate(var(--ui-theme-saturation, 120%));
        }
        body::before,
        body::after {
            content: '';
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 0;
        }
        body::before {
            background: linear-gradient(180deg, rgba(255,255,255,0.10), transparent 42%);
            opacity: 0.52;
        }
        body::after {
            background:
                radial-gradient(500px 240px at 82% 8%, var(--ai-glow), transparent 72%),
                radial-gradient(360px 190px at 10% 84%, var(--ai-glow), transparent 74%);
            opacity: 0.70;
        }
        .header {
            max-width: none;
            margin: 0;
            padding: clamp(10px, 1.3vh, 18px) 0 clamp(8px, 1.1vh, 14px);
            gap: clamp(8px, 1vw, 14px);
            position: relative;
            z-index: 1200;
            display: grid;
            grid-template-columns: minmax(320px, 0.95fr) minmax(0, 1.75fr) auto;
            align-items: center;
            justify-content: space-between;
            background: transparent;
            border: none;
            border-radius: 0;
            box-shadow: none;
        }
        .header::after {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 1px;
            background: linear-gradient(90deg, rgba(255,255,255,0), rgba(198, 174, 255, 0.38), rgba(255,255,255,0));
            pointer-events: none;
            opacity: 0.9;
        }
        .header-brand {
            min-width: 0;
            display: flex;
            align-items: center;
        }
        .brand-tile {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 14px;
            border-radius: var(--apple-radius-md);
            border: 1px solid rgba(172, 132, 255, 0.42);
            background:
                linear-gradient(155deg, rgba(13, 15, 25, 0.96), rgba(16, 12, 31, 0.94));
            box-shadow:
                0 10px 24px rgba(2, 8, 20, 0.40),
                inset 0 1px 0 rgba(255,255,255,0.08),
                0 0 0 1px rgba(0,0,0,0.25);
            backdrop-filter: blur(8px) saturate(120%);
            -webkit-backdrop-filter: blur(8px) saturate(120%);
        }
        .brand-logo-wrap {
            width: 44px;
            height: 44px;
            border-radius: 12px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(190, 155, 255, 0.34);
            background: linear-gradient(165deg, rgba(38, 31, 66, 0.9), rgba(21, 17, 36, 0.9));
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.10);
            flex: 0 0 auto;
        }
        .brand-logo-wrap img {
            width: 30px;
            height: 30px;
            display: block;
            filter: drop-shadow(0 2px 4px rgba(95, 74, 160, 0.34));
        }
        .brand-text {
            min-width: 0;
        }
        .header .brand-text h1 {
            margin: 0;
            font-size: 21px;
            line-height: 1.15;
            letter-spacing: -0.02em;
            color: #f5f8ff;
            font-family: var(--font-display);
            font-weight: 600;
        }
        .header .brand-text p {
            margin: 2px 0 0 0;
            font-size: 11px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #aeb8cf;
            font-family: var(--font-classic);
            font-style: italic;
        }
        .brand-script {
            font-family: var(--font-script);
            letter-spacing: 0.02em;
            text-transform: none;
            font-size: 1.1em;
            margin-left: 2px;
            color: #d8c5ff;
        }
        .header-assistant-slot {
            min-width: 0;
            width: min(100%, 1080px);
            justify-self: center;
            position: relative;
            z-index: 1210;
            overflow: visible;
        }
        .header h1 {
            font-size: 24px;
            font-weight: 600;
            color: var(--text-heading);
            letter-spacing: -0.02em;
        }
        .header p {
            font-weight: 400;
            color: var(--text-sub);
        }
        .header-actions {
            display:flex;
            align-items:center;
            gap: 6px;
            justify-content: flex-end;
            flex-wrap: nowrap;
            justify-self: end;
            min-width: 0;
        }
        button,
        input,
        select,
        textarea,
        .theme-btn,
        .admin-link,
        .header-quick-btn {
            font-family: var(--font-ui);
        }
        .header-quick-stack {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 4px;
        }
        .header-quick-stack .theme-btn,
        .header-quick-stack .admin-link,
        .header-quick-stack .perf-btn,
        .header-quick-stack #locateMeBtn {
            width: 100%;
            min-width: 64px;
            text-align: center;
        }
        .header-quick-stack .admin-link {
            display: block;
        }
        .admin-link {
            color: var(--text-sub);
            font-size: 12px;
            font-weight: 500;
            text-decoration: none;
            padding: 8px 10px;
            border-radius: var(--apple-radius-sm);
            border: 1px solid transparent;
            transition: all 0.2s ease;
        }
        .admin-link:hover {
            color: var(--text);
            border-color: var(--card-border);
            background: rgba(255,255,255,0.04);
        }
        .perf-btn {
            font-family: inherit;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.08em;
            line-height: 1;
            padding: 6px 7px;
            border-radius: 999px;
            border: 1px solid rgba(178, 152, 255, 0.22);
            background: rgba(255,255,255,0.03);
            color: var(--text-sub);
            opacity: 0.72;
            cursor: pointer;
            transition: opacity 0.12s linear, border-color 0.12s linear, color 0.12s linear, background-color 0.12s linear;
        }
        .perf-btn:hover {
            opacity: 0.95;
            border-color: rgba(178, 152, 255, 0.34);
            color: var(--text);
        }
        .perf-btn.active {
            opacity: 1;
            color: var(--text-heading);
            border-color: rgba(178, 152, 255, 0.50);
            background: rgba(130, 104, 255, 0.22);
        }

        .main-container {
            max-width: none;
            margin: 0;
            padding: 0 0 clamp(10px, 1.6vh, 18px);
            display:grid;
            grid-template-columns: minmax(0, 1.58fr) minmax(330px, 430px);
            gap: clamp(6px, 0.8vw, 10px);
            justify-content: center;
            align-items: stretch;
            flex: 1 1 auto;
            height: auto;
            min-height: 0;
            overflow: hidden;
            position: relative;
            z-index: 1;
        }
        .map-container {
            order: 1;
            min-width: 0;
            width: 100%;
            max-width: none;
            height: 100%;
            display:grid;
            grid-template-rows: minmax(0, 1fr) auto;
            gap: clamp(6px, 0.9vh, 10px);
            align-content: stretch;
        }
        .map-stage {
            position: relative;
            width: 100%;
            min-width: 0;
            min-height: 0;
            height: 100%;
            aspect-ratio: auto;
            max-height: none;
            display:flex;
            align-items:stretch;
            border-radius: var(--apple-radius-xl);
            overflow: hidden;
        }
        .map-fx {
            position: absolute;
            inset: 0;
            border-radius: var(--apple-radius-xl);
            pointer-events: none;
            opacity: 0;
            z-index: 7;
            transform-origin: center;
            transition: opacity 0.26s ease, transform 0.28s cubic-bezier(0.22, 1, 0.36, 1);
            animation: map-fade-in 0.55s ease forwards;
        }
        .map-ambient {
            background: linear-gradient(180deg, rgba(255,255,255,0.08) 0%, rgba(17,14,28,0.03) 34%, rgba(5,6,10,0.10) 100%);
            z-index: 8;
        }
        .map-texture {
            background-image:
                repeating-linear-gradient(0deg, rgba(184,166,255,0.05) 0px, rgba(184,166,255,0.05) 1px, transparent 1px, transparent 30px),
                repeating-linear-gradient(90deg, rgba(184,166,255,0.04) 0px, rgba(184,166,255,0.04) 1px, transparent 1px, transparent 30px);
            opacity: 0.09;
            z-index: 9;
        }
        .map-vignette {
            box-shadow: inset 0 0 42px rgba(4, 8, 14, 0.16), inset 0 0 0 1px rgba(255,255,255,0.05);
            z-index: 10;
        }
        body.light-mode .map-ambient {
            background: linear-gradient(180deg, rgba(255,255,255,0.20) 0%, rgba(255,255,255,0.05) 40%, rgba(48,34,92,0.08) 100%);
        }
        body.light-mode .map-texture {
            opacity: 0.10;
        }
        body.light-mode .map-vignette {
            box-shadow: inset 0 0 58px rgba(62, 54, 98, 0.12), inset 0 0 0 1px rgba(126,110,176,0.12);
        }
        body.light-mode .live-badge {
            background: rgba(255,255,255,0.72);
            color: #45328b;
            border-color: rgba(140, 122, 196, 0.36);
        }
        .live-badge {
            position: absolute;
            top: 16px;
            right: 16px;
            z-index: 620;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 999px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.08em;
            color: #f4edff;
            border: 1px solid rgba(181, 158, 255, 0.30);
            background: rgba(22, 20, 34, 0.58);
            backdrop-filter: blur(4px) saturate(112%);
            -webkit-backdrop-filter: blur(4px) saturate(112%);
            opacity: 0;
            animation: map-fade-in 0.55s ease forwards 0.08s;
            transition: opacity 0.2s ease;
        }
        .live-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background: #3bffb3;
            box-shadow: 0 0 0 0 rgba(59,255,179,0.45);
            animation: live-dot-blink 1.4s ease-in-out infinite;
        }
        @keyframes live-dot-blink {
            0%, 100% { opacity: 0.92; box-shadow: 0 0 0 0 rgba(59,255,179,0.45); }
            50% { opacity: 0.38; box-shadow: 0 0 0 5px rgba(59,255,179,0); }
        }
        @keyframes map-fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .route-main-line,
        .route-glow-line {
            transition: opacity 0.2s ease, stroke-width 0.2s ease;
        }
        .route-glow-line {
            filter: saturate(112%);
        }
        .bus-icon {
            transition: transform 0.15s ease, opacity 0.2s ease;
        }
        .bus-marker-wrap {
            position: relative;
            display: inline-block;
            opacity: 0;
            animation: map-fade-in 0.4s ease forwards;
            filter: saturate(1.48) brightness(1.12);
            transition: filter 0.16s linear, opacity 0.16s linear;
        }
        .bus-marker-wrap.is-tracked {
            filter: saturate(2.05) brightness(1.34) drop-shadow(0 0 18px rgba(171, 145, 255, 0.64));
        }
        .bus-marker-wrap.is-dimmed {
            filter: saturate(0.42) brightness(0.56);
        }
        .bus-marker-pulse {
            position: absolute;
            left: var(--marker-anchor-x, 50%);
            top: var(--marker-anchor-y, 50%);
            width: var(--marker-halo-size, 34px);
            height: var(--marker-halo-size, 34px);
            transform: translate(-50%, -50%) scale(1);
            border: 1.4px solid rgba(171, 145, 255, 0.45);
            border-radius: 50%;
            opacity: 0.6;
            animation: bus-pulse-ring 1.9s ease-out infinite;
            pointer-events: none;
        }
        .bus-marker-shadow {
            position: absolute;
            left: 50%;
            bottom: -6px;
            width: 66%;
            height: 8px;
            transform: translateX(-50%);
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0,0,0,0.34) 0%, rgba(0,0,0,0.02) 75%);
            opacity: 0.5;
            pointer-events: none;
        }
        .bus-marker-selected {
            position: absolute;
            left: var(--marker-anchor-x, 50%);
            top: var(--marker-anchor-y, 50%);
            width: var(--marker-halo-size, 34px);
            height: var(--marker-halo-size, 34px);
            transform: translate(-50%, -50%);
            border-radius: 50%;
            border: 1.8px solid rgba(216, 196, 255, 0.82);
            box-shadow:
                0 0 0 2px rgba(124, 94, 255, 0.34),
                0 0 18px rgba(171, 145, 255, 0.42);
            opacity: 0.94;
            pointer-events: none;
        }
        .bus-marker-selected::after {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 50%;
            border: 1.5px solid rgba(204, 178, 255, 0.74);
            box-shadow: 0 0 12px rgba(171, 145, 255, 0.44);
            opacity: 0.75;
            animation: tracked-glow 1.6s ease-in-out infinite;
        }
        @keyframes bus-pulse-ring {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 0.62; }
            100% { transform: translate(-50%, -50%) scale(1.35); opacity: 0; }
        }
        @keyframes tracked-glow {
            0%, 100% { transform: scale(1); opacity: 0.74; }
            50% { transform: scale(1.2); opacity: 0.18; }
        }
        .sidebar {
            order: 2;
            min-width: 0;
            display:grid;
            grid-auto-rows: max-content;
            gap: clamp(8px, 1vh, 12px);
            max-height: 100%;
            min-height: 0;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 2px;
            padding-bottom: clamp(10px, 1.5vh, 16px);
            scroll-padding-bottom: clamp(10px, 1.5vh, 16px);
            transform: translateZ(0);
            backface-visibility: hidden;
            contain: layout paint style;
        }
        .sidebar > .card {
            min-height: fit-content;
        }
        .sidebar.is-scrolling .card {
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            background-image: linear-gradient(160deg, rgba(255,255,255,0.13), rgba(255,255,255,0.05));
        }
        .sidebar.is-scrolling .card::after {
            display: none;
        }
        .sidebar::-webkit-scrollbar { width: 8px; }
        .sidebar::-webkit-scrollbar-track { background: transparent; }
        .sidebar::-webkit-scrollbar-thumb { background: rgba(145, 139, 188, 0.36); border-radius: 999px; }
        #map {
            width: 100%;
            height: 100%;
            min-height: 0;
            max-height: none;
            border-radius: var(--apple-radius-xl);
            border: 1px solid var(--map-border);
            position: relative;
            z-index: 6;
            box-shadow:
                0 10px 24px rgba(4, 10, 22, 0.24),
                0 0 0 1px rgba(255,255,255,0.10) inset;
            background: var(--map-bg);
            transition: transform 0.28s cubic-bezier(0.22, 1, 0.36, 1), box-shadow 0.28s ease, border-color 0.28s ease;
        }
        .map-stage:hover #map {
            border-color: rgba(168, 154, 255, 0.36);
            transform: none;
            box-shadow:
                0 14px 30px rgba(4, 10, 22, 0.30),
                0 0 0 1px rgba(255,255,255,0.12) inset;
        }
        .map-stage:hover .map-fx {
            transform: none;
        }
        .map-stage.layer-switching #map {
            opacity: 0.98;
            transition-duration: 0.12s;
        }
        .map-stage.layer-switching .map-fx {
            opacity: 0.90;
            transition-duration: 0.12s;
        }
        #map,
        #map.leaflet-container {
            -webkit-tap-highlight-color: transparent;
        }
        #map:focus,
        #map:focus-visible,
        #map.leaflet-container:focus,
        #map.leaflet-container:focus-visible,
        .leaflet-container:focus,
        .leaflet-container:focus-visible {
            outline: none !important;
        }
        @keyframes glass-sheen {
            0% {
                transform: translateX(-36%) rotate(11deg);
                opacity: 0.0;
            }
            30% {
                opacity: 0.7;
            }
            100% {
                transform: translateX(36%) rotate(11deg);
                opacity: 0.0;
            }
        }

        .card {
            margin-bottom: 0;
            padding: clamp(11px, 1vw, 14px);
            border-radius: var(--apple-radius-lg);
            border: 1px solid var(--card-border);
            background-color: var(--card-bg);
            backdrop-filter: blur(var(--glass-blur-sidebar)) saturate(var(--glass-sat));
            -webkit-backdrop-filter: blur(var(--glass-blur-sidebar)) saturate(var(--glass-sat));
            box-shadow: var(--card-shadow);
            background-image: var(--glass-highlight);
            background-clip: padding-box;
            transition: transform 0.28s cubic-bezier(0.22, 1, 0.36, 1), border-color 0.28s ease, background 0.28s ease, box-shadow 0.28s ease;
            position: relative;
            overflow: hidden;
            isolation: isolate;
            contain: paint;
        }
        .card::after {
            content: '';
            position: absolute;
            top: -45%;
            left: -42%;
            width: 58%;
            height: 190%;
            background: linear-gradient(120deg, transparent 34%, rgba(255,255,255,0.20) 50%, transparent 66%);
            opacity: 0;
            pointer-events: none;
        }
        .card:hover {
            transform: translateY(-5px);
            border-color: rgba(168, 154, 255, 0.34);
            box-shadow: 0 16px 32px rgba(4, 10, 22, 0.34);
        }
        .card:hover::after {
            animation: glass-sheen 0.8s ease forwards;
        }
        .card h3 {
            font-size: 15px;
            font-weight: 600;
            margin-bottom: var(--space-1);
            display:flex;
            align-items:center;
            gap: 6px;
            letter-spacing: 0.01em;
        }

        .stats-grid { gap: 12px; }
        .stat-box {
            border-radius: var(--apple-radius-md);
            padding: 12px;
            text-align: left;
            backdrop-filter: blur(3px) saturate(104%);
            -webkit-backdrop-filter: blur(3px) saturate(104%);
            box-shadow: 0 5px 12px rgba(0,0,0,0.12), inset 0 0 0 1px var(--stat-inner);
        }
        .stat-number {
            font-size: 26px;
            font-weight: 600;
            color: var(--text-heading);
            letter-spacing: -0.02em;
            line-height: 1.1;
        }
        .stat-label {
            margin-top: 4px;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-sub);
        }
        .live-track-pill {
            margin-left: auto;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 999px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.08em;
            color: var(--text-heading);
            background: rgba(41, 30, 78, 0.62);
            border: 1px solid rgba(168, 154, 255, 0.34);
        }
        .live-stats-card,
        .sidebar > .card:first-child {
            padding: 10px 12px;
        }
        .live-stats-card h3,
        .sidebar > .card:first-child h3 {
            margin-bottom: 8px;
            font-size: 14px;
        }
        .live-stats-card .live-track-pill,
        .sidebar > .card:first-child .live-track-pill {
            padding: 3px 7px;
            font-size: 9px;
            letter-spacing: 0.07em;
        }
        .sidebar > .card:first-child .stats-grid {
            display: flex;
            align-items: center;
            gap: 0;
            min-height: 36px;
            padding: 5px 10px;
            border-radius: 999px;
            border: 1px solid rgba(168, 154, 255, 0.34);
            background: linear-gradient(160deg, rgba(255,255,255,0.12), rgba(255,255,255,0.04));
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.12);
        }
        .sidebar > .card:first-child .stat-box {
            min-height: auto;
            padding: 2px 8px;
            border: 0;
            border-radius: 0;
            background: transparent;
            box-shadow: none;
            display: inline-flex;
            align-items: baseline;
            gap: 6px;
            text-align: left;
        }
        .sidebar > .card:first-child .stat-box + .stat-box {
            margin-left: 2px;
            padding-left: 12px;
            border-left: 1px solid rgba(168, 154, 255, 0.26);
        }
        .sidebar > .card:first-child .stat-number {
            font-size: 18px;
            line-height: 1;
        }
        .sidebar > .card:first-child .stat-label {
            margin-top: 0;
            font-size: 10px;
            letter-spacing: 0.06em;
            text-transform: uppercase;
        }
        .live-mini-tile {
            display: flex;
            align-items: center;
            gap: 8px;
            min-height: 36px;
            padding: 7px 10px;
            border-radius: 999px;
            border: 1px solid rgba(168, 154, 255, 0.34);
            background: linear-gradient(160deg, rgba(255,255,255,0.12), rgba(255,255,255,0.04));
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.12);
        }
        .live-mini-item {
            min-width: 0;
            display: inline-flex;
            align-items: baseline;
            gap: 6px;
        }
        .live-mini-label {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.08em;
            color: var(--text-sub);
            text-transform: uppercase;
        }
        .live-mini-value {
            font-size: 18px;
            font-weight: 600;
            line-height: 1;
            color: var(--text-heading);
        }
        .live-mini-divider {
            width: 1px;
            align-self: stretch;
            background: rgba(168, 154, 255, 0.26);
        }
        .live-track-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #41f7b3;
            box-shadow: 0 0 0 0 rgba(65,247,179,0.36);
            animation: live-track-pulse 2s ease-in-out infinite;
        }
        @keyframes live-track-pulse {
            0%, 100% { opacity: 0.9; box-shadow: 0 0 0 0 rgba(65,247,179,0.36); }
            50% { opacity: 0.4; box-shadow: 0 0 0 5px rgba(65,247,179,0); }
        }
        .routes-card,
        .route-details-card,
        .active-transport-card,
        .sidebar > .card:nth-of-type(3),
        #routeDetailsCard,
        .sidebar > .card:nth-of-type(5),
        .ops-master-card {
            padding: 14px;
        }
        .routes-card h3,
        .route-details-card h3,
        .active-transport-card h3,
        .sidebar > .card:nth-of-type(3) h3,
        #routeDetailsCard h3,
        .sidebar > .card:nth-of-type(5) h3,
        .ops-master-card h3 {
            margin-bottom: 10px;
        }
        .ops-master-card h3 {
            justify-content: space-between;
            gap: 10px;
        }
        .ops-title-group {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            min-width: 0;
        }
        .ops-diamond {
            color: #d8ceff;
            text-shadow: 0 0 8px rgba(168, 154, 255, 0.32);
        }
        .ai-galaxy-icon {
            position: relative;
            width: 14px;
            height: 14px;
            display: inline-block;
            flex: 0 0 auto;
        }
        .ai-galaxy-icon::before {
            content: '';
            position: absolute;
            inset: 0;
            clip-path: polygon(50% 0%, 63% 37%, 100% 50%, 63% 63%, 50% 100%, 37% 63%, 0% 50%, 37% 37%);
            background: conic-gradient(from 220deg, #ff7b8a, #8aa2ff 36%, #58db9d 64%, #ffe285 86%, #ff7b8a);
            transform: rotate(45deg);
            filter: drop-shadow(0 0 4px rgba(146, 176, 255, 0.4));
            animation: galaxy-ai-float 4.8s ease-in-out infinite;
        }
        .ai-galaxy-icon::after {
            content: '';
            position: absolute;
            inset: 4px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.84), rgba(255,255,255,0));
            pointer-events: none;
        }
        .ai-icon-stack {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            opacity: 0.94;
            flex-shrink: 0;
        }
        .ai-spark {
            width: 10px;
            height: 10px;
            flex: 0 0 auto;
            clip-path: polygon(50% 0%, 62% 38%, 100% 50%, 62% 62%, 50% 100%, 38% 62%, 0% 50%, 38% 38%);
            background: conic-gradient(from 220deg, #ff7b8a, #7f9dff 36%, #56d79c 63%, #ffe37a 86%, #ff7b8a);
            transform: rotate(45deg);
            filter: drop-shadow(0 0 3px rgba(138, 186, 255, 0.3));
            animation: ai-spark-float 5.2s ease-in-out infinite;
        }
        .ai-spark.s2 {
            width: 8px;
            height: 8px;
            opacity: 0.82;
            animation-delay: -1.3s;
        }
        .ai-spark.s3 {
            width: 7px;
            height: 7px;
            opacity: 0.72;
            animation-delay: -2.6s;
        }
        @keyframes galaxy-ai-float {
            0%, 100% { transform: rotate(45deg) translateY(0) scale(1); }
            50% { transform: rotate(45deg) translateY(-1px) scale(1.07); }
        }
        @keyframes ai-spark-float {
            0%, 100% { transform: rotate(45deg) translateY(0) scale(1); }
            50% { transform: rotate(45deg) translateY(-1px) scale(1.05); }
        }
        body.light-mode .ai-galaxy-icon::before {
            filter: drop-shadow(0 0 3px rgba(108, 132, 202, 0.28));
        }
        body.light-mode .ai-spark {
            filter: drop-shadow(0 0 3px rgba(108, 132, 202, 0.28));
        }
        .ops-master-card {
            order: 10;
        }
        .ops-panel {
            border: 1px solid rgba(168, 154, 255, 0.22);
            border-radius: var(--apple-radius-md);
            padding: 8px;
            background: linear-gradient(165deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
        }
        .ops-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 8px;
        }
        .ops-tile {
            position: relative;
            overflow: hidden;
            border-radius: 14px;
            border: 1px solid rgba(168, 154, 255, 0.24);
            background: rgba(20, 24, 38, 0.52);
            padding: 8px 9px;
            min-height: 60px;
            transition: transform 0.24s ease, border-color 0.24s ease, background 0.24s ease;
        }
        .ops-tile::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(140deg, rgba(255,255,255,0.10), transparent 52%);
            opacity: 0.55;
            pointer-events: none;
        }
        .ops-tile:hover {
            transform: translateY(-1px);
            border-color: rgba(176, 161, 255, 0.36);
        }
        .ops-wide { grid-column: 1 / -1; }
        #opsAvailabilityTile {
            grid-column: 2;
            grid-row: 2;
        }
        #opsRouteHealthTile {
            grid-column: 1;
            grid-row: 3;
        }
        #opsSystemTile {
            grid-column: 2;
            grid-row: 3;
            min-height: 52px;
        }
        #opsSystemTile .ops-value {
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.06em;
            text-transform: uppercase;
        }
        .ops-kicker {
            position: relative;
            z-index: 1;
            font-size: 11px;
            font-weight: 500;
            color: var(--text-sub);
            margin-bottom: 6px;
            text-transform: none;
            letter-spacing: 0.01em;
        }
        .ops-value {
            position: relative;
            z-index: 1;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-heading);
            line-height: 1.35;
        }
        .eta-rotor {
            display: inline-block;
            margin-left: 5px;
            font-size: 11px;
            opacity: 0.72;
            animation: eta-rotor-spin 3.8s linear infinite;
        }
        @keyframes eta-rotor-spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .ui-flash {
            animation: ui-soft-flash 0.32s ease;
        }
        @keyframes ui-soft-flash {
            0% { box-shadow: 0 0 0 0 rgba(171,145,255,0.28), inset 0 0 0 1px rgba(171,145,255,0.36); }
            100% { box-shadow: none; }
        }
        .bus-trail-line {
            stroke-linecap: round;
            stroke-linejoin: round;
            transition: opacity 1s ease;
        }
        .empty-state {
            border: 1px dashed var(--card-border);
            border-radius: var(--apple-radius-md);
            background: rgba(255,255,255,0.02);
        }

        .route-chip {
            font-family: inherit;
            font-weight: 500;
            transition: transform 0.24s cubic-bezier(0.22, 1, 0.36, 1), border-color 0.24s ease, background 0.24s ease, box-shadow 0.24s ease;
        }
        .route-chip:hover {
            transform: translateY(-2px) scale(1.035);
            border-color: rgba(168, 154, 255, 0.34);
            box-shadow: 0 10px 20px rgba(5, 18, 34, 0.22);
        }

        .active-buses {
            display:flex;
            flex-direction:column;
            gap: var(--space-1);
            max-height: min(23vh, 180px);
            overflow: auto;
            padding-right: 2px;
        }
        .active-buses::-webkit-scrollbar { width: 8px; }
        .active-buses::-webkit-scrollbar-track { background: transparent; }
        .active-buses::-webkit-scrollbar-thumb { background: rgba(145, 139, 188, 0.38); border-radius: 999px; }
        .bus-item {
            padding: 10px 12px;
            margin-bottom: 0;
            border-radius: var(--apple-radius-md);
            border: 1px solid rgba(168, 154, 255, 0.20);
            background: rgba(255,255,255,0.03);
            transition: transform 0.22s cubic-bezier(0.22, 1, 0.36, 1), background 0.22s ease, border-color 0.22s ease, box-shadow 0.22s ease;
            cursor:pointer;
        }
        .bus-item:hover {
            transform: translateX(4px) scale(1.012);
            background: rgba(255,255,255,0.06);
            border-color: rgba(168, 154, 255, 0.34);
            box-shadow: 0 10px 18px rgba(6, 18, 32, 0.22);
        }
        .bus-item.active-route {
            transform: none;
            box-shadow: 0 0 0 1px rgba(255,255,255,0.1) inset;
        }
        .bus-item.tracked {
            border-color: rgba(177, 157, 255, 0.56);
            background: linear-gradient(160deg, rgba(156, 122, 255, 0.22), rgba(255,255,255,0.06));
            box-shadow:
                0 0 0 2px rgba(156, 122, 255, 0.26),
                0 10px 20px rgba(7, 18, 34, 0.24);
            transform: translateX(3px) scale(1.012);
        }
        .bus-item.tracked .bus-dot {
            transform: scale(1.14);
            box-shadow: 0 0 0 3px rgba(156, 122, 255, 0.22), 0 4px 14px rgba(0,0,0,0.34);
        }
        .bus-item.tracked .bus-name {
            font-weight: 600;
        }
        .route-bus-item.tracked {
            border-color: rgba(177, 157, 255, 0.60) !important;
            background: linear-gradient(160deg, rgba(156, 122, 255, 0.22), rgba(255,255,255,0.08)) !important;
            box-shadow: 0 0 0 2px rgba(156, 122, 255, 0.28), 0 10px 18px rgba(7, 18, 34, 0.24) !important;
        }
        .route-bus-item .route-bus-dot {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .route-bus-item.tracked .route-bus-dot {
            transform: scale(1.12);
            box-shadow: 0 0 0 3px rgba(156, 122, 255, 0.22), 0 4px 12px rgba(0,0,0,0.32);
        }
        .bus-dot {
            width: 24px;
            height: 24px;
            font-size: 11px;
            font-weight: 600;
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
        }
        .bus-name { font-weight: 500; opacity: 0.9; }
        .bus-status {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            font-weight: 500;
        }

        .info-strip {
            top: 22px;
            left: 22px;
            right: 22px;
            gap: 10px;
            padding-right: 112px;
            pointer-events:none;
        }
        .info-item {
            padding: 12px 16px;
            border-radius: var(--apple-radius-md);
            font-size: 13px;
            font-weight: 500;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            backdrop-filter: blur(5px) saturate(108%);
            -webkit-backdrop-filter: blur(5px) saturate(108%);
            box-shadow: 0 5px 12px rgba(0,0,0,0.14), inset 0 0 0 1px rgba(255,255,255,0.08);
        }
        .overlay-pill {
            backdrop-filter: blur(4px) saturate(106%);
            -webkit-backdrop-filter: blur(4px) saturate(106%);
            background-image: var(--glass-highlight);
        }
        .info-label { font-weight: 500; }
        .info-eta {
            background: rgba(44, 32, 90, 0.88);
            border-color: rgba(171, 145, 255, 0.48);
            color: var(--text-heading);
        }

        .map-layers-card {
            backdrop-filter: blur(var(--glass-blur-panel)) saturate(114%);
            -webkit-backdrop-filter: blur(var(--glass-blur-panel)) saturate(114%);
            border-color: rgba(178, 152, 255, 0.32);
            box-shadow: 0 14px 28px rgba(5, 12, 28, 0.22);
            transition: transform 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, opacity 0.12s linear;
            align-self: stretch;
            margin-top: 0;
            padding: 12px 14px;
        }
        .map-layers-card h3 {
            margin-bottom: 9px;
            font-size: 15px;
        }
        .map-layers-card.layer-switching {
            transform: translateY(-1px);
            box-shadow: 0 16px 30px rgba(5, 12, 28, 0.26);
            border-color: rgba(183, 164, 255, 0.44);
        }
        .layer-control {
            display:grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 7px;
            margin-bottom: 8px;
        }
        .toggle-item {
            --layer-color: #a78bfa;
            position: relative;
            display: flex;
            align-items: center;
            gap: 7px;
            padding: 8px 10px;
            border-radius: 999px;
            border: 1px solid rgba(168, 154, 255, 0.24);
            background: linear-gradient(160deg, rgba(255,255,255,0.10), rgba(255,255,255,0.03));
            backdrop-filter: blur(var(--glass-blur-panel)) saturate(112%);
            -webkit-backdrop-filter: blur(var(--glass-blur-panel)) saturate(112%);
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.14), 0 8px 16px rgba(6, 18, 32, 0.16);
            transition: transform 0.12s linear, opacity 0.12s linear, border-color 0.12s linear, box-shadow 0.12s linear, background 0.12s linear;
            cursor:pointer;
            overflow: hidden;
            isolation: isolate;
        }
        .toggle-item::after {
            content: '';
            position: absolute;
            inset: 0;
            pointer-events: none;
            border-radius: inherit;
            background: radial-gradient(130% 100% at 18% 50%, color-mix(in srgb, var(--layer-color) 34%, transparent), transparent 64%);
            opacity: 0;
            transition: opacity 0.12s linear;
            z-index: 0;
        }
        .toggle-item:hover {
            transform: translateY(-1px);
            border-color: color-mix(in srgb, var(--layer-color) 60%, rgba(255,255,255,0.28));
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.16), 0 10px 18px rgba(6, 18, 32, 0.20);
        }
        .toggle-item:hover::after { opacity: 0.48; }
        .toggle-item input[type="checkbox"] {
            position: absolute;
            opacity: 0;
            width: 1px;
            height: 1px;
            pointer-events: none;
        }
        .layer-pill-icon,
        .toggle-label,
        .layer-state { position: relative; z-index: 1; }
        .layer-pill-icon {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            line-height: 1;
            background: rgba(255,255,255,0.10);
            border: 1px solid rgba(255,255,255,0.14);
            box-shadow: 0 2px 8px rgba(0,0,0,0.16);
            transition: transform 0.12s linear, border-color 0.12s linear, background 0.12s linear;
        }
        .toggle-label {
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
        }
        .layer-state {
            margin-left: auto;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            font-size: 9px;
            font-weight: 500;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            color: var(--text-sub);
            transition: color 0.12s linear;
        }
        .layer-state-dot {
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background: rgba(255,255,255,0.32);
            box-shadow: 0 0 0 0 rgba(255,255,255,0.0);
            transition: background 0.12s linear, box-shadow 0.12s linear;
        }
        .layer-state-text::before { content: 'off'; }
        .toggle-item input[type="checkbox"]:checked + .layer-pill-icon {
            transform: scale(1.05);
            border-color: color-mix(in srgb, var(--layer-color) 60%, rgba(255,255,255,0.30));
            background: color-mix(in srgb, var(--layer-color) 26%, rgba(255,255,255,0.16));
        }
        .toggle-item input[type="checkbox"]:checked ~ .layer-state {
            color: var(--text-heading);
        }
        .toggle-item input[type="checkbox"]:checked ~ .layer-state .layer-state-dot {
            background: var(--layer-color);
            box-shadow: 0 0 0 4px color-mix(in srgb, var(--layer-color) 22%, transparent);
        }
        .toggle-item input[type="checkbox"]:checked ~ .layer-state .layer-state-text::before {
            content: 'active';
        }
        .map-status-grid {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 7px;
            padding-top: 7px;
            border-top: 1px solid rgba(173, 152, 246, 0.24);
            transition: opacity 0.12s linear, transform 0.12s linear;
        }
        .map-layers-card.layer-switching .map-status-grid {
            opacity: 0.84;
            transform: translateY(1px);
        }
        .map-status-item {
            padding: 7px 9px;
            border-radius: 14px;
            border: 1px solid rgba(173, 152, 246, 0.24);
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(var(--glass-blur-panel)) saturate(112%);
            -webkit-backdrop-filter: blur(var(--glass-blur-panel)) saturate(112%);
            min-height: 44px;
            transition: border-color 0.12s linear, background 0.12s linear;
        }
        .map-status-item:hover {
            border-color: rgba(183, 164, 255, 0.40);
            background: rgba(255,255,255,0.08);
        }
        .map-status-key {
            font-size: 9px;
            font-weight: 500;
            color: var(--text-sub);
            letter-spacing: 0.04em;
            text-transform: uppercase;
        }
        .map-status-value {
            margin-top: 3px;
            font-size: 11px;
            font-weight: 500;
            color: var(--text-heading);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: color 0.12s linear, opacity 0.12s linear;
        }
        .map-status-value.is-live { color: #40e7ab; }
        .map-status-value.is-manual { color: #f4b263; }

        #routeBusList {
            margin-top: 8px;
            display: flex;
            flex-wrap: nowrap;
            align-items: stretch;
            gap: 8px;
            max-height: min(29vh, 228px);
            overflow-x: auto;
            overflow-y: hidden;
            padding: 7px 7px 11px;
            scroll-padding-left: 7px;
            scroll-padding-right: 7px;
            border-radius: 24px;
            border: 1px solid rgba(182, 166, 248, 0.30);
            background: linear-gradient(160deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.13);
            -webkit-overflow-scrolling: touch;
            touch-action: pan-x;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .routes-panel {
            overflow-x: auto;
            overflow-y: hidden;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            scroll-behavior: auto;
            overscroll-behavior-x: contain;
            border-radius: 24px;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .routes-panel:focus {
            outline: 1px solid rgba(168, 154, 255, 0.46);
            outline-offset: 2px;
        }
        .route-scroll-controls {
            margin-top: 6px;
            display: flex;
            justify-content: flex-end;
            gap: 6px;
        }
        .route-scroll-btn {
            min-width: 30px;
            height: 28px;
            border-radius: 14px;
            border: 1px solid rgba(168, 154, 255, 0.34);
            background: rgba(34, 28, 56, 0.52);
            color: var(--text-heading);
            font-size: 13px;
            font-weight: 700;
            line-height: 1;
            cursor: pointer;
        }
        .route-scroll-btn:hover {
            border-color: rgba(178, 162, 246, 0.54);
            background: rgba(48, 40, 78, 0.64);
        }
        .route-scroll-btn:active {
            transform: translateY(1px);
        }
        #routeBusList.stack-flow {
            position: relative;
            display: flex;
            flex-direction: row;
            align-items: stretch;
            min-height: clamp(148px, 22vh, 196px);
            max-height: min(29vh, 228px);
            padding-top: 7px;
            padding-bottom: 11px;
            scroll-padding-left: 7px;
            scroll-padding-right: 7px;
            scroll-snap-type: x mandatory;
            overscroll-behavior-x: contain;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: none;
            -ms-overflow-style: none;
            scroll-behavior: auto;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-x;
        }
        #routeBusList.stack-flow::-webkit-scrollbar {
            width: 0;
            height: 0;
            display: none;
        }
        #routeBusList.stack-flow::-webkit-scrollbar-thumb {
            display: none;
        }
        #routeBusList.stack-flow .route-result-head {
            display: none;
        }
        #routesCard.route-expanded {
            display: flex;
            flex-direction: column;
            min-height: clamp(260px, 40vh, 500px);
        }
        #routesCard.route-expanded #routeBusList {
            flex: 1 1 auto;
            min-height: clamp(148px, 22vh, 196px);
            max-height: min(29vh, 228px);
        }
        #routesCard.route-expanded.route-stack-mode {
            min-height: 0;
        }
        #routesCard.route-expanded.route-stack-mode #routeBusList {
            flex: 1 1 auto;
            min-height: clamp(148px, 22vh, 196px);
            max-height: min(29vh, 228px);
        }
        #activeTransportCard.route-hidden {
            display: none !important;
        }
        .route-result-head {
            display:flex;
            align-items:center;
            justify-content:space-between;
            gap:10px;
            font-size:11px;
            color:var(--text-sub);
            margin:8px 0 6px;
            letter-spacing:0.02em;
        }
        .route-result-card {
            position: relative;
            flex: 0 0 calc(100% - 2px);
            min-width: calc(100% - 2px);
            max-width: calc(100% - 2px);
            border-radius: 12px;
            border: 1px solid var(--chip-border);
            background: var(--chip-gradient);
            box-shadow: var(--chip-shadow);
            padding: 7px 8px;
            margin-bottom: 0;
            cursor: pointer;
            transition: border-color 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
            max-height: none;
            overflow: visible;
            isolation: isolate;
            --route-selected-border: rgba(178, 162, 246, 0.44);
            --route-selected-glow: rgba(178, 162, 246, 0.18);
            --route-selected-tint-strong: rgba(178, 162, 246, 0.12);
            --route-selected-tint: rgba(178, 162, 246, 0.04);
        }
        .route-detail-card {
            background: rgba(35, 25, 60, 0.45);
            backdrop-filter: blur(14px);
            -webkit-backdrop-filter: blur(14px);
            border-radius: 20px;
            position: relative;
            z-index: 2;
            isolation: isolate;
            max-height: none;
        }
        .transport-card {
            position: relative;
            z-index: 1;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            background: rgba(34, 28, 56, 0.34);
            max-height: none;
            overflow: visible;
            padding: 10px 12px;
            border-radius: 18px;
            opacity: 1;
            transition: border-color 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
            animation: none;
        }
        .transport-card:hover {
            transform: none;
            opacity: 1;
        }
        .route-result-card.route-result-selected {
            border-color: var(--route-selected-border);
            background:
                linear-gradient(160deg, var(--route-selected-tint-strong), var(--route-selected-tint)),
                var(--chip-gradient);
            backdrop-filter: blur(6px) saturate(110%);
            -webkit-backdrop-filter: blur(6px) saturate(110%);
            box-shadow:
                0 0 0 1px var(--route-selected-glow),
                inset 0 1px 0 rgba(255,255,255,0.14),
                0 8px 18px rgba(5, 18, 34, 0.20),
                var(--chip-shadow);
            transform: none !important;
        }
        .route-result-card.route-result-selected .route-result-name {
            color: var(--text-heading);
            font-weight: 700;
        }
        .route-result-card.route-result-selected:hover {
            transform: none !important;
        }
        .route-result-card::-webkit-scrollbar { width: 0; height: 0; }
        .route-result-card::before,
        .route-result-card::after {
            content: none !important;
        }
        #routeBusList.stack-flow .route-result-card {
            position: relative;
            top: auto;
            z-index: 1;
            margin-top: 0;
            margin-bottom: 0;
            min-height: 0;
            max-height: none;
            scroll-snap-align: start;
            scroll-snap-stop: always;
            overflow: visible;
            pointer-events: auto;
            transition: border-color 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
        }
        #routeBusList.stack-flow .route-detail-card {
            max-height: none;
        }
        #routeBusList.stack-flow .transport-card {
            max-height: none;
            overflow: visible;
        }
        #routeBusList.stack-flow .route-detail-card.stack-front {
            z-index: 2;
        }
        #routeBusList.stack-flow .transport-card {
            z-index: 1;
        }
        #routeBusList.stack-flow .route-result-card.stack-front {
            transform: none;
            opacity: 1;
            filter: none;
            border-color: rgba(178, 162, 246, 0.54);
        }
        #routeBusList.stack-flow .route-result-card.stack-back-1 {
            transform: none;
            opacity: 1;
            filter: none;
        }
        #routeBusList.stack-flow .route-result-card.stack-back-2 {
            transform: none;
            opacity: 1;
            filter: none;
        }
        #routeBusList.stack-flow .route-result-card.stack-back-3 {
            transform: none;
            opacity: 1;
            filter: none;
        }
        #routeBusList.stack-flow .route-result-card.stack-hidden {
            transform: none;
            opacity: 1;
            filter: none;
        }
        #routeBusList.stack-flow.is-flowing .route-result-card {
            filter: none;
        }
        .route-result-card:hover {
            transform: none;
            border-color: rgba(168,154,255,0.44);
        }
        #routeBusList.stack-flow .route-result-card.stack-front:hover {
            transform: none;
            z-index: 2;
        }
        #routeBusList.stack-flow .route-result-card.route-result-selected {
            z-index: 21;
            filter: none !important;
        }
        #routesCard {
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }
        #routesCard::after {
            display: none !important;
        }
        .route-result-top {
            display:flex;
            align-items:flex-start;
            justify-content:space-between;
            gap:6px;
            margin-bottom:4px;
        }
        .route-result-left {
            display:flex;
            align-items:center;
            gap:8px;
            min-width:0;
        }
        .route-result-busdot {
            width:20px;
            height:20px;
            border-radius:50%;
            display:flex;
            align-items:center;
            justify-content:center;
            color:#fff;
            font-size:11px;
            font-weight:600;
            flex:0 0 auto;
        }
        .route-result-name {
            font-size:11px;
            font-weight:600;
            color:var(--text);
            white-space:nowrap;
            overflow:hidden;
            text-overflow:ellipsis;
        }
        .route-result-nextstop {
            font-size:9px;
            color:var(--text-sub);
            margin-top:0;
            white-space:nowrap;
            overflow:hidden;
            text-overflow:ellipsis;
        }
        .route-result-eta {
            color:#34d399;
            font-size:12px;
            font-weight:700;
            letter-spacing:0.01em;
            white-space:nowrap;
        }
        .route-badge-reco {
            display:inline-flex;
            align-items:center;
            gap:4px;
            font-size:8px;
            font-weight:700;
            letter-spacing:0.08em;
            text-transform:uppercase;
            border-radius:999px;
            padding:2px 6px;
            color:#073824;
            background:linear-gradient(160deg, rgba(114,242,184,0.92), rgba(52,211,153,0.84));
            border:1px solid rgba(52,211,153,0.64);
            margin-left:4px;
        }
        .route-stats-grid {
            display:grid;
            grid-template-columns:repeat(3, minmax(0, 1fr));
            gap:4px;
            margin-bottom:4px;
        }
        .route-stat {
            background: rgba(255,255,255,0.05);
            border:1px solid rgba(255,255,255,0.08);
            border-radius:8px;
            padding:4px 5px;
        }
        .route-stat-k {
            font-size:8px;
            text-transform:uppercase;
            letter-spacing:0.05em;
            color:var(--text-sub);
            margin-bottom:1px;
        }
        .route-stat-v {
            font-size:10px;
            color:var(--text-heading);
            font-weight:600;
        }
        .timeline {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            opacity: 0.85;
            margin-top: 4px;
            white-space: nowrap;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .timeline::-webkit-scrollbar { display: none; }
        .timeline span {
            padding: 4px 8px;
            border-radius: 12px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.10);
            line-height: 1;
        }
        .timeline .timeline-arrow {
            border: 0;
            background: transparent;
            padding: 0;
            opacity: 0.56;
            font-size: 10px;
        }
        .route-status-tags {
            display:flex;
            flex-wrap:wrap;
            gap:4px;
            margin-top:3px;
        }
        .status-pill {
            font-size:8px;
            font-weight:700;
            letter-spacing:0.05em;
            text-transform:uppercase;
            border-radius:999px;
            padding:2px 5px;
            border:1px solid rgba(255,255,255,0.12);
            background:rgba(255,255,255,0.04);
            color:var(--text-sub);
        }
        .status-pill.green { color:#34d399; border-color:rgba(52,211,153,0.36); background:rgba(52,211,153,0.10); }
        .status-pill.yellow { color:#fbbf24; border-color:rgba(251,191,36,0.36); background:rgba(251,191,36,0.10); }
        .status-pill.red { color:#fb7185; border-color:rgba(251,113,133,0.36); background:rgba(251,113,133,0.10); }
        #routeBusList::-webkit-scrollbar,
        .routes-panel::-webkit-scrollbar {
            width: 0;
            height: 0;
            display: none;
        }
        #routeBusList::-webkit-scrollbar-thumb,
        .routes-panel::-webkit-scrollbar-thumb {
            display: none;
        }
        #routeDetailsCard {
            overflow: visible;
            scroll-margin-bottom: 12px;
        }
        .walk-segment-progress {
            width: 100%;
            max-width: 220px;
            margin: 6px auto 2px;
            height: 4px;
            border-radius: 999px;
            background: rgba(143,210,255,0.16);
            overflow: hidden;
        }
        .walk-segment-progress span {
            display:block;
            height:100%;
            border-radius:inherit;
            background: linear-gradient(90deg, rgba(143,210,255,0.88), rgba(82,193,255,0.54));
            transition: width 0.25s ease;
        }
        .last-update {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(168, 154, 255, 0.18);
            color: var(--text-sub);
            font-size: 11px;
            font-weight: 400;
        }

        .theme-btn,
        #locateMeBtn,
        .map-theme-btn {
            font-family: inherit;
            font-weight: 500;
            border-radius: var(--apple-radius-sm);
            border: 1px solid var(--input-border);
            backdrop-filter: blur(4px) saturate(106%);
            -webkit-backdrop-filter: blur(4px) saturate(106%);
            transition: all 0.22s ease;
        }
        .theme-btn:hover,
        .map-theme-btn:hover {
            transform: translateY(-2px) scale(1.04);
            opacity: 1;
            box-shadow: 0 10px 18px rgba(7, 24, 42, 0.24);
        }
        #locateMeBtn {
            padding: 8px 10px !important;
            border-radius: var(--apple-radius-sm) !important;
            border: 1px solid rgba(171,145,255,0.50) !important;
            background: linear-gradient(160deg, rgba(141,107,255,0.38), rgba(110,84,238,0.20)) !important;
            color: #f2f8ff !important;
            box-shadow: 0 6px 14px rgba(53, 36, 102, 0.28) !important;
        }
        #locateMeBtn:hover { transform: translateY(-2px) scale(1.03); filter: brightness(1.1); }
        .map-theme-btn {
            padding: 8px 10px;
            background: linear-gradient(160deg, rgba(44, 34, 84, 0.86), rgba(24, 20, 52, 0.78));
            box-shadow: 0 4px 10px rgba(0,0,0,0.20);
            border-color: rgba(183, 157, 255, 0.30);
        }
        .map-btn-row {
            position: absolute;
            bottom: 12px;
            right: 12px;
            z-index: 600;
            display: flex;
            gap: 8px;
        }
        .map-btn-row .map-theme-btn {
            position: static;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        .map-follow-btn {
            font-size: 11px;
            padding: 8px 11px;
            max-width: 180px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .map-zoom16-btn {
            min-width: 40px;
            padding: 8px 10px;
            font-weight: 600;
            letter-spacing: 0.02em;
        }
        .assistant-panel {
            position: relative;
            z-index: 30;
            border-radius: 22px;
            border: 1px solid rgba(186, 160, 255, 0.42);
            background:
                linear-gradient(160deg, rgba(111, 78, 216, 0.24), rgba(34, 28, 64, 0.58)),
                linear-gradient(190deg, rgba(255,255,255,0.22), rgba(255,255,255,0.04));
            box-shadow:
                0 12px 28px rgba(26, 14, 58, 0.34),
                inset 0 1px 0 rgba(255,255,255,0.20),
                inset 0 0 0 1px rgba(214, 194, 255, 0.12);
            backdrop-filter: blur(14px) saturate(130%);
            -webkit-backdrop-filter: blur(14px) saturate(130%);
            padding: 7px 9px 8px;
            transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
            overflow: hidden;
        }
        .assistant-panel:hover {
            transform: translateY(-1px);
            border-color: rgba(202, 180, 255, 0.56);
            box-shadow:
                0 14px 30px rgba(24, 12, 54, 0.38),
                inset 0 1px 0 rgba(255,255,255,0.24),
                inset 0 0 0 1px rgba(220, 203, 255, 0.14);
        }
        .route-summary-head {
            display:flex;
            align-items:center;
            justify-content:space-between;
            gap:8px;
            margin-bottom:7px;
        }
        .route-summary-title {
            font-size: 12px;
            font-weight: 700;
            color: var(--text-heading);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            letter-spacing: 0.01em;
        }
        .route-summary-meta {
            font-size: 10px;
            color: var(--text-sub);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: right;
            flex: 1 1 auto;
        }
        .route-summary-list {
            display:flex;
            align-items:center;
            gap:6px;
            overflow-x:auto;
            scrollbar-width:none;
            -ms-overflow-style:none;
            min-height: 32px;
        }
        .route-summary-list::-webkit-scrollbar { display: none; }
        .route-summary-empty {
            font-size: 11px;
            color: var(--text-sub);
            opacity: 0.88;
            white-space: nowrap;
        }
        .route-summary-pill {
            border: 1px solid rgba(209, 186, 255, 0.38);
            background: linear-gradient(160deg, rgba(255,255,255,0.16), rgba(255,255,255,0.06));
            border-radius: 999px;
            color: var(--text-heading);
            padding: 5px 9px;
            font-size: 11px;
            font-weight: 600;
            white-space: nowrap;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            transition: transform 0.12s linear, border-color 0.12s linear, opacity 0.12s linear;
        }
        .route-summary-pill:hover {
            transform: translateY(-1px);
            border-color: rgba(226, 208, 255, 0.62);
        }
        .route-summary-pill.best {
            border-color: rgba(126, 238, 190, 0.58);
            color: #dcfff0;
            box-shadow: inset 0 0 0 1px rgba(126, 238, 190, 0.20);
        }
        body.light-mode .route-summary-pill.best {
            color: #13603f;
            border-color: rgba(62, 157, 114, 0.50);
        }
        .route-summary-pill .rs-sep {
            opacity: 0.42;
        }
        .route-summary-pill .rs-total {
            color: #8bf5c6;
            font-weight: 700;
        }
        body.light-mode .route-summary-pill .rs-total {
            color: #1b7d55;
        }
        .assistant-grid {
            display:grid;
            grid-template-columns: minmax(132px, 0.34fr) minmax(0, 1fr) minmax(108px, 0.24fr);
            gap: 7px;
            align-items: center;
        }
        .assistant-field label,
        .assistant-leave-wrap label {
            display:none;
        }
        .assistant-field input,
        .assistant-leave-wrap select,
        .assistant-leave-wrap input {
            width:100%;
            min-height: 34px;
            border-radius: 999px;
            border:1px solid rgba(196,170,255,0.34);
            background: linear-gradient(160deg, rgba(255,255,255,0.12), rgba(255,255,255,0.04));
            color: var(--text);
            padding: 6px 12px;
            font-size: 12px;
            font-family: inherit;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.14);
        }
        .assistant-field input::placeholder {
            color: color-mix(in srgb, var(--text-sub) 84%, #ffffff 16%);
        }
        .assistant-input-wrap {
            display:flex;
            align-items:center;
            gap:6px;
        }
        .assistant-input-wrap input {
            flex:1;
            min-width: 0;
        }
        .assistant-destination {
            position: relative;
        }
        .assistant-destination::before { content: none; }
        .assistant-destination input {
            padding-left: 12px;
            font-weight: 500;
            border-color: rgba(206, 181, 255, 0.44);
            background: linear-gradient(160deg, rgba(255,255,255,0.18), rgba(255,255,255,0.06));
        }
        .assistant-mini-btn {
            min-height:34px;
            padding: 0 10px;
            border-radius:999px;
            border:1px solid rgba(196,170,255,0.36);
            background: rgba(255,255,255,0.10);
            color: var(--text);
            cursor:pointer;
            font-size:11px;
            font-weight:600;
        }
        .assistant-chips {
            grid-column: 1 / -1;
            display:none;
            flex-wrap: nowrap;
            gap:8px;
            margin-top: 3px;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .assistant-chips::-webkit-scrollbar { display: none; }
        .assistant-chips button {
            border:1px solid rgba(196,170,255,0.32);
            background: linear-gradient(160deg, rgba(255,255,255,0.12), rgba(255,255,255,0.04));
            color: var(--text-heading);
            font-size:11px;
            border-radius:999px;
            padding:5px 10px;
            cursor:pointer;
            font-family: inherit;
            font-weight: 600;
        }
        .assistant-chips button:hover {
            border-color: rgba(218, 196, 255, 0.54);
            transform: translateY(-1px);
        }
        .assistant-leave-wrap {
            display:flex;
            align-items:center;
            gap:6px;
            min-width: 108px;
        }
        .assistant-leave-wrap select {
            min-width: 108px;
            appearance: none;
            -webkit-appearance: none;
            color-scheme: dark;
            background-image:
                linear-gradient(45deg, transparent 50%, #d8ccff 50%),
                linear-gradient(135deg, #d8ccff 50%, transparent 50%);
            background-position:
                calc(100% - 16px) calc(50% - 2px),
                calc(100% - 11px) calc(50% - 2px);
            background-size: 6px 6px, 6px 6px;
            background-repeat: no-repeat;
            padding-right: 26px;
        }
        .assistant-leave-wrap select option {
            background: #0f1728;
            color: #e6eef8;
        }
        .assistant-leave-wrap select option:disabled {
            color: #8f9ab2;
        }
        body.light-mode .assistant-leave-wrap select option {
            background: #ffffff;
            color: #1c2238;
        }
        body.light-mode .assistant-leave-wrap select {
            color-scheme: light;
        }
        body.light-mode .assistant-leave-wrap select option:disabled {
            color: #6b7280;
        }
        .assistant-leave-wrap input[type="time"] {
            min-width: 110px;
        }
        .assistant-status {
            margin-top: 3px;
            font-size: 11px;
            color: var(--text-sub);
            opacity: 0;
            transform: translateY(4px);
            transition: opacity 0.2s ease, transform 0.2s ease;
            min-height: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .assistant-status.active {
            opacity: 1;
            transform: translateY(0);
        }
        .assistant-panel.searching {
            border-color: rgba(135,227,255,0.55);
            box-shadow: 0 12px 30px rgba(56,125,181,0.18), 0 0 0 1px rgba(135,227,255,0.16) inset;
        }
        .assistant-panel.searching::after {
            content:'';
            position:absolute;
            inset:0;
            border-radius:inherit;
            pointer-events:none;
            background: linear-gradient(100deg, transparent 20%, rgba(255,255,255,0.24) 50%, transparent 80%);
            animation: assistant-shimmer 0.7s ease;
        }
        @keyframes assistant-shimmer {
            from { transform: translateX(-58%); opacity: 0.1; }
            30% { opacity: 0.9; }
            to { transform: translateX(58%); opacity: 0; }
        }
        .card,
        .map-layers-card,
        .ops-panel,
        .ops-tile,
        .route-result-card,
        .route-stat,
        .bus-item,
        .toggle-item,
        .info-item,
        .overlay-pill,
        .map-status-item,
        .route-chip,
        .theme-btn,
        .map-theme-btn,
        #locateMeBtn,
        .assistant-panel,
        .route-summary-pill {
            border-color: var(--liquid-edge);
            background-image: var(--liquid-fill-soft);
            box-shadow: var(--liquid-shadow-sm);
        }
        .card,
        .map-layers-card,
        .ops-panel,
        .assistant-panel {
            background-image: var(--liquid-fill);
        }
        .card,
        .map-layers-card,
        .assistant-panel {
            border-radius: var(--apple-radius-lg);
        }
        .ops-tile,
        .route-result-card,
        .route-stat,
        .bus-item,
        .map-status-item {
            border-radius: var(--apple-radius-md);
        }
        .route-chip,
        .theme-btn,
        .map-theme-btn,
        #locateMeBtn,
        .route-summary-pill,
        .toggle-item {
            border-radius: 999px;
        }
        #map {
            border-color: var(--liquid-edge);
            box-shadow: var(--liquid-shadow-lg), 0 0 0 1px rgba(255,255,255,0.10) inset;
        }
        .route-chip,
        .route-summary-pill,
        .theme-btn,
        .map-theme-btn,
        #locateMeBtn {
            backdrop-filter: blur(calc(var(--glass-blur) + 1px)) saturate(calc(var(--glass-sat) + 6%));
            -webkit-backdrop-filter: blur(calc(var(--glass-blur) + 1px)) saturate(calc(var(--glass-sat) + 6%));
        }
        .route-chip:hover,
        .route-summary-pill:hover,
        .theme-btn:hover,
        .map-theme-btn:hover,
        #locateMeBtn:hover,
        .toggle-item:hover {
            border-color: color-mix(in srgb, var(--liquid-edge) 70%, #ffffff 30%);
        }
        .info-item,
        .overlay-pill {
            background-color: color-mix(in srgb, var(--card-bg) 84%, #ffffff 16%);
        }

        .leaflet-control-zoom a {
            background: rgba(11, 19, 30, 0.86) !important;
            color: #e1def8 !important;
            border-color: rgba(168, 154, 255, 0.24) !important;
        }
        .leaflet-popup-content-wrapper,
        .leaflet-popup-tip {
            background: rgba(8, 14, 24, 0.94);
            color: var(--text);
            border: 1px solid rgba(168, 154, 255, 0.24);
        }
        #walkDistance { color: var(--accent-blue) !important; }
        #routeBusList > div:hover {
            transform: none !important;
            border-color: rgba(168, 154, 255, 0.34) !important;
        }
        html.low-perf body::before,
        html.low-perf body::after {
            display: none !important;
        }
        html.low-perf #map,
        html.low-perf .map-stage,
        html.low-perf .map-fx,
        html.low-perf .live-badge,
        html.low-perf .card,
        html.low-perf .stat-box,
        html.low-perf .info-item,
        html.low-perf .overlay-pill,
        html.low-perf .toggle-item,
        html.low-perf .theme-btn,
        html.low-perf #locateMeBtn,
        html.low-perf .map-theme-btn,
        html.low-perf .route-chip,
        html.low-perf .bus-item,
        html.low-perf .map-status-item,
        html.low-perf #routeBusList > div {
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            background-image: none !important;
            box-shadow: none !important;
            will-change: auto !important;
            transition: background-color 0.12s linear, border-color 0.12s linear, color 0.12s linear, opacity 0.12s linear !important;
        }
        html.low-perf .card::after {
            display: none !important;
        }
        html.low-perf #map:hover,
        html.low-perf .map-stage:hover #map,
        html.low-perf .map-stage:hover .map-fx,
        html.low-perf .card:hover,
        html.low-perf .route-chip:hover,
        html.low-perf .bus-item:hover,
        html.low-perf .toggle-item:hover,
        html.low-perf .theme-btn:hover,
        html.low-perf #locateMeBtn:hover,
        html.low-perf .map-theme-btn:hover,
        html.low-perf #routeBusList > div:hover {
            transform: none !important;
            filter: none !important;
            box-shadow: none !important;
        }
        html.low-perf .pulse,
        html.low-perf .eta-spinner,
        html.low-perf .bus-icon,
        html.low-perf .live-dot,
        html.low-perf .live-track-dot,
        html.low-perf .ai-spark,
        html.low-perf .eta-rotor,
        html.low-perf .ui-flash {
            animation: none !important;
        }
        html.low-perf .ai-galaxy-icon::before {
            animation: none !important;
        }
        html.low-perf .map-fx {
            display: none !important;
        }
        html.low-perf .route-glow-line {
            opacity: 0 !important;
        }
        html.low-perf .live-badge {
            animation: none !important;
            opacity: 1 !important;
        }
        html.low-perf .bus-marker-pulse,
        html.low-perf .bus-marker-shadow,
        html.low-perf .bus-marker-selected {
            display: none !important;
        }
        html.low-perf .map-stage.layer-switching #map,
        html.low-perf .map-stage.layer-switching .map-fx,
        html.low-perf .map-layers-card.layer-switching,
        html.low-perf .map-layers-card.layer-switching .map-status-grid {
            opacity: 1 !important;
            transform: none !important;
        }
        html.low-perf body:not(.light-mode) #map {
            background: #0d1020 !important;
            border-color: rgba(178, 152, 255, 0.34) !important;
        }
        html.low-perf body:not(.light-mode) .card,
        html.low-perf body:not(.light-mode) .stat-box,
        html.low-perf body:not(.light-mode) .info-item,
        html.low-perf body:not(.light-mode) .overlay-pill,
        html.low-perf body:not(.light-mode) .toggle-item,
        html.low-perf body:not(.light-mode) .theme-btn,
        html.low-perf body:not(.light-mode) .map-theme-btn,
        html.low-perf body:not(.light-mode) .route-chip,
        html.low-perf body:not(.light-mode) .bus-item,
        html.low-perf body:not(.light-mode) .map-status-item,
        html.low-perf body:not(.light-mode) #routeBusList > div {
            background: #14172a !important;
            border-color: rgba(178, 152, 255, 0.34) !important;
        }
        html.low-perf body:not(.light-mode) #locateMeBtn {
            background: #4d3ea8 !important;
            border-color: rgba(178, 152, 255, 0.52) !important;
        }
        html.low-perf body:not(.light-mode) .info-eta {
            background: #312567 !important;
            border-color: rgba(178, 152, 255, 0.56) !important;
            color: #efe7ff !important;
        }
        html.low-perf body.light-mode #map {
            background: #e6e8f6 !important;
            border-color: rgba(141, 121, 192, 0.34) !important;
        }
        html.low-perf body.light-mode .card,
        html.low-perf body.light-mode .stat-box,
        html.low-perf body.light-mode .info-item,
        html.low-perf body.light-mode .overlay-pill,
        html.low-perf body.light-mode .toggle-item,
        html.low-perf body.light-mode .theme-btn,
        html.low-perf body.light-mode .map-theme-btn,
        html.low-perf body.light-mode .route-chip,
        html.low-perf body.light-mode .bus-item,
        html.low-perf body.light-mode .map-status-item,
        html.low-perf body.light-mode #routeBusList > div {
            background: #ffffff !important;
            border-color: rgba(141, 121, 192, 0.34) !important;
            color: var(--text) !important;
        }
        html.low-perf body.light-mode #locateMeBtn {
            background: #7f6de3 !important;
            border-color: rgba(141, 121, 192, 0.52) !important;
            color: #fff !important;
        }
        html.low-perf body.light-mode .info-eta {
            background: #ece8ff !important;
            border-color: rgba(141, 121, 192, 0.46) !important;
            color: #3f2f79 !important;
        }
        @media (prefers-reduced-motion: reduce) {
            #map,
            .card,
            .route-chip,
            .bus-item,
            .toggle-item,
            .theme-btn,
            #locateMeBtn,
            .map-theme-btn,
            #routeBusList > div,
            .map-status-item {
                transition: none !important;
                animation: none !important;
            }
        }

        @media (max-width: 1200px) {
            .main-container { grid-template-columns: minmax(0, 1.28fr) minmax(290px, 330px); gap: var(--space-2); }
            .map-container { max-width: none; }
            #map { min-height: 280px; }
            .map-status-grid { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        }
        @media (max-width: 1500px) and (min-width: 1025px) {
            .header {
                grid-template-columns: minmax(300px, 0.95fr) minmax(0, 1.7fr) auto;
                gap: 8px;
                padding-left: 0;
                padding-right: 0;
            }
            .header .brand-text h1 {
                font-size: 22px;
                white-space: nowrap;
                overflow: visible;
                text-overflow: clip;
            }
            .header .brand-text p {
                font-size: 12px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            .header-assistant-slot {
                width: 100%;
                justify-self: stretch;
            }
            .assistant-panel {
                padding: 6px 8px 7px;
            }
            .assistant-grid {
                grid-template-columns: minmax(120px, 0.32fr) minmax(0, 1fr) minmax(104px, 0.24fr);
                gap: 6px;
            }
            .assistant-field input,
            .assistant-leave-wrap select,
            .assistant-leave-wrap input {
                min-height: 33px;
                padding: 6px 10px;
                font-size: 12px;
            }
            .assistant-mini-btn {
                min-height: 33px;
                padding: 0 9px;
                font-size: 11px;
            }
            .assistant-leave-wrap select {
                min-width: 104px;
                padding-right: 24px;
            }
            .header-actions {
                gap: 5px;
            }
            .theme-btn {
                padding: 8px 9px;
                font-size: 13px;
            }
            .admin-link {
                padding: 8px 8px;
                font-size: 11px;
            }
            #locateMeBtn {
                padding: 9px 11px !important;
                font-size: 13px !important;
                white-space: nowrap;
            }
        }
        @media (max-width: 1320px) and (min-width: 1025px) {
            .header {
                grid-template-columns: minmax(260px, 0.9fr) minmax(0, 1.8fr) auto;
                gap: 7px;
            }
            .header-assistant-slot {
                width: 100%;
                justify-self: stretch;
            }
            .assistant-grid {
                grid-template-columns: minmax(108px, 0.28fr) minmax(0, 1fr) minmax(94px, 0.22fr);
                gap: 5px;
            }
            .header-actions {
                gap: 5px;
            }
            .theme-btn {
                font-size: 12px;
                padding: 7px 8px;
            }
            #locateMeBtn {
                padding: 8px 10px !important;
                font-size: 12px !important;
            }
        }
        @media (max-width: 1400px) and (min-width: 1201px) {
            .main-container { grid-template-columns: minmax(0, 1.42fr) minmax(320px, 390px); gap: var(--space-2); }
            .map-container { max-width: none; }
            #map { min-height: 300px; }
            .map-status-grid { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        }
        @media (max-height: 940px) and (min-width: 1025px) {
            .header { padding-top: var(--space-2); padding-bottom: var(--space-1); }
            .main-container { gap: var(--space-2); }
            .card { padding: 14px; }
            .stat-number { font-size: 24px; }
            .map-container { gap: 8px; }
            .map-stage { min-height: 0; max-height: none; }
            .map-layers-card { padding: 10px 12px; }
            .map-layers-card h3 { margin-bottom: 7px; font-size: 14px; }
            .layer-control { gap: 5px; margin-bottom: 6px; }
            .toggle-item { padding: 6px 7px; }
            .map-status-grid { grid-template-columns: repeat(3, minmax(0, 1fr)); }
            .map-status-grid { gap: 5px; padding-top: 5px; }
            .map-status-item { min-height: 36px; padding: 5px 7px; }
            .map-status-key { font-size: 8px; }
            .map-status-value { font-size: 10px; margin-top: 2px; }
            .sidebar { gap: 10px; }
            .live-stats-card,
            .sidebar > .card:first-child { padding: 9px 10px; }
            .live-mini-tile { min-height: 32px; padding: 6px 9px; }
            .live-mini-value { font-size: 16px; }
            .sidebar > .card:first-child .stats-grid { min-height: 32px; padding: 4px 8px; }
            .sidebar > .card:first-child .stat-number { font-size: 16px; }
            .sidebar > .card:first-child .stat-label { font-size: 9px; }
            #routeBusList { max-height: min(25vh, 200px); }
            .active-buses { max-height: min(18vh, 132px); }
            .ops-master-card { padding: 12px; }
        }
        @media (max-height: 860px) and (min-width: 1025px) {
            .header { padding-top: 8px; padding-bottom: 6px; }
            .main-container { height: auto; }
            .map-container { gap: 6px; }
            .card { padding: 12px; }
            .sidebar { gap: 8px; }
            .map-stage { min-height: 0; max-height: none; }
            .map-layers-card { padding: 9px 10px; }
            .map-layers-card h3 { margin-bottom: 6px; font-size: 13px; }
            .toggle-item {
                padding: 5px 6px;
                gap: 5px;
            }
            .layer-pill-icon {
                width: 15px;
                height: 15px;
                font-size: 8px;
            }
            .toggle-label { font-size: 10px; }
            .layer-state { font-size: 7px; }
            .map-status-grid { gap: 4px; padding-top: 4px; }
            .map-status-item {
                min-height: 32px;
                padding: 4px 6px;
            }
            .map-status-key { font-size: 7px; }
            .map-status-value {
                font-size: 9px;
                margin-top: 1px;
            }
            #routeBusList,
            #routeBusList.stack-flow,
            #routesCard.route-expanded #routeBusList,
            #routesCard.route-expanded.route-stack-mode #routeBusList {
                min-height: clamp(138px, 20vh, 172px);
                max-height: clamp(148px, 22vh, 188px);
            }
            .active-buses { max-height: min(14vh, 110px); }
        }
        @media (max-width: 1024px) {
            html { height: auto; overflow: auto; }
            body { height: auto; overflow: auto; display: block; }
            .header {
                padding: var(--space-2);
                grid-template-columns: 1fr;
                align-items: stretch;
            }
            .header-brand { order: 1; }
            .header-assistant-slot { order: 2; }
            .header-actions { order: 3; justify-content: flex-start; flex-wrap: wrap; }
            .header-quick-stack {
                flex-direction: row;
                align-items: center;
                gap: 6px;
            }
            .main-container {
                grid-template-columns: 1fr;
                padding: 0 var(--space-2) var(--space-2);
                height: auto;
                overflow: visible;
            }
            .map-container { order: 1; display:flex; max-width:none; }
            .map-stage { height: auto; }
            .sidebar { order: 2; max-height: none; overflow: visible; }
            #map {
                width: 100%;
                aspect-ratio: auto;
                height: clamp(300px, 54vh, 560px);
                min-height: 320px;
                max-height: none;
                border-radius: var(--apple-radius-lg);
            }
            .map-status-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
        }
        @media (max-width: 768px) {
            .header .brand-text h1 { font-size: 20px; }
            .header-actions { width: 100%; justify-content: flex-start; }
            .route-summary-head {
                flex-direction: column;
                align-items: flex-start;
                gap: 2px;
            }
            .route-summary-meta {
                text-align: left;
            }
            .info-strip { top: 12px; left: 12px; right: 12px; padding-right: 0; }
            .live-badge { top: auto; right: 12px; bottom: 12px; }
            .info-item { padding: 9px 11px; font-size: 12px; }
            .layer-control { grid-template-columns: 1fr; }
            .map-status-grid { grid-template-columns: 1fr; }
            .stats-grid { grid-template-columns: 1fr 1fr; }
            .ops-grid { grid-template-columns: 1fr 1fr; }
            .assistant-grid { grid-template-columns: 1fr; }
            .assistant-chips { grid-column: 1 / -1; flex-wrap: wrap; overflow: visible; }
            .assistant-leave-wrap { grid-column: 1 / -1; min-width: 0; }
            .map-follow-btn { max-width: 140px; font-size: 10px; }
            .route-stats-grid { grid-template-columns: 1fr; }
            #routesCard.route-expanded { min-height: 0; }
            #routesCard.route-expanded #routeBusList {
                min-height: min(28vh, 190px);
                max-height: min(32vh, 240px);
            }
            #routeBusList.stack-flow,
            #routesCard.route-expanded.route-stack-mode #routeBusList {
                min-height: min(28vh, 190px);
                max-height: min(32vh, 240px);
            }
        }
        @media (max-width: 560px) {
            .main-container, .header { padding-left: 12px; padding-right: 12px; }
            #map { min-height: 280px; border-radius: var(--apple-radius-md); }
            .stats-grid { grid-template-columns: 1fr; }
            .ops-grid { grid-template-columns: 1fr; }
            #opsAvailabilityTile,
            #opsRouteHealthTile,
            #opsSystemTile {
                grid-column: auto;
                grid-row: auto;
            }
            #opsSystemTile .ops-value {
                font-size: 12px;
                letter-spacing: 0.01em;
                text-transform: none;
            }
        }
        @media (min-width: 1025px) and (max-width: 1280px) {
            .main-container {
                grid-template-columns: minmax(0, 1.24fr) minmax(280px, 350px);
            }
            .header {
                grid-template-columns: minmax(250px, 0.86fr) minmax(0, 1.9fr) auto;
            }
        }
        /* Header action stack: compact 4-button column that matches assistant bar height */
        .header-actions {
            justify-self: start;
            justify-content: flex-start;
            align-items: stretch;
            align-self: stretch;
            margin-right: clamp(8px, 0.9vw, 14px);
        }
        .header-actions .header-quick-stack {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 4px;
            min-width: clamp(52px, 3.9vw, 61px);
            width: clamp(52px, 3.9vw, 61px);
        }
        .header-actions .header-quick-stack .header-quick-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            min-height: 18px;
            height: 18px;
            padding: 0 8px !important;
            font-size: 11px;
            font-weight: 600;
            line-height: 1;
            letter-spacing: 0.01em;
            color: var(--text-heading) !important;
            text-decoration: none;
            cursor: pointer;
            border-radius: 8px;
            border: 1px solid rgba(194, 168, 255, 0.46) !important;
            background: linear-gradient(180deg, rgba(255,255,255,0.20), rgba(255,255,255,0.06) 62%) !important;
            box-shadow: 0 3px 8px rgba(10, 12, 28, 0.30), inset 0 1px 0 rgba(255,255,255,0.18);
            backdrop-filter: blur(10px) saturate(118%);
            -webkit-backdrop-filter: blur(10px) saturate(118%);
            opacity: 0.96;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .header-actions .header-quick-stack #locateMeBtn.header-quick-btn {
            border-radius: 8px !important;
            border: 1px solid rgba(194, 168, 255, 0.46) !important;
            background: linear-gradient(180deg, rgba(255,255,255,0.20), rgba(255,255,255,0.06) 62%) !important;
            color: var(--text-heading) !important;
            box-shadow: 0 3px 8px rgba(10, 12, 28, 0.30), inset 0 1px 0 rgba(255,255,255,0.18) !important;
        }
        .header-actions .header-quick-stack .header-quick-btn:hover {
            transform: translateY(-1px);
            border-color: rgba(198, 180, 255, 0.56) !important;
            box-shadow: var(--liquid-shadow-lg);
            filter: brightness(1.03);
        }
        .header-actions .header-quick-stack #locateMeBtn.header-quick-btn:hover {
            transform: translateY(-1px) !important;
            filter: brightness(1.03) !important;
        }
        .header-actions .header-quick-stack .perf-btn.header-quick-btn.active {
            background: linear-gradient(165deg, rgba(185, 156, 255, 0.36), rgba(138, 107, 255, 0.18) 62%) !important;
            border-color: rgba(206, 184, 255, 0.62) !important;
            color: var(--text-heading) !important;
            opacity: 1;
        }
        @media (min-width: 1025px) {
            .header {
                padding-top: clamp(6px, 0.8vh, 10px);
                padding-bottom: clamp(3px, 0.6vh, 7px);
            }
        }
        @media (max-width: 1024px) {
            .header-actions {
                align-self: auto;
                margin-right: 0;
            }
            .header-actions .header-quick-stack {
                display: flex;
                flex-direction: row;
                align-items: center;
                gap: 6px;
                min-width: 0;
                width: auto;
                height: auto;
            }
            .header-actions .header-quick-stack .header-quick-btn {
                width: auto;
                min-height: 32px;
                height: auto;
                padding: 0 10px !important;
                font-size: 12px;
                border-radius: 12px;
            }
        }
        /* Premium glass polish (UI-only, no logic changes) */
        :root {
            --ui-radius-search: 26px;
            --ui-radius-map: 24px;
            --ui-radius-card: 22px;
            --ui-radius-btn: 12px;
            --ui-radius-chip: 14px;
        }
        body.app-shell {
            padding: 20px 24px;
            position: relative;
            top: -5px;
        }
        body.app-shell .header,
        body.app-shell .main-container {
            max-width: none;
        }
        body.app-shell .main-container {
            padding-bottom: 0;
        }
        .assistant-panel {
            border-radius: var(--ui-radius-search) !important;
        }
        .map-stage,
        #map,
        .map-fx {
            border-radius: var(--ui-radius-map) !important;
        }
        .sidebar .card,
        .sidebar .map-layers-card,
        .sidebar .ops-master-card {
            border-radius: var(--ui-radius-card) !important;
        }
        button,
        .theme-btn,
        .map-theme-btn,
        #locateMeBtn,
        .assistant-mini-btn,
        .header-quick-btn {
            border-radius: var(--ui-radius-btn) !important;
        }
        .route-chip,
        .status-pill,
        .route-summary-pill,
        .toggle-item,
        .overlay-pill,
        .info-item,
        .live-track-pill {
            border-radius: var(--ui-radius-chip) !important;
        }
        html:not(.low-perf) .panel-card,
        html:not(.low-perf) .sidebar,
        html:not(.low-perf) .search-panel,
        html:not(.low-perf) .sidebar .card,
        html:not(.low-perf) .assistant-panel {
            background: rgba(35, 28, 60, 0.42);
            border: 1px solid rgba(255,255,255,0.08);
            backdrop-filter: blur(10px) saturate(118%);
            -webkit-backdrop-filter: blur(10px) saturate(118%);
        }
        html:not(.low-perf) body.light-mode .sidebar,
        html:not(.low-perf) body.light-mode .sidebar .card,
        html:not(.low-perf) body.light-mode .assistant-panel {
            background: rgba(246, 241, 255, 0.74);
            border-color: rgba(125, 98, 186, 0.20);
        }
        .map-container {
            position: relative;
        }
        .map-container::after {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: var(--ui-radius-map);
            box-shadow: inset 0 0 40px rgba(0,0,0,0.35);
            pointer-events: none;
            z-index: 4;
        }
        .sidebar .card,
        .assistant-panel,
        .map-layers-card {
            box-shadow:
                0 6px 18px rgba(0,0,0,0.35),
                inset 0 1px rgba(255,255,255,0.06) !important;
        }
        html:not(.low-perf) .sidebar .card,
        html:not(.low-perf) .assistant-panel,
        html:not(.low-perf) .map-layers-card,
        html:not(.low-perf) button {
            transition: transform .2s ease, box-shadow .2s ease !important;
        }
        html:not(.low-perf) .sidebar .card:hover,
        html:not(.low-perf) .assistant-panel:hover,
        html:not(.low-perf) .map-layers-card:hover {
            transform: translateY(-2px) !important;
        }
        html:not(.low-perf) button:active {
            transform: scale(.97);
        }
        html:not(.low-perf) .sidebar {
            background: rgba(40, 30, 70, 0.36);
            border-radius: var(--ui-radius-card);
            border: 1px solid rgba(198, 174, 255, 0.20);
            box-shadow:
                0 12px 26px rgba(6, 10, 24, 0.34),
                inset 0 1px 0 rgba(255,255,255,0.07);
        }
        #routeBusList,
        .routes-panel {
            border-radius: var(--ui-radius-card) !important;
            box-shadow:
                0 8px 18px rgba(7, 12, 28, 0.30),
                inset 0 1px 0 rgba(255,255,255,0.10) !important;
        }
        html:not(.low-perf) .map-chip,
        html:not(.low-perf) .info-strip .info-item,
        html:not(.low-perf) .map-overlay .overlay-pill {
            opacity: 0;
            transform: translateY(6px);
            animation: fadeUp .25s ease forwards;
        }
        @keyframes fadeUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        /* Map Layers panel control upgrade (UI-only) */
        .map-layers-panel .row {
            gap: 10px;
        }
        .map-layers-panel .layer-control.row {
            margin-bottom: 10px;
        }
        .map-layers-panel .layer-toggle {
            padding: 8px 14px;
            border-radius: 16px;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.10);
            cursor: pointer;
            transition: all .18s ease;
        }
        .map-layers-panel .layer-toggle:hover {
            background: rgba(255,255,255,0.14);
            transform: translateY(-1px);
        }
        .map-layers-panel .layer-toggle.is-active,
        .map-layers-panel .layer-toggle.active {
            background: rgba(120, 90, 255, 0.35);
            border-color: rgba(160, 130, 255, 0.6);
        }
        .map-layers-panel .map-info-chip {
            padding: 8px 16px;
            border-radius: 18px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.08);
            font-size: 13px;
            min-height: 0;
            transition: transform .18s ease, background .18s ease, border-color .18s ease, box-shadow .18s ease;
        }
        .map-layers-panel .map-info-chip:hover {
            background: rgba(255,255,255,0.10);
            border-color: rgba(255,255,255,0.14);
        }
        .map-layers-panel .map-info-chip .map-status-key {
            font-size: 10px;
        }
        .map-layers-panel .map-info-chip .map-status-value {
            font-size: 13px;
            margin-top: 2px;
        }
        .map-layers-panel .layer-toggle:active,
        .map-layers-panel .map-info-chip:active {
            transform: scale(0.96);
        }
        /* Search panel + AI assistant UX upgrade (UI-only) */
        .search-panel {
            background: linear-gradient(160deg, rgba(58, 40, 104, 0.52), rgba(28, 22, 56, 0.44)) !important;
            border: 1px solid rgba(255,255,255,0.09) !important;
            box-shadow: 0 8px 18px rgba(0,0,0,0.26) !important;
            border-radius: 28px !important;
            padding: 12px 16px !important;
            backdrop-filter: blur(7px) saturate(112%) !important;
            -webkit-backdrop-filter: blur(7px) saturate(112%) !important;
            overflow: visible !important;
            position: relative;
            z-index: 1220;
        }
        .search-panel .assistant-grid {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: nowrap;
        }
        .assistant-origin {
            flex: 0 0 160px;
            min-width: 145px;
        }
        .assistant-origin .origin-chip {
            position: relative;
            padding: 2px 6px;
            border-radius: 999px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.09);
        }
        .assistant-origin .origin-chip::before {
            content: "\1F4CD";
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
            line-height: 1;
            pointer-events: none;
            opacity: 0.92;
        }
        .assistant-origin .origin-chip input {
            padding-left: 26px;
            background: rgba(255,255,255,0.08);
            border-color: rgba(255,255,255,0.18);
            border-radius: 999px;
        }
        .assistant-destination {
            position: relative;
            flex: 1 1 auto;
            min-width: 280px;
            max-width: 560px;
        }
        .destination-input {
            flex: 1;
            width: 100%;
            max-width: 560px;
            background: rgba(255,255,255,0.14) !important;
            border: 1px solid rgba(194, 168, 255, 0.42) !important;
            border-radius: 16px !important;
            padding: 10px 15px !important;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.20), 0 3px 8px rgba(10, 14, 34, 0.14);
        }
        .destination-input::placeholder {
            color: rgba(255,255,255,0.6);
        }
        .destination-input:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(168,138,255,0.38), 0 4px 10px rgba(12, 16, 36, 0.20);
            background: rgba(255,255,255,0.18) !important;
        }
        .search-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 6px;
            background: rgba(40,30,70,0.95);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.08);
            padding: 8px;
            z-index: 1600;
            box-shadow: 0 10px 24px rgba(8, 12, 30, 0.40);
        }
        .suggestion-item {
            padding: 8px 10px;
            border-radius: 10px;
            cursor: pointer;
            transition: background .15s ease;
            color: var(--text-heading);
            font-size: 12px;
            font-weight: 500;
        }
        .suggestion-item:hover {
            background: rgba(255,255,255,0.08);
        }
        .ai-search-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 16px;
            border-radius: 18px;
            background: linear-gradient(160deg, rgba(129, 96, 255, 0.32), rgba(85, 69, 170, 0.20));
            border: 1px solid rgba(202, 182, 255, 0.42);
            color: var(--text-heading);
            cursor: pointer;
            transition: transform .2s ease, opacity .2s ease, border-color .2s ease, box-shadow .2s ease;
            min-height: 36px;
            font-size: 12px;
            font-weight: 600;
            font-family: inherit;
            white-space: nowrap;
            flex: 0 0 auto;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.22), 0 4px 10px rgba(24, 14, 56, 0.24);
            will-change: transform, opacity;
        }
        .ai-search-button:hover {
            border-color: rgba(220, 206, 255, 0.56);
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.26), 0 6px 12px rgba(24, 14, 56, 0.28);
        }
        .ai-search-button::before {
            content: "\2726";
            filter: drop-shadow(0 0 4px rgba(186, 149, 255, 0.32));
        }
        .ai-search-button::after {
            content: "";
            position: absolute;
            inset: -2px;
            border-radius: inherit;
            border: 1px solid rgba(209, 186, 255, 0.24);
            opacity: 0;
            transform: scale(0.98);
            animation: aiIdlePulse 3.8s ease-in-out infinite;
            pointer-events: none;
        }
        @keyframes aiIdlePulse {
            0%, 100% { opacity: 0.10; transform: scale(0.985); }
            45% { opacity: 0.24; transform: scale(1.03); }
        }
        .ai-active {
            animation: aiPulse 1.2s ease;
        }
        @keyframes aiPulse {
            0% { box-shadow: 0 0 0 rgba(120,100,255,0); }
            50% { box-shadow: 0 0 20px rgba(120,100,255,0.45); }
            100% { box-shadow: 0 0 0 rgba(120,100,255,0); }
        }
        .route-result-card.recommended,
        .transport-card.recommended {
            box-shadow: inset 0 0 0 1px rgba(114, 244, 210, 0.28);
        }
        .route-result-card {
            will-change: transform, opacity;
        }
        .route-result-card.route-card-enter {
            opacity: 0;
            transform: translateY(8px) scale(0.99);
            animation: routeCardFadeIn 0.26s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
        }
        @keyframes routeCardFadeIn {
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        .route-result-card.recommend-pop-once {
            animation: recommendPopOnce 0.72s ease;
        }
        @keyframes recommendPopOnce {
            0% { transform: scale(1); opacity: 0.96; }
            55% { transform: scale(1.017); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        .routes-empty-state {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 14px 14px;
            border-radius: 16px;
            border: 1px dashed rgba(190, 166, 255, 0.48);
            background: linear-gradient(160deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
            color: var(--text-sub);
            font-size: 12px;
            line-height: 1.4;
            min-height: 56px;
        }
        .routes-empty-state .empty-icon {
            flex: 0 0 auto;
            width: 24px;
            height: 24px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 999px;
            border: 1px solid rgba(190, 166, 255, 0.30);
            background: rgba(255,255,255,0.04);
            opacity: 0.7;
            font-size: 12px;
        }
        .route-result-card.ai-recommended-active,
        .transport-card.ai-recommended-active {
            animation: recommendGlow 1s ease;
            box-shadow:
                0 0 0 1px rgba(98, 255, 221, 0.40),
                0 0 26px rgba(82, 230, 210, 0.34),
                inset 0 0 0 1px rgba(132, 255, 227, 0.36);
        }
        @keyframes recommendGlow {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        .top-right-button {
            opacity: 0.58;
            background: rgba(255,255,255,0.04) !important;
            border-color: rgba(255,255,255,0.11) !important;
            box-shadow: 0 2px 5px rgba(6, 10, 24, 0.12), inset 0 1px 0 rgba(255,255,255,0.08) !important;
        }
        .top-right-button:hover {
            opacity: 0.86;
        }
        .sidebar {
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            box-shadow: 0 8px 16px rgba(6, 10, 24, 0.22), inset 0 1px 0 rgba(255,255,255,0.06);
        }
        .sidebar .card {
            backdrop-filter: blur(4px) saturate(108%) !important;
            -webkit-backdrop-filter: blur(4px) saturate(108%) !important;
            box-shadow: 0 4px 10px rgba(8, 12, 28, 0.20), inset 0 1px 0 rgba(255,255,255,0.07) !important;
        }
        #routeBusList,
        .routes-panel,
        .active-buses {
            transform: translateZ(0);
            contain: layout paint style;
        }
        #mapThemeBtn.map-theme-btn {
            position: absolute;
            right: 18px;
            bottom: 18px;
            z-index: 760;
            min-width: 104px;
            text-align: center;
        }
        #zoom16Btn.map-zoom16-btn {
            position: absolute;
            right: 132px;
            bottom: 18px;
            z-index: 760;
        }
        #followNearestBtn.map-follow-btn {
            position: absolute;
            left: 18px;
            bottom: 18px;
            right: auto;
            z-index: 760;
        }
        .map-overlay .overlay-pill,
        .info-strip .info-item {
            box-shadow: 0 3px 8px rgba(6, 10, 22, 0.18);
            backdrop-filter: blur(3px) saturate(106%);
            -webkit-backdrop-filter: blur(3px) saturate(106%);
            will-change: transform, opacity;
        }
        .assistant-leave-wrap {
            position: relative;
            min-width: 0;
            flex: 0 0 auto;
            display: flex;
            align-items: center;
            gap: 0;
        }
        .assistant-leave-wrap .leave-now-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            min-height: 34px;
            padding: 0 12px;
            border-radius: 16px;
            border: 1px solid rgba(196,170,255,0.34);
            background: rgba(255,255,255,0.08);
            color: var(--text-heading);
            font-size: 12px;
            font-weight: 600;
            font-family: inherit;
            cursor: pointer;
            white-space: nowrap;
            transition: background .18s ease, border-color .18s ease, transform .18s ease;
        }
        .assistant-leave-wrap .leave-now-btn:hover {
            background: rgba(255,255,255,0.14);
            border-color: rgba(214,190,255,0.50);
            transform: translateY(-1px);
        }
        .assistant-leave-wrap .leave-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 6px;
            width: 168px;
            background: rgba(40,30,70,0.95);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 14px;
            padding: 8px;
            box-shadow: 0 10px 24px rgba(8, 12, 30, 0.40);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            z-index: 1610;
        }
        .assistant-leave-wrap .leave-option {
            width: 100%;
            border: 0;
            border-radius: 10px;
            padding: 8px 10px;
            background: transparent;
            color: var(--text-heading);
            font-size: 12px;
            font-weight: 500;
            text-align: left;
            cursor: pointer;
            transition: background .15s ease;
            font-family: inherit;
        }
        .assistant-leave-wrap .leave-option:hover {
            background: rgba(255,255,255,0.08);
        }
        .assistant-leave-wrap .leave-option.active {
            background: rgba(125, 105, 255, 0.22);
            border: 1px solid rgba(172, 145, 255, 0.52);
        }
        .assistant-leave-wrap input[type="time"] {
            width: 100%;
            margin-top: 6px;
            min-height: 32px;
            padding: 4px 8px;
            border-radius: 10px;
            border: 1px solid rgba(196,170,255,0.34);
            background: rgba(255,255,255,0.08);
            color: var(--text-heading);
            font-family: inherit;
        }
        @media (max-width: 1320px) and (min-width: 1025px) {
            .search-panel .assistant-grid {
                gap: 8px;
            }
            .assistant-origin {
                flex-basis: 168px;
                min-width: 150px;
            }
            .assistant-destination {
                max-width: 360px;
            }
            .ai-search-button {
                padding: 9px 11px;
                font-size: 11px;
            }
        }
        @media (max-width: 1024px) {
            .search-panel .assistant-grid {
                grid-template-columns: 1fr;
                display: grid;
            }
            .assistant-destination,
            .destination-input {
                max-width: none;
            }
        }
        @media (max-width: 1024px) {
            body.app-shell {
                padding: 14px 12px;
            }
        }
    </style>
</head>
<body class="app-shell">
    <div class="header">
        <div class="header-brand">
            <div class="brand-tile" aria-label="Campus Transport System">
                <span class="brand-logo-wrap">
                    <img src="{{ url_for('static', filename='favicons/favicon-student.svg') }}" alt="Campus Transport Logo">
                </span>
                <div class="brand-text">
                    <h1>Campus Transport System</h1>
                    <p>KIIT Transport <span class="brand-script">Live</span> Tracking</p>
                </div>
            </div>
        </div>
        <div class="header-assistant-slot">
            <div class="assistant-panel search-panel" id="assistantPanel">
                <div class="assistant-grid">
                    <div class="assistant-field assistant-origin">
                        <label for="fromInput">Nearest stop</label>
                        <div class="assistant-input-wrap origin-chip" id="originChip" role="button" tabindex="0" aria-label="Nearest stop">
                            <input id="fromInput" type="text" placeholder="Detecting nearest stop..." readonly>
                        </div>
                    </div>
                    <div class="assistant-field assistant-destination">
                        <label for="toInput">Where to go?</label>
                        <input id="toInput" class="destination-input" type="text" placeholder="Where to go?">
                        <div id="searchSuggestions" class="search-suggestions" hidden></div>
                    </div>
                    <button id="askAiBtn" type="button" class="ai-search-button" aria-label="Ask AI">Ask AI</button>
                    <div class="assistant-leave-wrap">
                        <label for="leaveNowBtn">Leave now</label>
                        <button id="leaveNowBtn" type="button" class="leave-now-btn" aria-haspopup="true" aria-expanded="false">Leave now</button>
                        <div id="leaveDropdown" class="leave-dropdown" hidden>
                            <button type="button" class="leave-option" data-value="0">Leave now</button>
                            <button type="button" class="leave-option" data-value="15">+15 min</button>
                            <button type="button" class="leave-option" data-value="30">+30 min</button>
                            <button type="button" class="leave-option" data-value="45">+45 min</button>
                            <button type="button" class="leave-option" data-value="custom">Custom time</button>
                            <input id="leaveTimeCustom" type="time" aria-label="Custom leave time" style="display:none">
                        </div>
                        <select id="leaveTimeSelect" hidden>
                            <option value="0" selected>Leave now</option>
                            <option value="15">+15 min</option>
                            <option value="30">+30 min</option>
                            <option value="45">+45 min</option>
                            <option value="custom">Custom time</option>
                        </select>
                    </div>
                </div>
                <div class="assistant-status" id="assistantSearchStatus" aria-live="polite">Finding best route...</div>
            </div>
        </div>
        <div class="header-actions">
            <div class="header-quick-stack">
                <button id="globalThemeBtn" class="theme-btn header-quick-btn top-right-button" onclick="toggleGlobalTheme()" title="Toggle light/dark mode">Theme</button>
                <a href="/admin/login" target="_blank" rel="noopener noreferrer" class="admin-link header-quick-btn top-right-button">Admin</a>
                <button id="lowPerfBtn" class="perf-btn header-quick-btn top-right-button" onclick="toggleLowPerfMode()" title="Low performance mode" aria-pressed="false">LP</button>
                <button id="locateMeBtn" class="header-quick-btn top-right-button" title="Locate me" aria-label="Locate me">Me</button>
            </div>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <div class="card">
                <h3><span class="icon">&#128202;</span> Live Statistics <span class="live-track-pill" id="liveTrackingChip"><span class="live-track-dot"></span>LIVE TRACKING</span></h3>
                <div class="stats-grid">
                    <div class="stat-box"><div class="stat-number" id="activeBusCount">0</div><div class="stat-label">Active</div></div>
                    <div class="stat-box"><div class="stat-number" id="totalTransportCount">100</div><div class="stat-label">Total</div></div>
                </div>
            </div>

            <div class="card ops-master-card">
                <h3><span class="ops-title-group"><span class="ops-diamond">&#9672;</span><span class="ai-galaxy-icon" aria-hidden="true"></span><span>Operations Overview</span></span><span class="ai-icon-stack" aria-hidden="true"><span class="ai-spark s1"></span><span class="ai-spark s2"></span><span class="ai-spark s3"></span></span></h3>
                <div class="ops-panel">
                    <div class="ops-grid">
                        <div class="ops-tile" id="opsNextBusTile">
                            <div class="ops-kicker">Next Bus</div>
                            <div class="ops-value" id="opsNextBus">Next bus to KP14 in ~4 min</div>
                        </div>
                        <div class="ops-tile" id="opsDemandTile">
                            <div class="ops-kicker">Demand Level</div>
                            <div class="ops-value" id="opsDemand">Campus transport demand: HIGH</div>
                        </div>
                        <div class="ops-tile" id="opsNearestTile">
                            <div class="ops-kicker">Nearest Stop</div>
                            <div class="ops-value" id="opsNearestStop">Distance + walking direction.</div>
                        </div>
                        <div class="ops-tile" id="opsRouteHealthTile">
                            <div class="ops-kicker">Route Health</div>
                            <div class="ops-value" id="opsRouteHealth">Route K14: On time</div>
                        </div>
                        <div class="ops-tile" id="opsAvailabilityTile">
                            <div class="ops-kicker">Transport Availability</div>
                            <div class="ops-value" id="opsAvailability">NORMAL</div>
                        </div>
                        <div class="ops-tile" id="opsSystemTile">
                            <div class="ops-kicker">System Status</div>
                            <div class="ops-value" id="opsSystemStatus">LIVE</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card routes-card" id="routesCard">
                <h3><span>&#128739;&#65039;</span> Routes</h3>
                <div class="route-chips" id="routesContainer"></div>
                <div id="routeSortLabel" style="font-size:11px;color:var(--text-sub);margin-top:8px">Routes sorted by fastest arrival</div>
                <div class="route-scroll-controls">
                    <button id="routeScrollUpBtn" class="route-scroll-btn" type="button" aria-label="Scroll routes left" title="Scroll left">&#9664;</button>
                    <button id="routeScrollDownBtn" class="route-scroll-btn" type="button" aria-label="Scroll routes right" title="Scroll right">&#9654;</button>
                </div>
                <div id="routeBusList" class="routes-panel" tabindex="0" aria-label="Route transport list"></div>
            </div>

            <div class="card" id="routeDetailsCard" style="display:none">
                <h3><span>&#128205;</span> Route Details</h3>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px">
                    <div style="text-align:center"><div style="font-size:12px; color:#9aa4b2">Arriving In</div><div id="etaValue" style="font-size:18px; font-weight:600; color:#34d399; margin-top:4px">--</div></div>
                    <div style="text-align:center">
                        <div style="font-size:12px; color:#9aa4b2">Nearest Stop</div>
                        <div id="walkDistance" style="font-size:18px; font-weight:600; color:#667eea; margin-top:4px">--</div>
                        <div id="walkSegmentMeta" style="margin-top:6px; font-size:12px; color:#8fd2ff; display:flex; align-items:center; justify-content:center; gap:6px"><span aria-hidden="true">&#128694;</span><span id="walkDuration">~2 min walk</span></div>
                        <div class="walk-segment-progress" aria-hidden="true"><span id="walkProgressFill" style="width:30%"></span></div>
                        <div id="nextStop" style="font-size:13px; color:#9aa4b2; margin-top:2px"></div>
                    </div>
                </div>
                <div id="busesOnRoute" style="margin-top:12px; font-size:12px; color:#9aa4b2">&#128652; Transports on route: <span id="busesOnRouteCount">-</span></div>
            </div>

            <div class="card active-transport-card" id="activeTransportCard">
                <h3><span>&#128652;</span> Active Transport</h3>
                <div class="active-buses" id="activeBuses"><div class="empty-state"><p>No Transports currently active</p></div></div>
                <div class="last-update">Last updated: <span id="lastUpdate">Loading...</span></div>
            </div>
        </div>

        <div class="map-container">
            <div class="map-stage">
            <div class="map-fx map-ambient"></div>
            <div class="map-fx map-texture"></div>
            <div class="map-fx map-vignette"></div>
            <div class="live-badge"><span class="live-dot"></span>LIVE</div>
            <div class="info-strip">
                <div class="info-item"><span class="info-label">Route</span><span id="currentRouteOverlay">--</span></div>
                <div class="info-item info-eta">Arriving In: <span id="etaOverlay">--</span></div>
                <div class="info-item"><span class="info-label">Active</span><span id="activeCountOverlay">0</span></div>
                <div class="info-item"><span class="info-label">Last</span><span id="lastUpdateOverlay">--</span></div>
            </div>
            <div id="map"></div>
            <button id="zoom16Btn" class="map-theme-btn map-zoom16-btn" title="Center and zoom to 16" aria-label="Center and zoom to 16">16x</button>
            <button id="followNearestBtn" class="map-theme-btn map-follow-btn" title="Follow nearest transport" aria-label="Follow nearest transport">Follow nearest transport</button>
            <button id="mapThemeBtn" class="map-theme-btn" onclick="toggleMapTheme()" title="Toggle map light/dark">Map Theme</button>
            </div>
            <div class="card map-layers-card map-layers-panel" id="mapLayersCard">
                <h3><span>&#128205;</span> Map Layers and Info</h3>
                <div class="layer-control row">
                    <label class="toggle-item layer-toggle" style="--layer-color:#FF5722;">
                        <input type="checkbox" id="routesToggle" checked>
                        <span class="layer-pill-icon" aria-hidden="true">&#128739;</span>
                        <span class="toggle-label">Routes</span>
                        <span class="layer-state"><span class="layer-state-dot"></span><span class="layer-state-text"></span></span>
                    </label>
                    <label class="toggle-item layer-toggle" style="--layer-color:#9C27B0;">
                        <input type="checkbox" id="hostelsToggle" checked>
                        <span class="layer-pill-icon" aria-hidden="true">&#127968;</span>
                        <span class="toggle-label">Hostels</span>
                        <span class="layer-state"><span class="layer-state-dot"></span><span class="layer-state-text"></span></span>
                    </label>
                    <label class="toggle-item layer-toggle" style="--layer-color:#2196F3;">
                        <input type="checkbox" id="classesToggle" checked>
                        <span class="layer-pill-icon" aria-hidden="true">&#127979;</span>
                        <span class="toggle-label">Classes</span>
                        <span class="layer-state"><span class="layer-state-dot"></span><span class="layer-state-text"></span></span>
                    </label>
                </div>
                <div class="map-status-grid row" id="mapStatusGrid">
                    <div class="map-status-item map-info-chip">
                        <div class="map-status-key">Zoom Level</div>
                        <div class="map-status-value" id="mapZoomValue">--</div>
                    </div>
                    <div class="map-status-item map-info-chip">
                        <div class="map-status-key">Tracking Mode</div>
                        <div class="map-status-value" id="mapTrackingValue">--</div>
                    </div>
                    <div class="map-status-item map-info-chip">
                        <div class="map-status-key">Last Sync</div>
                        <div class="map-status-value" id="mapSyncValue">--</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        let map;
        let busMarkers = {};
        let hostelMarkers = {};
        let classMarkers = {};
        let routePolylines = {};
        const routeLineAnimState = {};
        let selectedRouteId = null;
        let trackedBus = null;
        let recommendedPulseRouteId = null;
        let animatedCardsRouteId = null;
        let allRoutes = [];
        let userLocation = null;
        let walkingLine = null;
        let busRouteMap = {}; // Maps bus number to route ID
        let userMarker = null;
        let userWatchId = null;
        // Shared buses cache to avoid redundant /api/buses fetches
        let latestBuses = {};
        let sseConnected = false;
        let _eventSource = null;
        let busesPollTimerId = null;
        let _busFetchInFlight = false;
        let _busFetchQueued = false;
        let _busUiRefreshTimer = null;
        const POLL_INTERVAL_MS = 1200;   // latency-first polling fallback when SSE is down
        const RESYNC_INTERVAL_MS = 30000; // light cleanup resync every 30s
        const OFFLINE_MS = 30000; // mark bus offline after 30s of no updates
        const REMOVE_MS = 60000; // remove bus marker after 60s of no updates
        const colors = [
            '#FF3B30', '#34C759', '#007AFF', '#FF9500', '#AF52DE',
            '#5AC8FA', '#FF2D55', '#FFD60A', '#32D74B', '#5856D6',
            '#FF9F0A', '#00C7BE', '#E82D2D', '#00A8FF', '#9B59B6',
            '#F1C40F', '#2ECC71', '#E74C3C', '#3498DB', '#E67E22'
        ];
        const DEFAULT_UI_THEME = Object.freeze({ accent_color: '#8b64ff', saturation: 120 });
        const THEME_BROADCAST_KEY = 'kiit_ui_theme_broadcast_v1';

        function normalizeThemeHexColor(value) {
            let hex = String(value || '').trim();
            if (/^#[0-9a-fA-F]{3}$/.test(hex)) {
                hex = '#' + hex.slice(1).split('').map(ch => ch + ch).join('');
            }
            if (!/^#[0-9a-fA-F]{6}$/.test(hex)) return DEFAULT_UI_THEME.accent_color;
            return `#${hex.slice(1).toLowerCase()}`;
        }

        function clampThemeSaturation(value) {
            const n = Number(value);
            if (!Number.isFinite(n)) return DEFAULT_UI_THEME.saturation;
            return Math.max(20, Math.min(260, Math.round(n)));
        }

        function hexToRgb(themeHex) {
            const clean = normalizeThemeHexColor(themeHex).slice(1);
            return {
                r: parseInt(clean.slice(0, 2), 16),
                g: parseInt(clean.slice(2, 4), 16),
                b: parseInt(clean.slice(4, 6), 16),
            };
        }

        function rgbToHsl(r, g, b) {
            const rn = r / 255;
            const gn = g / 255;
            const bn = b / 255;
            const max = Math.max(rn, gn, bn);
            const min = Math.min(rn, gn, bn);
            const d = max - min;
            let h = 0;
            if (d !== 0) {
                if (max === rn) h = ((gn - bn) / d) % 6;
                else if (max === gn) h = ((bn - rn) / d) + 2;
                else h = ((rn - gn) / d) + 4;
            }
            h = Math.round(((h * 60) + 360) % 360);
            const l = (max + min) / 2;
            const s = d === 0 ? 0 : d / (1 - Math.abs((2 * l) - 1));
            return { h, s, l };
        }

        function hsla(h, s, l, a) {
            const hh = Math.round(((Number(h) % 360) + 360) % 360);
            const ss = Math.max(0, Math.min(100, Number(s)));
            const ll = Math.max(0, Math.min(100, Number(l)));
            if (a == null) return `hsl(${hh}, ${ss}%, ${ll}%)`;
            const aa = Math.max(0, Math.min(1, Number(a)));
            return `hsla(${hh}, ${ss}%, ${ll}%, ${aa})`;
        }

        function setThemeCssVar(name, value) {
            document.documentElement.style.setProperty(name, value);
            if (document.body) document.body.style.setProperty(name, value);
        }

        function applyGlobalUiTheme(rawTheme) {
            const accent = normalizeThemeHexColor((rawTheme || {}).accent_color);
            const saturation = clampThemeSaturation((rawTheme || {}).saturation);
            const rgb = hexToRgb(accent);
            const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
            const baseRgb = hexToRgb(DEFAULT_UI_THEME.accent_color);
            const baseHsl = rgbToHsl(baseRgb.r, baseRgb.g, baseRgb.b);
            const hueDelta = hsl.h - baseHsl.h;
            const satScale = saturation / DEFAULT_UI_THEME.saturation;
            const baseSat = Math.max(18, Math.min(96, Math.round((hsl.s * 100) * satScale)));
            const baseLight = Math.max(28, Math.min(72, Math.round(hsl.l * 100)));
            const altHue = (hsl.h + 24) % 360;

            setThemeCssVar('--ui-theme-accent', accent);
            setThemeCssVar('--ui-theme-hue', `${hueDelta.toFixed(1)}deg`);
            setThemeCssVar('--ui-theme-saturation', `${saturation}%`);
            setThemeCssVar('--ui-theme-accent-rgb', `${rgb.r}, ${rgb.g}, ${rgb.b}`);
            setThemeCssVar('--glass-sat', `${Math.max(70, Math.min(220, saturation))}%`);
            setThemeCssVar('--theme-icon-saturation', `${Math.max(0.65, Math.min(2.1, saturation / 85)).toFixed(2)}`);
            setThemeCssVar('--theme-icon-brightness', `${Math.max(0.88, Math.min(1.24, 1 + ((saturation - 120) / 420))).toFixed(2)}`);
            setThemeCssVar('--accent-blue', accent);
            setThemeCssVar('--accent-cyan', hsla(altHue, Math.min(98, baseSat + 8), Math.min(84, baseLight + 16)));
            setThemeCssVar('--bg-gradient1', hsla(hsl.h, Math.max(22, baseSat), Math.min(78, baseLight + 10), 0.48));
            setThemeCssVar('--bg-gradient2', hsla((hsl.h + 18) % 360, Math.max(20, Math.round(baseSat * 0.84)), Math.min(74, baseLight + 4), 0.36));
            setThemeCssVar('--ai-glow', hsla((hsl.h + 8) % 360, Math.max(24, Math.round(baseSat * 0.9)), Math.min(82, baseLight + 14), 0.46));
            setThemeCssVar('--card-border', hsla(hsl.h, Math.max(22, Math.round(baseSat * 0.84)), Math.min(86, baseLight + 18), 0.50));
            setThemeCssVar('--stat-border', hsla(hsl.h, Math.max(24, Math.round(baseSat * 0.88)), Math.min(88, baseLight + 20), 0.52));
            setThemeCssVar('--input-border', hsla(hsl.h, Math.max(24, Math.round(baseSat * 0.92)), Math.min(90, baseLight + 21), 0.56));
            setThemeCssVar('--chip-border', hsla(hsl.h, Math.max(24, Math.round(baseSat * 0.9)), Math.min(88, baseLight + 20), 0.54));
            setThemeCssVar('--map-border', hsla(hsl.h, Math.max(24, Math.round(baseSat * 0.9)), Math.min(90, baseLight + 21), 0.52));
            setThemeCssVar('--liquid-edge', hsla(hsl.h, Math.max(24, Math.round(baseSat * 0.9)), Math.min(90, baseLight + 20), 0.52));
        }

        async function loadGlobalUiTheme() {
            try {
                const res = await fetch('/api/ui-theme', { cache: 'no-store' });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'theme_load_failed');
                applyGlobalUiTheme(data || DEFAULT_UI_THEME);
            } catch (e) {
                applyGlobalUiTheme(DEFAULT_UI_THEME);
            }
        }

        function handleUiThemeBroadcastEvent(e) {
            if (!e || e.key !== THEME_BROADCAST_KEY || !e.newValue) return;
            try {
                const payload = JSON.parse(e.newValue);
                applyGlobalUiTheme(payload || DEFAULT_UI_THEME);
            } catch (err) {}
        }

        let prevBusPositions = {};  // snapped positions for display
        let prevRawPositions = {};   // raw positions for status detection
        let prevBusTimes = {};
        let prevBusRotation = {};
        let prevTrackedState = {};
        let prevRouteSelState = {};
        let followEnabled = true;
        let busLastSeen = {};  // busNum -> Date.now() of last received update
        let busLastSSEUpdate = {};  // busNum -> Date.now() of last SSE-driven update (to skip redundant polls)
        let busDirection = {};  // busNum -> 'up' | 'down' (direction along route stops)
        let busLastStopIdx = {}; // busNum -> last nearest stop index
        let busCurrentStop = {}; // busNum -> stop name if at a stop, null otherwise
        const AT_STOP_THRESHOLD = 80; // meters - consider bus "at stop" within this distance (accounts for GPS lag)
        const busNearestStopCache = {}; // busNum -> { idx, dist, atStopName }
        const busStatusCache = {}; // busNum -> last computed status string
        const busSpeedCache = {};  // busNum -> last computed speed (km/h) or null
        const busMovedCache = {};  // busNum -> distance moved (meters) since last update
        let busTerminalStatus = {}; // busNum -> 'at_start' | 'at_destination' | 'waiting' | null
        const routeCumulDistCache = {}; // routeId -> cumulative distances array
        const busKalmanState = {}; // busNum -> { lat: {x,p,q,r}, lng: {x,p,q,r} }
        const busTweenSpeedCache = {}; // busNum -> smoothed speed (km/h) for movement pacing
        const busTrails = {}; // busNum -> { polyline, points: [{lat,lng,t}] }
        const TRAIL_MAX_AGE_MS = 42000;
        const TRAIL_MAX_POINTS = 20;
        const TRAIL_MIN_MOVE_M = 6;
        let trailRefreshTimerId = null;
        let mapManualUntilMs = 0;
        let mapManualTimerId = null;
        let sidebarScrollTimerId = null;
        const USER_RENDER_RADIUS_M = 30000;
        const ALL_ROUTES_PAD_M = 5000;
        const ROUTE_FOCUS_PAD_M = 3000;
        let allRoutesBounds = null;
        const routeBoundsCache = {};
        let _initialViewportApplied = false;
        let _lastViewportContextKey = '';
        let _spatialSyncRaf = null;
        let _spatialSyncTimer = null;
        let _lastSpatialSyncMs = 0;
        let _tweenAnimRunning = false;
        let _lastTweenFrameTs = 0;
        let _lastAutoPanMs = 0;
        let _lastPredictionFrameTs = 0;
        let _detectedRefreshHz = 60;
        let _tweenFrameMinGapMs = 1000 / 60;
        let _predFrameMinGapMs = 1000 / 60;
        let _framePacingReady = false;
        const AUTO_PAN_MIN_INTERVAL_MS = 420;
        const AUTO_PAN_PADDING_PX = 80;
        const DEFAULT_TILE_ZOOM = 16;
        const MIN_AUTO_FIT_ZOOM = 16;
        const BHUBANESWAR_CORE_BOUNDS = L.latLngBounds([20.195, 85.74], [20.44, 85.93]);
        const BHUBANESWAR_PADDING_KM = 10;
        const BHUBANESWAR_LIMIT_BOUNDS = expandBoundsByKm(BHUBANESWAR_CORE_BOUNDS, BHUBANESWAR_PADDING_KM);
        const SPATIAL_SYNC_MIN_GAP_MS = 180;
        const DESTINATION_PRESETS = {
            'campus gate': { label: 'Campus Gate', lat: 20.3529, lng: 85.8182 },
            'academic block': { label: 'Academic Block', lat: 20.3564, lng: 85.8170 },
            'library': { label: 'Library', lat: 20.3560, lng: 85.8158 },
            'kp hostels': { label: 'KP Hostels', lat: 20.3608, lng: 85.8204 },
            'food court': { label: 'Food Court', lat: 20.3552, lng: 85.8146 }
        };
        const ETA_TREND_MIN_INTERVAL_MS = 2000;
        const VIEWER_PRESENCE_KEY = 'kiit_student_viewers_presence_v1';
        const VIEWER_HEARTBEAT_MS = 5000;
        const STUDENT_SERVER_PRESENCE_HEARTBEAT_MS = 12000;
        const VIEWER_STALE_MS = 16000;
        const VIEWER_ID = `viewer_${Math.random().toString(36).slice(2)}_${Date.now()}`;
        const WALK_SPEED_MPS = 1.35;
        const RIDE_SPEED_KMH = 18;
        let viewerPresenceTimerId = null;
        let studentPresenceInFlight = false;
        let approxViewerCount = 1;
        let assistantFromEdited = false;
        let assistantDestinationPoint = null;
        let assistantDestinationLabel = '';
        let assistantSearchDebounceId = null;
        let assistantSearchAnimTimerId = null;
        let assistantPreviewLine = null;
        let assistantPreviewAnimRaf = null;
        let assistantSuggestionCloseTimerId = null;
        let routeStackFlowScrollTimerId = null;
        let routeStackFlowWheelLockUntil = 0;
        let routeStackFlowMomentumRaf = null;
        let routeStackFlowMomentumVelocity = 0;
        const busEtaTrendCache = {}; // busNum -> { etaSec, ts }

        function expandBoundsByKm(bounds, km) {
            const center = bounds.getCenter();
            const latPad = km / 110.574;
            const lngDenom = 111.320 * Math.max(0.2, Math.cos(center.lat * Math.PI / 180));
            const lngPad = km / lngDenom;
            return L.latLngBounds(
                [bounds.getSouth() - latPad, bounds.getWest() - lngPad],
                [bounds.getNorth() + latPad, bounds.getEast() + lngPad]
            );
        }

        // Cached DOM element refs - populated once in initMap, avoids getElementById in hot paths
        const _dom = {};
        function cacheDom() {
            _dom.sidebar = document.querySelector('.sidebar');
            _dom.activeBusCount = document.getElementById('activeBusCount');
            _dom.activeCountOverlay = document.getElementById('activeCountOverlay');
            _dom.activeBuses = document.getElementById('activeBuses');
            _dom.lastUpdate = document.getElementById('lastUpdate');
            _dom.lastUpdateOverlay = document.getElementById('lastUpdateOverlay');
            _dom.etaValue = document.getElementById('etaValue');
            _dom.etaOverlay = document.getElementById('etaOverlay');
            _dom.etaInfo = document.querySelector('.info-item.info-eta');
            _dom.currentRouteOverlay = document.getElementById('currentRouteOverlay');
            _dom.busesOnRouteCount = document.getElementById('busesOnRouteCount');
            _dom.walkDistance = document.getElementById('walkDistance');
            _dom.routeDetailsCard = document.getElementById('routeDetailsCard');
            _dom.routesContainer = document.getElementById('routesContainer');
            _dom.routeBusList = document.getElementById('routeBusList');
            _dom.routeScrollUpBtn = document.getElementById('routeScrollUpBtn');
            _dom.routeScrollDownBtn = document.getElementById('routeScrollDownBtn');
            _dom.routesCard = document.getElementById('routesCard');
            _dom.activeTransportCard = document.getElementById('activeTransportCard');
            _dom.totalTransportCount = document.getElementById('totalTransportCount');
            _dom.opsNextBus = document.getElementById('opsNextBus');
            _dom.opsDemand = document.getElementById('opsDemand');
            _dom.opsNearestStop = document.getElementById('opsNearestStop');
            _dom.opsRouteHealth = document.getElementById('opsRouteHealth');
            _dom.opsAvailability = document.getElementById('opsAvailability');
            _dom.opsSystemStatus = document.getElementById('opsSystemStatus');
            _dom.mapStage = document.querySelector('.map-stage');
            _dom.mapLayersCard = document.getElementById('mapLayersCard');
            _dom.mapStatusGrid = document.getElementById('mapStatusGrid');
            _dom.mapZoomValue = document.getElementById('mapZoomValue');
            _dom.mapTrackingValue = document.getElementById('mapTrackingValue');
            _dom.mapSyncValue = document.getElementById('mapSyncValue');
            _dom.assistantPanel = document.getElementById('assistantPanel');
            _dom.routeSummaryTitle = document.getElementById('routeSummaryTitle');
            _dom.routeSummaryMeta = document.getElementById('routeSummaryMeta');
            _dom.routeSummaryList = document.getElementById('routeSummaryList');
            _dom.fromInput = document.getElementById('fromInput');
            _dom.toInput = document.getElementById('toInput');
            _dom.originChip = document.getElementById('originChip');
            _dom.searchSuggestions = document.getElementById('searchSuggestions');
            _dom.askAiBtn = document.getElementById('askAiBtn');
            _dom.destinationChips = document.getElementById('destinationChips');
            _dom.leaveNowBtn = document.getElementById('leaveNowBtn');
            _dom.leaveDropdown = document.getElementById('leaveDropdown');
            _dom.leaveTimeSelect = document.getElementById('leaveTimeSelect');
            _dom.leaveTimeCustom = document.getElementById('leaveTimeCustom');
            _dom.assistantSearchStatus = document.getElementById('assistantSearchStatus');
            _dom.followNearestBtn = document.getElementById('followNearestBtn');
            _dom.walkDuration = document.getElementById('walkDuration');
            _dom.walkProgressFill = document.getElementById('walkProgressFill');
            _dom.nextStop = document.getElementById('nextStop');
        }
        function initSidebarScrollStabilizer() {
            const sidebar = _dom.sidebar || document.querySelector('.sidebar');
            if (!sidebar || sidebar._scrollStabilizerBound) return;
            sidebar._scrollStabilizerBound = true;
            sidebar.addEventListener('scroll', () => {
                sidebar.classList.add('is-scrolling');
                if (sidebarScrollTimerId) {
                    try { clearTimeout(sidebarScrollTimerId); } catch (e) {}
                }
                sidebarScrollTimerId = setTimeout(() => {
                    sidebarScrollTimerId = null;
                    sidebar.classList.remove('is-scrolling');
                }, 120);
            }, { passive: true });
        }
        function syncRouteFocusedLayout() {
            const hasRoute = !!selectedRouteId;
            const routesCard = _dom.routesCard || document.getElementById('routesCard');
            const activeCard = _dom.activeTransportCard || document.getElementById('activeTransportCard');
            if (routesCard) routesCard.classList.toggle('route-expanded', hasRoute);
            if (activeCard) activeCard.classList.toggle('route-hidden', hasRoute);
        }
        function ensureRouteDetailsVisible() {
            const sidebar = _dom.sidebar || document.querySelector('.sidebar');
            const details = _dom.routeDetailsCard || document.getElementById('routeDetailsCard');
            if (!sidebar || !details) return;
            const pad = 10;
            const sRect = sidebar.getBoundingClientRect();
            const dRect = details.getBoundingClientRect();
            const top = (dRect.top - sRect.top) + sidebar.scrollTop;
            const bottom = top + dRect.height;
            const viewTop = sidebar.scrollTop + pad;
            const viewBottom = sidebar.scrollTop + sidebar.clientHeight - pad;
            let targetTop = sidebar.scrollTop;
            if (bottom > viewBottom) {
                targetTop = Math.max(0, bottom - sidebar.clientHeight + pad);
            }
            if (top < viewTop) {
                targetTop = Math.max(0, top - pad);
            }
            if (Math.abs(targetTop - sidebar.scrollTop) > 1) {
                try { sidebar.scrollTo({ top: targetTop, behavior: 'smooth' }); } catch (e) { sidebar.scrollTop = targetTop; }
            }
        }
        function ensureTrackedRouteCardVisible(containerParam = null, behavior = 'auto') {
            const container = containerParam || _dom.routeBusList || document.getElementById('routeBusList');
            if (!container || !trackedBus) return;
            const target = container.querySelector(`.route-result-card[data-bus-num="${trackedBus}"]`);
            if (!target) return;
            const pad = 8;
            const viewLeft = container.scrollLeft;
            const viewRight = viewLeft + container.clientWidth;
            const cardLeft = target.offsetLeft;
            const cardRight = cardLeft + target.offsetWidth;
            if (cardLeft >= (viewLeft + pad) && cardRight <= (viewRight - pad)) return;
            const centeredLeft = Math.max(0, Math.round(cardLeft - ((container.clientWidth - target.offsetWidth) * 0.5)));
            try {
                container.scrollTo({ left: centeredLeft, behavior });
            } catch (e) {
                container.scrollLeft = centeredLeft;
            }
        }
        function applyRouteStackFlow(containerParam = null) {
            const container = containerParam || _dom.routeBusList || document.getElementById('routeBusList');
            if (!container) return;
            const cards = Array.from(container.querySelectorAll('.route-result-card'));
            if (!cards.length) return;
            let activeIndex = 0;
            const trackedIndex = trackedBus
                ? cards.findIndex((card) => String(card.dataset.busNum || '') === String(trackedBus))
                : -1;
            if (trackedIndex >= 0) {
                activeIndex = trackedIndex;
            } else {
                let bestOffset = Infinity;
                cards.forEach((card, idx) => {
                    const centerX = card.offsetLeft + (card.offsetWidth * 0.5);
                    const viewportCenterX = container.scrollLeft + (container.clientWidth * 0.5);
                    const d = Math.abs(centerX - viewportCenterX);
                    if (d < bestOffset) {
                        bestOffset = d;
                        activeIndex = idx;
                    }
                });
            }
            cards.forEach((card, idx) => {
                const delta = idx - activeIndex;
                const topPx = 0;
                const overlapPx = 0;

                card.classList.remove('stack-front', 'stack-back-1', 'stack-back-2', 'stack-back-3', 'stack-hidden');
                if (delta === 0) card.classList.add('stack-front');
                else if (delta === 1) card.classList.add('stack-back-1');
                else if (delta === 2) card.classList.add('stack-back-2');
                else if (delta > 2) card.classList.add('stack-back-3');
                else card.classList.add('stack-hidden');

                card.style.setProperty('--stack-index', String(idx));
                card.style.setProperty('--stack-top', `${topPx}px`);
                card.style.setProperty('--stack-overlap', `${overlapPx}px`);
                const zValue = delta === 0 ? 20 : 1;
                card.style.setProperty('--stack-z', String(zValue));
            });
        }
        function setRouteStackFlowState(enabled) {
            const container = _dom.routeBusList || document.getElementById('routeBusList');
            if (!container) return;
            const routesCard = _dom.routesCard || document.getElementById('routesCard');
            const shouldEnable = !!enabled && !isLowPerfMode();
            container.classList.toggle('stack-flow', shouldEnable);
            if (routesCard) routesCard.classList.toggle('route-stack-mode', shouldEnable);
            if (!shouldEnable) {
                container.classList.remove('is-flowing');
                routeStackFlowWheelLockUntil = 0;
                stopRouteStackFlowMomentum();
                const cards = container.querySelectorAll('.route-result-card');
                cards.forEach((card) => {
                    card.classList.remove('stack-front', 'stack-back-1', 'stack-back-2', 'stack-back-3', 'stack-hidden');
                    card.style.removeProperty('--stack-index');
                    card.style.removeProperty('--stack-top');
                    card.style.removeProperty('--stack-overlap');
                    card.style.removeProperty('--stack-z');
                });
                return;
            }
            if (container.scrollLeft < 0 || !Number.isFinite(container.scrollLeft)) container.scrollLeft = 0;
            applyRouteStackFlow(container);
        }
        function stopRouteStackFlowMomentum() {
            if (routeStackFlowMomentumRaf) {
                try { cancelAnimationFrame(routeStackFlowMomentumRaf); } catch (e) {}
                routeStackFlowMomentumRaf = null;
            }
            routeStackFlowMomentumVelocity = 0;
        }
        function pushRouteStackFlowMomentum(container, deltaPx) {
            if (!container || !Number.isFinite(deltaPx) || deltaPx === 0) return;
            routeStackFlowMomentumVelocity += deltaPx;
            routeStackFlowMomentumVelocity = Math.max(-120, Math.min(120, routeStackFlowMomentumVelocity));
            if (routeStackFlowMomentumRaf) return;
            const tick = () => {
                routeStackFlowMomentumRaf = null;
                if (!container.isConnected) {
                    stopRouteStackFlowMomentum();
                    return;
                }
                if (Math.abs(routeStackFlowMomentumVelocity) < 0.12) {
                    routeStackFlowMomentumVelocity = 0;
                    return;
                }
                const prevLeft = container.scrollLeft;
                container.scrollLeft += routeStackFlowMomentumVelocity;
                const moved = Math.abs(container.scrollLeft - prevLeft);
                const atEdge = moved < 0.2;
                routeStackFlowMomentumVelocity *= atEdge ? 0.58 : 0.93;
                routeStackFlowMomentumRaf = requestAnimationFrame(tick);
            };
            routeStackFlowMomentumRaf = requestAnimationFrame(tick);
        }
        function bindRouteStackFlow() {
            const container = _dom.routeBusList || document.getElementById('routeBusList');
            if (!container || container.dataset.stackFlowBound) return;
            container.dataset.stackFlowBound = '1';
            const scrollStep = () => Math.max(220, Math.round(container.clientWidth - 14));
            const scrollRouteList = (delta) => {
                if (!Number.isFinite(delta) || delta === 0) return;
                stopRouteStackFlowMomentum();
                try {
                    container.scrollBy({ left: delta, behavior: 'smooth' });
                } catch (e) {
                    container.scrollLeft += delta;
                }
            };
            container.addEventListener('mouseenter', () => {
                try { container.focus({ preventScroll: true }); } catch (e) { try { container.focus(); } catch (e2) {} }
            });
            container.addEventListener('pointerdown', () => { stopRouteStackFlowMomentum(); }, { passive: true });
            container.addEventListener('touchstart', () => { stopRouteStackFlowMomentum(); }, { passive: true });
            container.addEventListener('keydown', (event) => {
                const key = event.key;
                if (key === 'ArrowRight' || key === 'ArrowDown') {
                    event.preventDefault();
                    scrollRouteList(scrollStep());
                } else if (key === 'ArrowLeft' || key === 'ArrowUp') {
                    event.preventDefault();
                    scrollRouteList(-scrollStep());
                } else if (key === 'PageDown') {
                    event.preventDefault();
                    scrollRouteList(Math.max(220, Math.round(container.clientWidth * 0.9)));
                } else if (key === 'PageUp') {
                    event.preventDefault();
                    scrollRouteList(-Math.max(220, Math.round(container.clientWidth * 0.9)));
                } else if (key === 'Home') {
                    event.preventDefault();
                    container.scrollTo({ left: 0, behavior: 'smooth' });
                } else if (key === 'End') {
                    event.preventDefault();
                    container.scrollTo({ left: container.scrollWidth, behavior: 'smooth' });
                }
            });
            const upBtn = _dom.routeScrollUpBtn || document.getElementById('routeScrollUpBtn');
            const downBtn = _dom.routeScrollDownBtn || document.getElementById('routeScrollDownBtn');
            if (upBtn && !upBtn.dataset.bound) {
                upBtn.dataset.bound = '1';
                upBtn.addEventListener('click', () => scrollRouteList(-scrollStep()));
            }
            if (downBtn && !downBtn.dataset.bound) {
                downBtn.dataset.bound = '1';
                downBtn.addEventListener('click', () => scrollRouteList(scrollStep()));
            }
            container.addEventListener('wheel', (event) => {
                if (container.scrollWidth <= container.clientWidth + 1) return;
                const rawX = Number.isFinite(event.deltaX) ? event.deltaX : 0;
                const rawY = Number.isFinite(event.deltaY) ? event.deltaY : 0;
                const horizontalIntent = Math.abs(rawX) > 0.6 && Math.abs(rawX) >= (Math.abs(rawY) * 0.6);
                if (horizontalIntent) {
                    // Native horizontal trackpad scrolling feels better than scripted interpolation.
                    stopRouteStackFlowMomentum();
                    return;
                }
                let delta = rawY;
                if (!Number.isFinite(delta) || Math.abs(delta) < 1) return;
                if (event.deltaMode === 1) delta *= 18;
                else if (event.deltaMode === 2) delta *= Math.max(280, container.clientWidth * 0.92);
                const maxLeft = Math.max(0, container.scrollWidth - container.clientWidth);
                const atStart = container.scrollLeft <= 1;
                const atEnd = container.scrollLeft >= (maxLeft - 1);
                if ((delta < 0 && atStart) || (delta > 0 && atEnd)) return;
                event.preventDefault();
                const scaled = delta * (Math.abs(delta) > 42 ? 0.58 : 0.46);
                pushRouteStackFlowMomentum(container, scaled);
                routeStackFlowWheelLockUntil = 0;
            }, { passive: false });
            container.addEventListener('scroll', () => {
                if (!container.classList.contains('stack-flow')) return;
                container.classList.add('is-flowing');
                applyRouteStackFlow(container);
                if (routeStackFlowScrollTimerId) {
                    try { clearTimeout(routeStackFlowScrollTimerId); } catch (e) {}
                    routeStackFlowScrollTimerId = null;
                }
                routeStackFlowScrollTimerId = setTimeout(() => {
                    routeStackFlowScrollTimerId = null;
                    container.classList.remove('is-flowing');
                }, 120);
            }, { passive: true });
        }

        // Throttled time string  toLocaleTimeString is expensive, limit to 1/sec
        let _cachedTimeStr = ''; let _cachedTimeMs = 0;
        function getTimeString() {
            const now = Date.now();
            if (now - _cachedTimeMs < 1000) return _cachedTimeStr;
            _cachedTimeMs = now;
            _cachedTimeStr = new Date(now).toLocaleTimeString();
            return _cachedTimeStr;
        }
        function refreshLayerToggleUi() {
            ['routesToggle', 'hostelsToggle', 'classesToggle'].forEach((id) => {
                const input = document.getElementById(id);
                if (!input) return;
                const label = input.closest('.toggle-item');
                if (!label) return;
                const active = !!input.checked;
                label.classList.toggle('is-active', active);
                label.setAttribute('aria-pressed', active ? 'true' : 'false');
            });
        }
        function pulseLayerChangeUI() {
            if (isLowPerfMode()) return;
            const animateOnce = (el) => {
                if (!el) return;
                el.classList.remove('layer-switching');
                void el.offsetWidth;
                el.classList.add('layer-switching');
                setTimeout(() => { try { el.classList.remove('layer-switching'); } catch(e) {} }, 180);
            };
            animateOnce(_dom.mapStage || document.querySelector('.map-stage'));
            animateOnce(_dom.mapLayersCard || document.getElementById('mapLayersCard'));
        }
        function setManualTrackingWindow(ms = 9000) {
            mapManualUntilMs = Date.now() + ms;
            if (mapManualTimerId) { clearTimeout(mapManualTimerId); mapManualTimerId = null; }
            mapManualTimerId = setTimeout(() => { mapManualTimerId = null; refreshMapStatusPanel(); }, ms + 120);
            refreshMapStatusPanel();
        }
        function refreshMapStatusPanel(syncText) {
            if (_dom.mapZoomValue && map) {
                _dom.mapZoomValue.textContent = String(map.getZoom());
            }
            if (_dom.mapTrackingValue) {
                const manualMode = (Date.now() < mapManualUntilMs) || !sseConnected;
                const modeText = manualMode ? 'Manual' : 'Live';
                _dom.mapTrackingValue.textContent = modeText;
                _dom.mapTrackingValue.classList.toggle('is-live', !manualMode);
                _dom.mapTrackingValue.classList.toggle('is-manual', manualMode);
            }
            if (_dom.mapSyncValue) {
                const val = syncText || (_dom.lastUpdate ? _dom.lastUpdate.textContent : '');
                _dom.mapSyncValue.textContent = (val && val !== 'Loading...') ? val : '--';
            }
        }
        function setLastSyncUI(nowText) {
            if (_dom.lastUpdate) _dom.lastUpdate.textContent = nowText;
            if (_dom.lastUpdateOverlay) _dom.lastUpdateOverlay.textContent = nowText;
            refreshMapStatusPanel(nowText);
        }
        function refreshFramePacing() {
            if (isLowPerfMode()) {
                _tweenFrameMinGapMs = 1000 / 30;
                _predFrameMinGapMs = 1000 / 24;
                return;
            }
            const hz = Math.max(50, Math.min(165, _detectedRefreshHz || 60));
            const tweenHz = Math.min(144, Math.max(60, hz));
            const predHz = Math.min(120, Math.max(50, hz * 0.80));
            _tweenFrameMinGapMs = 1000 / tweenHz;
            _predFrameMinGapMs = 1000 / predHz;
        }
        function calibrateFramePacing() {
            if (_framePacingReady) return;
            _framePacingReady = true;
            const samples = [];
            let lastTs = 0;
            const SAMPLE_COUNT = 28;
            const step = (ts) => {
                if (lastTs) {
                    const delta = ts - lastTs;
                    if (delta > 3 && delta < 40) samples.push(delta);
                }
                lastTs = ts;
                if (samples.length < SAMPLE_COUNT) {
                    requestAnimationFrame(step);
                    return;
                }
                const sorted = samples.slice().sort((a, b) => a - b);
                const median = sorted[Math.floor(sorted.length / 2)] || (1000 / 60);
                _detectedRefreshHz = Math.max(30, Math.min(240, 1000 / median));
                refreshFramePacing();
            };
            requestAnimationFrame(step);
        }

        function computeBoundsFromLatLngs(latlngs) {
            if (!latlngs || !latlngs.length) return null;
            let minLat = Infinity, maxLat = -Infinity, minLng = Infinity, maxLng = -Infinity;
            for (let i = 0; i < latlngs.length; i++) {
                const pt = latlngs[i];
                if (!pt || pt.length < 2) continue;
                const lat = Number(pt[0]);
                const lng = Number(pt[1]);
                if (!isFinite(lat) || !isFinite(lng)) continue;
                if (lat < minLat) minLat = lat;
                if (lat > maxLat) maxLat = lat;
                if (lng < minLng) minLng = lng;
                if (lng > maxLng) maxLng = lng;
            }
            if (!isFinite(minLat) || !isFinite(minLng) || !isFinite(maxLat) || !isFinite(maxLng)) return null;
            return { minLat, maxLat, minLng, maxLng };
        }
        function mergeBounds(a, b) {
            if (!a) return b ? { ...b } : null;
            if (!b) return { ...a };
            return {
                minLat: Math.min(a.minLat, b.minLat),
                maxLat: Math.max(a.maxLat, b.maxLat),
                minLng: Math.min(a.minLng, b.minLng),
                maxLng: Math.max(a.maxLng, b.maxLng)
            };
        }
        function expandBoundsByMeters(bounds, meters) {
            if (!bounds) return null;
            const centerLat = (bounds.minLat + bounds.maxLat) * 0.5;
            const dLat = meters / 111320;
            const cosLat = Math.cos(centerLat * Math.PI / 180);
            const dLng = meters / (111320 * Math.max(0.2, Math.abs(cosLat)));
            return {
                minLat: bounds.minLat - dLat,
                maxLat: bounds.maxLat + dLat,
                minLng: bounds.minLng - dLng,
                maxLng: bounds.maxLng + dLng
            };
        }
        function boundsToLeaflet(bounds) {
            if (!bounds) return null;
            return L.latLngBounds([[bounds.minLat, bounds.minLng], [bounds.maxLat, bounds.maxLng]]);
        }
        function isPointInsideBounds(lat, lng, bounds) {
            if (!bounds) return true;
            return lat >= bounds.minLat && lat <= bounds.maxLat && lng >= bounds.minLng && lng <= bounds.maxLng;
        }
        function boundsIntersect(a, b) {
            if (!a || !b) return false;
            return !(a.maxLat < b.minLat || a.minLat > b.maxLat || a.maxLng < b.minLng || a.minLng > b.maxLng);
        }
        function distancePointToBoundsMeters(lat, lng, bounds) {
            if (!bounds) return Infinity;
            const clampedLat = Math.max(bounds.minLat, Math.min(bounds.maxLat, lat));
            const clampedLng = Math.max(bounds.minLng, Math.min(bounds.maxLng, lng));
            return calcDistance(lat, lng, clampedLat, clampedLng);
        }
        function cacheRouteBounds(routeId, latlngs) {
            const b = computeBoundsFromLatLngs(latlngs);
            if (!b) return;
            routeBoundsCache[String(routeId)] = b;
        }
        function rebuildAllRoutesBounds() {
            allRoutesBounds = null;
            const vals = Object.values(routeBoundsCache);
            for (let i = 0; i < vals.length; i++) {
                allRoutesBounds = mergeBounds(allRoutesBounds, vals[i]);
            }
            if (!allRoutesBounds && allRoutes && allRoutes.length) {
                for (let i = 0; i < allRoutes.length; i++) {
                    const route = allRoutes[i];
                    const rb = computeBoundsFromLatLngs(route && route.waypoints ? route.waypoints : null);
                    if (!rb) continue;
                    routeBoundsCache[String(route.id)] = rb;
                    allRoutesBounds = mergeBounds(allRoutesBounds, rb);
                }
            }
        }
        function getRenderContext() {
            if (selectedRouteId) {
                const rb = routeBoundsCache[String(selectedRouteId)];
                if (rb) {
                    return {
                        mode: 'route',
                        routeId: String(selectedRouteId),
                        bounds: expandBoundsByMeters(rb, ROUTE_FOCUS_PAD_M)
                    };
                }
            }
            if (userLocation && userLocation.length === 2) {
                return {
                    mode: 'user',
                    center: [userLocation[0], userLocation[1]],
                    radiusM: USER_RENDER_RADIUS_M
                };
            }
            if (!allRoutesBounds) rebuildAllRoutesBounds();
            if (allRoutesBounds) {
                return {
                    mode: 'all',
                    bounds: expandBoundsByMeters(allRoutesBounds, ALL_ROUTES_PAD_M)
                };
            }
            return { mode: 'none' };
        }
        function getRenderContextKey(ctx) {
            if (!ctx) return 'none';
            if (ctx.mode === 'route') return `route:${ctx.routeId || ''}`;
            if (ctx.mode === 'user') return `user:${ctx.center ? `${ctx.center[0].toFixed(5)},${ctx.center[1].toFixed(5)}` : ''}`;
            if (ctx.mode === 'all' && ctx.bounds) {
                return `all:${ctx.bounds.minLat.toFixed(5)}:${ctx.bounds.minLng.toFixed(5)}:${ctx.bounds.maxLat.toFixed(5)}:${ctx.bounds.maxLng.toFixed(5)}`;
            }
            return 'none';
        }
        function isPointRenderableByContext(lat, lng, routeId, ctx = null) {
            const renderCtx = ctx || getRenderContext();
            if (!renderCtx || renderCtx.mode === 'none') return true;
            if (renderCtx.mode === 'route') {
                if (routeId != null && String(routeId) !== String(renderCtx.routeId)) return false;
                return isPointInsideBounds(lat, lng, renderCtx.bounds);
            }
            if (renderCtx.mode === 'user') {
                return calcDistance(lat, lng, renderCtx.center[0], renderCtx.center[1]) <= renderCtx.radiusM;
            }
            return isPointInsideBounds(lat, lng, renderCtx.bounds);
        }
        function shouldRenderRouteByContext(routeId, ctx = null) {
            const renderCtx = ctx || getRenderContext();
            if (!renderCtx || renderCtx.mode === 'none') return true;
            const rid = String(routeId);
            if (renderCtx.mode === 'route') return rid === String(renderCtx.routeId);
            const rb = routeBoundsCache[rid];
            if (!rb) return true;
            if (renderCtx.mode === 'user') {
                return distancePointToBoundsMeters(renderCtx.center[0], renderCtx.center[1], rb) <= renderCtx.radiusM;
            }
            return boundsIntersect(rb, renderCtx.bounds);
        }
        function ensureLayerVisibility(layer, visible) {
            if (!map || !layer) return;
            const has = map.hasLayer(layer);
            if (visible && !has) {
                try { map.addLayer(layer); } catch (e) {}
            } else if (!visible && has) {
                try { map.removeLayer(layer); } catch (e) {}
            }
        }
        function syncSpatialRendering() {
            if (!map) return;
            const ctx = getRenderContext();
            const routesVisible = !!visibleLayers.routes;
            for (let ri = 0; ri < allRoutes.length; ri++) {
                const route = allRoutes[ri];
                const rid = String(route.id);
                const showRoute = routesVisible && shouldRenderRouteByContext(rid, ctx);
                ensureLayerVisibility(routePolylines[rid], showRoute);
                ensureLayerVisibility(routePolylines[`${rid}-glow`], showRoute);
                if (showRoute && routePolylines[`${rid}-glow`] && routePolylines[`${rid}-glow`].bringToBack) {
                    try { routePolylines[`${rid}-glow`].bringToBack(); } catch (e) {}
                }
                const stopCount = route && route.waypoints ? route.waypoints.length : 0;
                for (let si = 0; si < stopCount; si++) {
                    ensureLayerVisibility(routePolylines[`${rid}-stop-${si}`], showRoute);
                }
            }
            const hostelsVisible = !!visibleLayers.hostels;
            Object.values(hostelMarkers).forEach((marker) => {
                if (!marker || !marker.getLatLng) return;
                const ll = marker.getLatLng();
                const show = hostelsVisible && isPointRenderableByContext(ll.lat, ll.lng, null, ctx);
                ensureLayerVisibility(marker, show);
            });
            const classesVisible = !!visibleLayers.classes;
            Object.values(classMarkers).forEach((marker) => {
                if (!marker || !marker.getLatLng) return;
                const ll = marker.getLatLng();
                const show = classesVisible && isPointRenderableByContext(ll.lat, ll.lng, null, ctx);
                ensureLayerVisibility(marker, show);
            });
            Object.entries(busMarkers).forEach(([busNum, marker]) => {
                if (!marker || !marker.getLatLng) return;
                const b = latestBuses[busNum];
                const rid = (b && b.routeId != null) ? b.routeId : busRouteMap[busNum];
                const ll = marker.getLatLng();
                const tracked = trackedBus && String(trackedBus) === String(busNum);
                const show = tracked || isPointRenderableByContext(ll.lat, ll.lng, rid, ctx);
                ensureLayerVisibility(marker, show);
                if (!show) removeBusTrail(busNum);
            });
        }
        function scheduleSpatialSync() {
            const now = Date.now();
            const gap = now - _lastSpatialSyncMs;
            if (gap < SPATIAL_SYNC_MIN_GAP_MS) {
                if (_spatialSyncTimer) return;
                _spatialSyncTimer = setTimeout(() => {
                    _spatialSyncTimer = null;
                    scheduleSpatialSync();
                }, Math.max(16, SPATIAL_SYNC_MIN_GAP_MS - gap));
                return;
            }
            if (_spatialSyncRaf) return;
            _spatialSyncRaf = requestAnimationFrame(() => {
                _spatialSyncRaf = null;
                _lastSpatialSyncMs = Date.now();
                syncSpatialRendering();
            });
        }
        function applyMapViewportForContext(force = false) {
            if (!map) return;
            const ctx = getRenderContext();
            let targetBounds = null;
            if (ctx.mode === 'route' || ctx.mode === 'all') {
                targetBounds = boundsToLeaflet(ctx.bounds);
            } else if (ctx.mode === 'user' && ctx.center) {
                const userBox = expandBoundsByMeters({
                    minLat: ctx.center[0],
                    maxLat: ctx.center[0],
                    minLng: ctx.center[1],
                    maxLng: ctx.center[1]
                }, ctx.radiusM || USER_RENDER_RADIUS_M);
                targetBounds = boundsToLeaflet(userBox);
            }
            if (!targetBounds || !targetBounds.isValid()) return;
            const ctxKey = getRenderContextKey(ctx);
            if (!force && _initialViewportApplied && _lastViewportContextKey === ctxKey) return;
            _lastViewportContextKey = ctxKey;
            const targetCenter = targetBounds.getCenter();
            const animate = !isLowPerfMode() && !document.hidden;
            const lockZoomToDefault = (ctx.mode === 'route') || !!trackedBus;
            if (!_initialViewportApplied && !force) {
                try {
                    map.setView(targetCenter, DEFAULT_TILE_ZOOM, { animate: false });
                } catch (e) {}
            } else if (lockZoomToDefault) {
                try {
                    map.setView(targetCenter, DEFAULT_TILE_ZOOM, {
                        animate,
                        duration: animate ? 0.28 : 0
                    });
                } catch (e) {}
            } else {
                try {
                    map.fitBounds(targetBounds, {
                        padding: [34, 34],
                        maxZoom: DEFAULT_TILE_ZOOM,
                        animate,
                        duration: animate ? 0.34 : 0
                    });
                    const fitZoom = map.getZoom();
                    if (Number.isFinite(fitZoom) && fitZoom < MIN_AUTO_FIT_ZOOM) {
                        map.setView(targetCenter, MIN_AUTO_FIT_ZOOM, { animate: false });
                    }
                } catch (e) {}
            }
            _initialViewportApplied = true;
        }

        const _flashTimes = {};
        const _opsValueCache = {};
        function flashElement(el, key = 'default', minGapMs = 700) {
            if (!el || isLowPerfMode()) return;
            const now = Date.now();
            if (_flashTimes[key] && (now - _flashTimes[key]) < minGapMs) return;
            _flashTimes[key] = now;
            el.classList.remove('ui-flash');
            void el.offsetWidth;
            el.classList.add('ui-flash');
            setTimeout(() => { try { el.classList.remove('ui-flash'); } catch(e) {} }, 340);
        }
        function queueBusUiRefresh(delayMs = 180) {
            if (_busUiRefreshTimer) return;
            _busUiRefreshTimer = setTimeout(() => {
                _busUiRefreshTimer = null;
                computeAndShowStudentETA(latestBuses);
                renderRouteBusByETA();
                updateOperationalTiles();
            }, delayMs);
        }
        function decorateEtaHtml(html) {
            if (typeof html !== 'string') return html;
            if (html.includes('eta-spinner') || html.includes('eta-rotor') || html === '--') return html;
            const plain = html.replace(/<[^>]*>/g, '').trim();
            if (!plain || plain === '--') return html;
            if (plain === 'Reached' || plain === 'At Start' || plain === 'At Stop' || plain === 'Waiting') return html;
            if (/updating/i.test(plain)) return html;
            return `${html} <span class="eta-rotor">&#8635;</span>`;
        }
        function getCompassDirection(from, to) {
            const bearing = calcBearing(from, to);
            const dirs = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
            return dirs[Math.round(bearing / 45) % 8];
        }
        function getFreshBusEntries(busesData) {
            const nowMs = Date.now();
            return Object.entries(busesData || {}).filter(([busNum, b]) => {
                if (!b || typeof b.lat !== 'number' || typeof b.lng !== 'number') return false;
                const t = b.lastUpdate ? parseIsoTime(b.lastUpdate) : null;
                const lastSeen = busLastSeen[busNum] || 0;
                const effective = Math.max(lastSeen, t || 0);
                return !!effective && (nowMs - effective) <= OFFLINE_MS;
            });
        }
        function setOpsValue(id, text) {
            const el = document.getElementById(id);
            if (!el) return;
            if (_opsValueCache[id] === text) return;
            _opsValueCache[id] = text;
            el.textContent = text;
            const tile = el.closest('.ops-tile');
            if (tile) flashElement(tile, `ops_${id}`, 1200);
        }
        function getLeaveOffsetMinutes() {
            const selectEl = _dom.leaveTimeSelect || document.getElementById('leaveTimeSelect');
            if (!selectEl) return 0;
            const selected = String(selectEl.value || '0');
            if (selected !== 'custom') {
                const n = Number(selected);
                return Number.isFinite(n) ? Math.max(0, n) : 0;
            }
            const customEl = _dom.leaveTimeCustom || document.getElementById('leaveTimeCustom');
            if (!customEl || !customEl.value) return 0;
            const [hh, mm] = String(customEl.value).split(':').map(v => Number(v));
            if (!Number.isFinite(hh) || !Number.isFinite(mm)) return 0;
            const now = new Date();
            const target = new Date(now);
            target.setHours(hh, mm, 0, 0);
            let diffMs = target.getTime() - now.getTime();
            if (diffMs < 0) diffMs += 24 * 60 * 60 * 1000;
            return Math.max(0, Math.round(diffMs / 60000));
        }
        function applyLeaveOffsetToEta(etaSec) {
            if (!Number.isFinite(etaSec) || etaSec < 0) return etaSec;
            return etaSec + (getLeaveOffsetMinutes() * 60);
        }
        function estimateTransportAvailability(activeCount) {
            if (activeCount >= 8) return 'HIGH';
            if (activeCount >= 4) return 'NORMAL';
            return 'LOW';
        }
        function estimateTrafficLevel(busNum, statusText) {
            const speed = Number(busSpeedCache[busNum]);
            const moved = Number(busMovedCache[busNum]);
            if (statusText === 'Idle' || statusText === 'Waiting for Update') return 'HIGH';
            if ((Number.isFinite(speed) && speed < 10) || (Number.isFinite(moved) && moved < 8)) return 'HIGH';
            if ((Number.isFinite(speed) && speed < 20) || (Number.isFinite(moved) && moved < 18)) return 'MED';
            return 'LOW';
        }
        function estimateDelayLevel(busNum, etaSecRaw) {
            const now = Date.now();
            const etaSec = Number(etaSecRaw);
            if (!Number.isFinite(etaSec) || etaSec < 0) return 'NONE';
            const prev = busEtaTrendCache[busNum];
            busEtaTrendCache[busNum] = { etaSec, ts: now };
            if (!prev || (now - prev.ts) < ETA_TREND_MIN_INTERVAL_MS) return 'NONE';
            const delta = etaSec - prev.etaSec;
            if (delta > 55) return 'MAJOR';
            if (delta > 18) return 'MINOR';
            return 'NONE';
        }
        function estimateCrowdLevel() {
            const viewers = Number(approxViewerCount) || 1;
            if (viewers >= 5) return 'HIGH';
            if (viewers >= 3) return 'NORMAL';
            return 'LOW';
        }
        function statusLevelClass(type, level) {
            const lv = String(level || '').toUpperCase();
            if (type === 'traffic') return lv === 'LOW' ? 'green' : (lv === 'MED' ? 'yellow' : 'red');
            if (type === 'delay') return lv === 'NONE' ? 'green' : (lv === 'MINOR' ? 'yellow' : 'red');
            if (type === 'crowd') return lv === 'LOW' ? 'green' : (lv === 'NORMAL' ? 'yellow' : 'red');
            return 'yellow';
        }
        function formatEtaMinutes(seconds) {
            if (!Number.isFinite(seconds)) return '--';
            const mins = Math.max(0, Math.round(seconds / 60));
            if (mins <= 1) return '<1 min';
            return `${mins} min`;
        }
        function getReferenceLocation() {
            if (userLocation && userLocation.length === 2) return [Number(userLocation[0]), Number(userLocation[1])];
            if (map) {
                const c = map.getCenter();
                return [c.lat, c.lng];
            }
            return null;
        }
        function getNearestStopForRoute(route, point) {
            if (!route || !route.waypoints || !route.waypoints.length || !point) return { stop: null, idx: -1, dist: Infinity };
            let bestDist = Infinity;
            let bestIdx = -1;
            for (let i = 0; i < route.waypoints.length; i++) {
                const wp = route.waypoints[i];
                const d = calcDistance(point[0], point[1], wp[0], wp[1]);
                if (d < bestDist) { bestDist = d; bestIdx = i; }
            }
            return { stop: bestIdx >= 0 ? route.waypoints[bestIdx] : null, idx: bestIdx, dist: bestDist };
        }
        function refreshAssistantFromField() {
            const fromEl = _dom.fromInput || document.getElementById('fromInput');
            if (!fromEl || assistantFromEdited) return;
            const route = selectedRouteId ? getRouteById(selectedRouteId) : null;
            const ref = getReferenceLocation();
            if (userLocation && userLocation.length === 2) {
                fromEl.value = 'Nearest stop';
                fromEl.title = `Nearest stop: My location (${userLocation[0].toFixed(4)}, ${userLocation[1].toFixed(4)})`;
                return;
            }
            if (route && ref) {
                const nearest = getNearestStopForRoute(route, ref);
                if (nearest.stop) {
                    const stopName = (route.stops && route.stops[nearest.idx]) || `Stop ${nearest.idx + 1}`;
                    fromEl.value = 'Nearest stop';
                    fromEl.title = `Nearest stop: ${stopName} (${Math.round(nearest.dist)}m away)`;
                    return;
                }
            }
            if (ref) {
                fromEl.value = 'Nearest stop';
                fromEl.title = `Nearest stop: Map center (${ref[0].toFixed(4)}, ${ref[1].toFixed(4)})`;
                return;
            }
            fromEl.value = 'Nearest stop';
            fromEl.title = 'Detecting nearest stop...';
        }
        function normalizeQuery(query) {
            return String(query || '').trim().toLowerCase();
        }
        function getAssistantSuggestionLabels(source = 'to', filterText = '') {
            const q = normalizeQuery(filterText);
            const out = [];
            const seen = new Set();
            const push = (label) => {
                const raw = String(label || '').trim();
                if (!raw) return;
                const key = raw.toLowerCase();
                if (seen.has(key)) return;
                if (q && !key.includes(q)) return;
                seen.add(key);
                out.push(raw);
            };

            if (source === 'from') {
                if (userLocation && userLocation.length === 2) push('My location');
                const route = selectedRouteId ? getRouteById(selectedRouteId) : null;
                const ref = getReferenceLocation();
                if (route && ref) {
                    const nearest = getNearestStopForRoute(route, ref);
                    const nearestName = (route.stops && nearest.idx >= 0) ? route.stops[nearest.idx] : '';
                    push(nearestName);
                    if (Array.isArray(route.stops)) route.stops.slice(0, 10).forEach(push);
                }
                push('Map center');
            } else {
                Object.values(DESTINATION_PRESETS).forEach((item) => push(item && item.label));
                const route = selectedRouteId ? getRouteById(selectedRouteId) : null;
                if (route && Array.isArray(route.stops)) route.stops.slice(0, 14).forEach(push);
                Object.values(hostelMarkers || {}).forEach((marker) => push(marker && marker.options && marker.options.title));
                Object.values(classMarkers || {}).forEach((marker) => push(marker && marker.options && marker.options.title));
            }
            return out.slice(0, 10);
        }
        function closeAssistantSuggestions() {
            const list = _dom.searchSuggestions || document.getElementById('searchSuggestions');
            if (!list) return;
            list.hidden = true;
            list.innerHTML = '';
            list.removeAttribute('data-source');
        }
        function openAssistantSuggestions(source = 'to', filterText = '') {
            const list = _dom.searchSuggestions || document.getElementById('searchSuggestions');
            if (!list) return;
            const items = getAssistantSuggestionLabels(source, filterText);
            if (!items.length) { closeAssistantSuggestions(); return; }
            const esc = (s) => String(s)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
            list.setAttribute('data-source', source);
            list.innerHTML = items.map((label) => `<div class="suggestion-item" data-suggest="${esc(label)}">${esc(label)}</div>`).join('');
            list.hidden = false;
        }
        function applyAssistantSuggestion(label, source = 'to') {
            if (!label) return;
            const fromInput = _dom.fromInput || document.getElementById('fromInput');
            const toInput = _dom.toInput || document.getElementById('toInput');
            if (source === 'from') {
                if (fromInput) {
                    setFromEditMode(true, { keepValue: true });
                    const typed = String(label || '').trim();
                    fromInput.value = typed;
                    fromInput.title = `Nearest stop: ${typed}`;
                }
            } else if (toInput) {
                toInput.value = label;
                triggerAssistantSearch(true);
            }
            closeAssistantSuggestions();
        }
        function syncLeaveNowButtonLabel() {
            const btn = _dom.leaveNowBtn || document.getElementById('leaveNowBtn');
            const selectEl = _dom.leaveTimeSelect || document.getElementById('leaveTimeSelect');
            if (!btn || !selectEl) return;
            const val = String(selectEl.value || '0');
            if (val === '0') btn.textContent = 'Leave now';
            else if (val === 'custom') btn.textContent = 'Custom';
            else btn.textContent = `+${val} min`;
        }
        function syncLeaveDropdownActiveOption() {
            const selectEl = _dom.leaveTimeSelect || document.getElementById('leaveTimeSelect');
            const dd = _dom.leaveDropdown || document.getElementById('leaveDropdown');
            if (!selectEl || !dd) return;
            const selected = String(selectEl.value || '0');
            dd.querySelectorAll('.leave-option[data-value]').forEach((opt) => {
                const isActive = String(opt.getAttribute('data-value') || '') === selected;
                opt.classList.toggle('active', isActive);
            });
        }
        function applyLeaveSelection(nextValue) {
            const selectEl = _dom.leaveTimeSelect || document.getElementById('leaveTimeSelect');
            if (!selectEl) return;
            const value = String(nextValue || '0');
            const hasValue = Array.from(selectEl.options || []).some((opt) => String(opt.value) === value);
            if (!hasValue) return;
            const changed = String(selectEl.value || '') !== value;
            selectEl.value = value;
            if (changed) {
                selectEl.dispatchEvent(new Event('change', { bubbles: true }));
            } else {
                const leaveCustom = _dom.leaveTimeCustom || document.getElementById('leaveTimeCustom');
                if (leaveCustom) leaveCustom.style.display = value === 'custom' ? 'block' : 'none';
                syncLeaveNowButtonLabel();
            }
            syncLeaveDropdownActiveOption();
        }
        function closeLeaveDropdown() {
            const btn = _dom.leaveNowBtn || document.getElementById('leaveNowBtn');
            const dd = _dom.leaveDropdown || document.getElementById('leaveDropdown');
            if (!dd) return;
            dd.hidden = true;
            if (btn) btn.setAttribute('aria-expanded', 'false');
        }
        function openLeaveDropdown() {
            const btn = _dom.leaveNowBtn || document.getElementById('leaveNowBtn');
            const dd = _dom.leaveDropdown || document.getElementById('leaveDropdown');
            if (!dd) return;
            syncLeaveDropdownActiveOption();
            dd.hidden = false;
            if (btn) btn.setAttribute('aria-expanded', 'true');
        }
        function pulseRecommendedTransportCard(maxAttempts = 8) {
            const list = _dom.routeBusList || document.getElementById('routeBusList');
            if (!list) return;
            const card = list.querySelector('.route-result-card.recommended');
            if (card) {
                card.classList.remove('ai-recommended-active');
                void card.offsetWidth;
                card.classList.add('ai-recommended-active');
                setTimeout(() => { try { card.classList.remove('ai-recommended-active'); } catch (e) {} }, 1200);
                try { card.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' }); } catch (e) {}
                return;
            }
            if (maxAttempts <= 0) return;
            setTimeout(() => pulseRecommendedTransportCard(maxAttempts - 1), 180);
        }
        function resolveDestinationPoint(query) {
            const q = normalizeQuery(query);
            if (!q) return null;
            const preset = Object.entries(DESTINATION_PRESETS).find(([k]) => q === k || q.includes(k));
            if (preset) return { point: [preset[1].lat, preset[1].lng], label: preset[1].label };

            let best = null;
            Object.values(hostelMarkers).forEach((marker) => {
                if (!marker || !marker.getLatLng) return;
                const name = String((marker.options && marker.options.title) || '').toLowerCase();
                if (!name || (!name.includes(q) && !q.includes(name))) return;
                const ll = marker.getLatLng();
                best = { point: [ll.lat, ll.lng], label: marker.options.title || query };
            });
            if (best) return best;
            Object.values(classMarkers).forEach((marker) => {
                if (!marker || !marker.getLatLng) return;
                const name = String((marker.options && marker.options.title) || '').toLowerCase();
                if (!name || (!name.includes(q) && !q.includes(name))) return;
                const ll = marker.getLatLng();
                best = { point: [ll.lat, ll.lng], label: marker.options.title || query };
            });
            if (best) return best;

            for (let ri = 0; ri < allRoutes.length; ri++) {
                const route = allRoutes[ri];
                if (!route || !route.waypoints) continue;
                for (let si = 0; si < route.waypoints.length; si++) {
                    const stopName = String((route.stops && route.stops[si]) || `Stop ${si + 1}`).toLowerCase();
                    if (!stopName.includes(q) && !q.includes(stopName)) continue;
                    const stop = route.waypoints[si];
                    return { point: [stop[0], stop[1]], label: (route.stops && route.stops[si]) || query };
                }
            }

            const ref = getReferenceLocation();
            if (ref) return { point: ref, label: query };
            return null;
        }
        function clearAssistantPreviewLine() {
            if (assistantPreviewAnimRaf) {
                try { cancelAnimationFrame(assistantPreviewAnimRaf); } catch (e) {}
                assistantPreviewAnimRaf = null;
            }
            if (assistantPreviewLine) {
                try { map.removeLayer(assistantPreviewLine); } catch (e) {}
                assistantPreviewLine = null;
            }
        }
        function animateAssistantPreview(routeId) {
            if (!map) return;
            const route = getRouteById(routeId);
            if (!route) return;
            const coords = routeCoordsCache[String(route.id)] || route.waypoints || [];
            if (!coords || coords.length < 2) return;
            clearAssistantPreviewLine();
            assistantPreviewLine = L.polyline([], {
                color: route.color || '#8b7cff',
                weight: 6,
                opacity: 0.85,
                dashArray: '8, 8',
                lineCap: 'round',
                lineJoin: 'round',
                interactive: false
            }).addTo(map);
            const start = performance.now();
            const duration = 700;
            const frame = (now) => {
                const t = Math.min(1, (now - start) / duration);
                const drawCount = Math.max(2, Math.floor(coords.length * t));
                try { assistantPreviewLine.setLatLngs(coords.slice(0, drawCount)); } catch (e) {}
                if (t < 1) {
                    assistantPreviewAnimRaf = requestAnimationFrame(frame);
                } else {
                    assistantPreviewAnimRaf = null;
                    setTimeout(() => {
                        clearAssistantPreviewLine();
                    }, 420);
                }
            };
            assistantPreviewAnimRaf = requestAnimationFrame(frame);
        }
        function computeRoutePlanForDestination(route, destinationPoint, leaveOffsetMin = 0) {
            if (!route || !destinationPoint || !route.waypoints || route.waypoints.length < 2) return null;
            const nowMs = Date.now();
            const ref = getReferenceLocation();
            const pickupMeta = getNearestStopForRoute(route, ref);
            const dropMeta = getNearestStopForRoute(route, destinationPoint);
            if (!pickupMeta.stop || !dropMeta.stop) return null;
            let bestBus = null;
            let bestWaitSec = Infinity;
            Object.entries(latestBuses).forEach(([busNum, b]) => {
                if (!b || typeof b.lat !== 'number' || typeof b.lng !== 'number') return;
                const rid = (b.routeId != null) ? String(b.routeId) : (busRouteMap[busNum] != null ? String(busRouteMap[busNum]) : null);
                if (rid !== String(route.id)) return;
                const t = b.lastUpdate ? parseIsoTime(b.lastUpdate) : null;
                const lastSeen = busLastSeen[busNum] || 0;
                const effectiveTime = Math.max(lastSeen, t || 0);
                if (!effectiveTime || (nowMs - effectiveTime) > OFFLINE_MS) return;
                const distM = getRouteDistanceBetween(rid, [b.lat, b.lng], pickupMeta.stop) || calcDistance(b.lat, b.lng, pickupMeta.stop[0], pickupMeta.stop[1]);
                const speed = Math.max(8, Math.min(45, busSpeedCache[busNum] || 14));
                const waitSec = Math.max(0, Math.ceil(((distM / 1000) / speed) * 3600));
                if (waitSec < bestWaitSec) {
                    bestWaitSec = waitSec;
                    bestBus = { busNum, data: b, status: busStatusCache[busNum] || determineStatus(busNum, [b.lat, b.lng], b.lastUpdate) };
                }
            });
            const walkStartSec = ref ? Math.ceil(pickupMeta.dist / WALK_SPEED_MPS) : 0;
            const walkEndSec = Math.ceil(dropMeta.dist / WALK_SPEED_MPS);
            const rideDistM = getRouteDistanceBetween(String(route.id), pickupMeta.stop, dropMeta.stop)
                || calcDistance(pickupMeta.stop[0], pickupMeta.stop[1], dropMeta.stop[0], dropMeta.stop[1]);
            const rideSec = Math.max(120, Math.ceil(((rideDistM / 1000) / RIDE_SPEED_KMH) * 3600));
            const waitSecSafe = Number.isFinite(bestWaitSec) ? bestWaitSec : (8 * 60);
            const leaveOffsetSec = Math.max(0, leaveOffsetMin) * 60;
            const totalSec = leaveOffsetSec + walkStartSec + waitSecSafe + rideSec + walkEndSec;
            return {
                route,
                pickupMeta,
                dropMeta,
                bus: bestBus,
                waitSec: waitSecSafe,
                rideSec,
                walkStartSec,
                walkEndSec,
                totalSec
            };
        }
        function findBestRouteForDestination(destinationPoint) {
            const leaveOffset = getLeaveOffsetMinutes();
            const plans = [];
            for (let i = 0; i < allRoutes.length; i++) {
                const plan = computeRoutePlanForDestination(allRoutes[i], destinationPoint, leaveOffset);
                if (!plan) continue;
                plans.push(plan);
            }
            plans.sort((a, b) => a.totalSec - b.totalSec);
            return plans;
        }
        function setAssistantStatus(text, active = false) {
            const statusEl = _dom.assistantSearchStatus || document.getElementById('assistantSearchStatus');
            if (!statusEl) return;
            statusEl.textContent = text || '';
            statusEl.classList.toggle('active', !!active);
        }
        function triggerAssistantSearch(immediate = false) {
            const input = _dom.toInput || document.getElementById('toInput');
            if (!input) return;
            if (immediate) closeAssistantSuggestions();
            const q = String(input.value || '').trim();
            if (!q) {
                assistantDestinationPoint = null;
                assistantDestinationLabel = '';
                clearAssistantPreviewLine();
                setAssistantStatus('', false);
                return;
            }
            const resolved = resolveDestinationPoint(q);
            if (!resolved || !resolved.point) {
                setAssistantStatus('Finding best route...', true);
                return;
            }
            assistantDestinationPoint = resolved.point;
            assistantDestinationLabel = resolved.label || q;
            const plans = findBestRouteForDestination(assistantDestinationPoint);
            if (!plans.length) {
                setAssistantStatus('No route found yet. Try another destination.', true);
                return;
            }
            const bestPlan = plans[0];
            const panel = _dom.assistantPanel || document.getElementById('assistantPanel');
            if (panel) panel.classList.add('searching');
            setAssistantStatus('Finding best route...', true);
            animateAssistantPreview(bestPlan.route.id);
            if (assistantSearchAnimTimerId) {
                try { clearTimeout(assistantSearchAnimTimerId); } catch (e) {}
                assistantSearchAnimTimerId = null;
            }
            const animDelay = immediate ? 700 : 680;
            assistantSearchAnimTimerId = setTimeout(() => {
                assistantSearchAnimTimerId = null;
                selectRoute(bestPlan.route.id);
                if (bestPlan.bus && bestPlan.bus.busNum) {
                    setTrackedBus(String(bestPlan.bus.busNum));
                }
                if (panel) panel.classList.remove('searching');
                setAssistantStatus(`Fastest: ${bestPlan.route.name} - ${formatEtaMinutes(bestPlan.totalSec)}`, true);
            }, animDelay);
        }
        function handleDestinationInputDebounced() {
            if (assistantSearchDebounceId) {
                try { clearTimeout(assistantSearchDebounceId); } catch (e) {}
                assistantSearchDebounceId = null;
            }
            assistantSearchDebounceId = setTimeout(() => {
                assistantSearchDebounceId = null;
                triggerAssistantSearch(false);
            }, 220);
        }
        function setFromEditMode(enable, options = {}) {
            const input = _dom.fromInput || document.getElementById('fromInput');
            if (!input) return;
            const keepValue = !!(options && options.keepValue);
            assistantFromEdited = !!enable;
            input.readOnly = !enable;
            if (enable) {
                input.placeholder = 'Type start stop...';
                if (!keepValue && String(input.value || '').trim().toLowerCase() === 'nearest stop') {
                    input.value = '';
                }
                try { input.focus({ preventScroll: true }); input.select(); } catch (e) {
                    try { input.focus(); input.select(); } catch (err) {}
                }
            } else {
                input.placeholder = 'Detecting nearest stop...';
                refreshAssistantFromField();
            }
        }
        function followNearestTransport() {
            if (!map) return;
            const ref = getReferenceLocation();
            if (!ref) return;
            const freshEntries = getFreshBusEntries(latestBuses);
            if (!freshEntries.length) {
                setAssistantStatus('No active transport to follow.', true);
                return;
            }
            let bestBus = null;
            let bestDist = Infinity;
            freshEntries.forEach(([busNum, b]) => {
                if (!b || typeof b.lat !== 'number' || typeof b.lng !== 'number') return;
                const d = calcDistance(ref[0], ref[1], b.lat, b.lng);
                if (d < bestDist) { bestDist = d; bestBus = { busNum, pos: [b.lat, b.lng] }; }
            });
            if (!bestBus) return;
            followEnabled = true;
            setTrackedBus(String(bestBus.busNum));
            map.setView(bestBus.pos, Math.max(DEFAULT_TILE_ZOOM, map.getZoom()), { animate: true, duration: 0.35 });
            setAssistantStatus(`Following Transport ${bestBus.busNum} (${Math.round(bestDist)}m away)`, true);
            setTimeout(() => {
                if (_dom.assistantSearchStatus && !_dom.assistantPanel?.classList.contains('searching')) {
                    _dom.assistantSearchStatus.classList.remove('active');
                }
            }, 2200);
        }
        function refreshViewerPresence(removeSelf = false) {
            const now = Date.now();
            try {
                const raw = localStorage.getItem(VIEWER_PRESENCE_KEY);
                const parsed = raw ? JSON.parse(raw) : {};
                const next = {};
                Object.entries(parsed || {}).forEach(([id, ts]) => {
                    const n = Number(ts);
                    if (Number.isFinite(n) && (now - n) < VIEWER_STALE_MS) next[id] = n;
                });
                if (!removeSelf) next[VIEWER_ID] = now;
                else delete next[VIEWER_ID];
                localStorage.setItem(VIEWER_PRESENCE_KEY, JSON.stringify(next));
                const count = Object.keys(next).length;
                approxViewerCount = Math.max(1, count || 1);
            } catch (e) {
                approxViewerCount = 1;
            }
        }
        function sendStudentPresence(active = true, useKeepalive = false) {
            if (studentPresenceInFlight && active) return;
            const payload = JSON.stringify({ clientId: VIEWER_ID, active: !!active });
            if (!active && navigator.sendBeacon) {
                try {
                    const blob = new Blob([payload], { type: 'application/json' });
                    navigator.sendBeacon('/api/presence/student', blob);
                    return;
                } catch (e) {}
            }
            if (active) studentPresenceInFlight = true;
            fetch('/api/presence/student', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: payload,
                keepalive: !!useKeepalive
            }).catch(() => {}).finally(() => {
                if (active) studentPresenceInFlight = false;
            });
        }
        function startViewerPresenceTracking() {
            refreshViewerPresence(false);
            sendStudentPresence(true);
            if (viewerPresenceTimerId) {
                try { clearInterval(viewerPresenceTimerId); } catch (e) {}
                viewerPresenceTimerId = null;
            }
            viewerPresenceTimerId = setInterval(() => {
                refreshViewerPresence(false);
                sendStudentPresence(true);
            }, Math.max(VIEWER_HEARTBEAT_MS, STUDENT_SERVER_PRESENCE_HEARTBEAT_MS));
        }
        function bindAssistantInteractions() {
            const fromInput = _dom.fromInput || document.getElementById('fromInput');
            const toInput = _dom.toInput || document.getElementById('toInput');
            const originChip = _dom.originChip || document.getElementById('originChip');
            const suggestionsEl = _dom.searchSuggestions || document.getElementById('searchSuggestions');
            const askAiBtn = _dom.askAiBtn || document.getElementById('askAiBtn');
            const assistantPanel = _dom.assistantPanel || document.getElementById('assistantPanel');
            const chipsWrap = _dom.destinationChips || document.getElementById('destinationChips');
            const leaveSel = _dom.leaveTimeSelect || document.getElementById('leaveTimeSelect');
            const leaveCustom = _dom.leaveTimeCustom || document.getElementById('leaveTimeCustom');
            const leaveNowBtn = _dom.leaveNowBtn || document.getElementById('leaveNowBtn');
            const leaveDropdown = _dom.leaveDropdown || document.getElementById('leaveDropdown');
            const followBtn = _dom.followNearestBtn || document.getElementById('followNearestBtn');

            syncLeaveNowButtonLabel();
            syncLeaveDropdownActiveOption();

            if (fromInput && !fromInput.dataset.bound) {
                fromInput.dataset.bound = '1';
                fromInput.addEventListener('click', () => {
                    if (fromInput.readOnly) setFromEditMode(true);
                    openAssistantSuggestions('from', fromInput.readOnly ? '' : (fromInput.value || ''));
                });
                fromInput.addEventListener('focus', () => {
                    if (!fromInput.readOnly) openAssistantSuggestions('from', fromInput.value || '');
                });
                fromInput.addEventListener('input', () => {
                    if (!fromInput.readOnly) openAssistantSuggestions('from', fromInput.value || '');
                });
                fromInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        if (fromInput.readOnly) {
                            setFromEditMode(true);
                            openAssistantSuggestions('from', '');
                            return;
                        }
                        const typed = String(fromInput.value || '').trim();
                        if (!typed) {
                            setFromEditMode(false);
                            closeAssistantSuggestions();
                            return;
                        }
                        fromInput.value = typed;
                        fromInput.title = `Nearest stop: ${typed}`;
                        closeAssistantSuggestions();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        setFromEditMode(false);
                        closeAssistantSuggestions();
                    }
                });
                fromInput.addEventListener('blur', () => {
                    if (assistantSuggestionCloseTimerId) {
                        try { clearTimeout(assistantSuggestionCloseTimerId); } catch (e) {}
                    }
                    assistantSuggestionCloseTimerId = setTimeout(() => {
                        assistantSuggestionCloseTimerId = null;
                        closeAssistantSuggestions();
                    }, 120);
                    if (!fromInput.readOnly) {
                        const typed = String(fromInput.value || '').trim();
                        if (!typed) {
                            setFromEditMode(false);
                        } else {
                            fromInput.value = typed;
                            fromInput.title = `Nearest stop: ${typed}`;
                        }
                    }
                });
            }
            if (originChip && !originChip.dataset.bound) {
                originChip.dataset.bound = '1';
                originChip.addEventListener('click', () => {
                    if (fromInput && fromInput.readOnly) setFromEditMode(true);
                    openAssistantSuggestions('from', (fromInput && !fromInput.readOnly) ? (fromInput.value || '') : '');
                });
                originChip.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        if (fromInput && fromInput.readOnly) setFromEditMode(true);
                        openAssistantSuggestions('from', (fromInput && !fromInput.readOnly) ? (fromInput.value || '') : '');
                    } else if (e.key === 'Escape') {
                        setFromEditMode(false);
                        closeAssistantSuggestions();
                    }
                });
            }
            if (toInput && !toInput.dataset.bound) {
                toInput.dataset.bound = '1';
                toInput.addEventListener('input', () => {
                    handleDestinationInputDebounced();
                    openAssistantSuggestions('to', toInput.value || '');
                });
                toInput.addEventListener('click', () => openAssistantSuggestions('to', toInput.value || ''));
                toInput.addEventListener('focus', () => openAssistantSuggestions('to', toInput.value || ''));
                toInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        triggerAssistantSearch(true);
                        closeAssistantSuggestions();
                    } else if (e.key === 'Escape') {
                        closeAssistantSuggestions();
                    }
                });
            }
            if (suggestionsEl && !suggestionsEl.dataset.bound) {
                suggestionsEl.dataset.bound = '1';
                suggestionsEl.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                });
                suggestionsEl.addEventListener('click', (e) => {
                    const item = e.target && e.target.closest ? e.target.closest('.suggestion-item[data-suggest]') : null;
                    if (!item) return;
                    const value = String(item.getAttribute('data-suggest') || '');
                    const source = String(suggestionsEl.getAttribute('data-source') || 'to');
                    applyAssistantSuggestion(value, source);
                });
            }
            if (leaveNowBtn && !leaveNowBtn.dataset.bound) {
                leaveNowBtn.dataset.bound = '1';
                leaveNowBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (!leaveDropdown) return;
                    if (leaveDropdown.hidden) openLeaveDropdown();
                    else closeLeaveDropdown();
                });
                leaveNowBtn.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        closeLeaveDropdown();
                    }
                });
            }
            if (leaveDropdown && !leaveDropdown.dataset.bound) {
                leaveDropdown.dataset.bound = '1';
                leaveDropdown.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                });
                leaveDropdown.addEventListener('click', (e) => {
                    const option = e.target && e.target.closest ? e.target.closest('.leave-option[data-value]') : null;
                    if (!option) return;
                    const nextValue = String(option.getAttribute('data-value') || '0');
                    applyLeaveSelection(nextValue);
                    if (nextValue === 'custom') {
                        if (leaveCustom) {
                            leaveCustom.style.display = 'block';
                            try { leaveCustom.focus({ preventScroll: true }); } catch (err) { leaveCustom.focus(); }
                        }
                        openLeaveDropdown();
                    } else {
                        closeLeaveDropdown();
                    }
                });
            }
            if (askAiBtn && !askAiBtn.dataset.bound) {
                askAiBtn.dataset.bound = '1';
                askAiBtn.addEventListener('click', () => {
                    askAiBtn.classList.remove('ai-active');
                    void askAiBtn.offsetWidth;
                    askAiBtn.classList.add('ai-active');
                    setTimeout(() => { try { askAiBtn.classList.remove('ai-active'); } catch (e) {} }, 1250);
                    triggerAssistantSearch(true);
                    pulseRecommendedTransportCard(10);
                });
            }
            if (assistantPanel && !assistantPanel.dataset.suggestBound) {
                assistantPanel.dataset.suggestBound = '1';
                const closeFloatingPanelsOnOutside = (target) => {
                    if (assistantPanel.contains(target)) return;
                    closeAssistantSuggestions();
                    closeLeaveDropdown();
                };
                document.addEventListener('pointerdown', (e) => {
                    closeFloatingPanelsOnOutside(e.target);
                }, true);
                document.addEventListener('click', (e) => {
                    closeFloatingPanelsOnOutside(e.target);
                });
                document.addEventListener('keydown', (e) => {
                    if (e.key !== 'Escape') return;
                    closeAssistantSuggestions();
                    closeLeaveDropdown();
                });
            }
            if (chipsWrap && !chipsWrap.dataset.bound) {
                chipsWrap.dataset.bound = '1';
                chipsWrap.addEventListener('click', (e) => {
                    const btn = e.target && e.target.closest ? e.target.closest('button[data-dest]') : null;
                    if (!btn) return;
                    if (toInput) toInput.value = btn.getAttribute('data-dest') || '';
                    triggerAssistantSearch(true);
                });
            }
            if (leaveSel && !leaveSel.dataset.bound) {
                leaveSel.dataset.bound = '1';
                leaveSel.addEventListener('change', () => {
                    const isCustom = leaveSel.value === 'custom';
                    if (leaveCustom) leaveCustom.style.display = isCustom ? 'block' : 'none';
                    syncLeaveNowButtonLabel();
                    syncLeaveDropdownActiveOption();
                    computeAndShowStudentETA(latestBuses);
                    renderRouteBusByETA();
                    updateOperationalTiles();
                    if ((_dom.toInput || document.getElementById('toInput'))?.value) triggerAssistantSearch(false);
                });
            }
            if (leaveCustom && !leaveCustom.dataset.bound) {
                leaveCustom.dataset.bound = '1';
                leaveCustom.addEventListener('change', () => {
                    computeAndShowStudentETA(latestBuses);
                    renderRouteBusByETA();
                    updateOperationalTiles();
                    if ((_dom.toInput || document.getElementById('toInput'))?.value) triggerAssistantSearch(false);
                });
                leaveCustom.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') closeLeaveDropdown();
                    if (e.key === 'Enter') closeLeaveDropdown();
                });
            }
            if (followBtn && !followBtn.dataset.bound) {
                followBtn.dataset.bound = '1';
                followBtn.addEventListener('click', followNearestTransport);
            }

            window.addEventListener('storage', (e) => {
                if (e.key !== VIEWER_PRESENCE_KEY) return;
                refreshViewerPresence(false);
            });
            refreshAssistantFromField();
            startViewerPresenceTracking();
        }
        function updateOperationalTiles() {
            if (!_dom.opsNextBus || !_dom.opsDemand || !_dom.opsNearestStop || !_dom.opsRouteHealth || !_dom.opsSystemStatus) return;
            const freshEntries = getFreshBusEntries(latestBuses);
            const activeCount = freshEntries.length;

            const demand = activeCount >= 8 ? 'HIGH' : (activeCount >= 4 ? 'MEDIUM' : 'LOW');
            setOpsValue('opsDemand', `Campus transport demand: ${demand}`);
            if (_dom.opsAvailability) setOpsValue('opsAvailability', estimateTransportAvailability(activeCount));
            refreshAssistantFromField();

            const route = selectedRouteId ? getRouteById(selectedRouteId) : (allRoutes && allRoutes.length ? allRoutes[0] : null);
            const routeLabel = route ? route.name : 'KP14';
            const ref = (userLocation && userLocation.length === 2) ? userLocation : (map ? [map.getCenter().lat, map.getCenter().lng] : null);

            let nearestStop = null;
            let nearestStopIdx = 0;
            let nearestDist = Infinity;
            if (route && route.waypoints && route.waypoints.length > 0) {
                if (ref) {
                    route.waypoints.forEach((wp, idx) => {
                        const d = calcDistance(ref[0], ref[1], wp[0], wp[1]);
                        if (d < nearestDist) { nearestDist = d; nearestStop = wp; nearestStopIdx = idx; }
                    });
                } else {
                    nearestStop = route.waypoints[0];
                    nearestStopIdx = 0;
                }
            }

            let nextBusText = `Next bus to ${routeLabel} in ~--`;
            if (route && nearestStop) {
                let bestEtaSec = Infinity;
                for (const [busNum, b] of freshEntries) {
                    const rid = (b.routeId != null) ? String(b.routeId) : (busRouteMap[busNum] != null ? String(busRouteMap[busNum]) : null);
                    if (rid !== String(route.id)) continue;
                    const distM = getRouteDistanceBetween(rid, [b.lat, b.lng], nearestStop) || calcDistance(b.lat, b.lng, nearestStop[0], nearestStop[1]);
                    const dynKmh = Math.max(10, Math.min(46, busSpeedCache[busNum] || 16));
                    const etaSec = applyLeaveOffsetToEta(Math.max(0, Math.ceil(((distM / 1000) / dynKmh) * 3600)));
                    if (etaSec < bestEtaSec) bestEtaSec = etaSec;
                }
                if (isFinite(bestEtaSec)) {
                    if (bestEtaSec <= 45) nextBusText = `Next bus to ${routeLabel} in <1 min`;
                    else nextBusText = `Next bus to ${routeLabel} in ~${Math.ceil(bestEtaSec / 60)} min`;
                } else {
                    nextBusText = `Next bus to ${routeLabel}: no active bus`;
                }
            }
            setOpsValue('opsNextBus', nextBusText);

            let nearestStopText = 'Nearest stop: --';
            if (route && nearestStop) {
                const stopName = (route.stops && route.stops[nearestStopIdx]) ? route.stops[nearestStopIdx] : `Stop ${nearestStopIdx + 1}`;
                if (ref && isFinite(nearestDist)) {
                    nearestStopText = `${Math.round(nearestDist)} m - Walk ${getCompassDirection(ref, nearestStop)} to ${stopName}`;
                } else {
                    nearestStopText = `Nearest stop: ${stopName}`;
                }
            }
            setOpsValue('opsNearestStop', nearestStopText);

            let routeHealthText = `Route ${routeLabel}: On time`;
            if (route) {
                const onRoute = freshEntries.filter(([busNum, b]) => {
                    const rid = (b.routeId != null) ? String(b.routeId) : (busRouteMap[busNum] != null ? String(busRouteMap[busNum]) : null);
                    return rid === String(route.id);
                });
                if (onRoute.length === 0) {
                    routeHealthText = `Route ${routeLabel}: No active buses`;
                } else {
                    let totalSpeed = 0;
                    let speedCount = 0;
                    onRoute.forEach(([busNum]) => {
                        const s = busSpeedCache[busNum];
                        if (s && s > 0) { totalSpeed += s; speedCount++; }
                    });
                    const avgSpeed = speedCount > 0 ? (totalSpeed / speedCount) : 0;
                    routeHealthText = avgSpeed > 10 ? `Route ${routeLabel}: On time` : `Route ${routeLabel}: Minor delay`;
                }
            }
            setOpsValue('opsRouteHealth', routeHealthText);

            const sysText = sseConnected
                ? 'LIVE'
                : (busesPollTimerId ? 'FALLBACK' : 'RETRYING');
            setOpsValue('opsSystemStatus', sysText);
        }

        // Route lookup map for O(1) access (built in loadRoutes)
        const routeMap = {};
        const routeGeometryEnhanceState = {}; // routeId -> pending | done | failed

        // --- Route snapping: global + per-route settings ---
        const DEFAULT_ROUTE_SNAP_SETTINGS = Object.freeze({ enabled: true, distance_m: 10, show_range: false });
        let routeSnapSettings = { ...DEFAULT_ROUTE_SNAP_SETTINGS };

        function normalizeRouteSnapSettings(raw) {
            const src = raw && typeof raw === 'object' ? raw : {};
            const parsedDistance = Number(src.distance_m);
            const distance = Number.isFinite(parsedDistance)
                ? Math.max(1, Math.min(1000, Math.round(parsedDistance)))
                : DEFAULT_ROUTE_SNAP_SETTINGS.distance_m;
            return {
                enabled: !!src.enabled,
                distance_m: distance,
                show_range: !!src.show_range
            };
        }

        function normalizeRouteSnapOverride(raw) {
            const src = raw && typeof raw === 'object' ? raw : {};
            const parsedDistance = Number(src.distance_m);
            const fallbackDistance = routeSnapSettings.distance_m || DEFAULT_ROUTE_SNAP_SETTINGS.distance_m;
            const distance = Number.isFinite(parsedDistance)
                ? Math.max(1, Math.min(1000, Math.round(parsedDistance)))
                : fallbackDistance;
            return {
                override_global: !!src.override_global,
                enabled: (src.enabled == null) ? !!routeSnapSettings.enabled : !!src.enabled,
                distance_m: distance,
                show_range: (src.show_range == null) ? !!routeSnapSettings.show_range : !!src.show_range
            };
        }

        function getEffectiveRouteSnapSettings(routeId) {
            const rid = String(routeId || '');
            const route = rid ? getRouteById(rid) : null;
            const globalSettings = normalizeRouteSnapSettings(routeSnapSettings);
            if (!route || !route.snap_settings) return globalSettings;
            const routeOverride = normalizeRouteSnapOverride(route.snap_settings);
            if (!routeOverride.override_global) return globalSettings;
            return {
                enabled: !!routeOverride.enabled,
                distance_m: Math.max(1, Math.min(1000, Math.round(routeOverride.distance_m || globalSettings.distance_m))),
                show_range: !!routeOverride.show_range
            };
        }

        async function loadRouteSnapSettings() {
            try {
                const res = await fetch('/api/route-snap-settings', { cache: 'no-store' });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'route_snap_settings_load_failed');
                routeSnapSettings = normalizeRouteSnapSettings(data || DEFAULT_ROUTE_SNAP_SETTINGS);
            } catch (e) {
                routeSnapSettings = normalizeRouteSnapSettings(DEFAULT_ROUTE_SNAP_SETTINGS);
            }
        }

        // Cache decoded route coords: routeId -> [[lat,lng], ...]
        const routeCoordsCache = {};

        function cacheRouteCoords(routeId, latlngs) {
            routeCoordsCache[routeId] = latlngs;
        }

        // Find closest point on a polyline segment AB to point P
        function closestPointOnSegmentMeters(px, py, ax, ay, bx, by) {
            const latRef = (py + ay + by) / 3;
            const rad = latRef * Math.PI / 180;
            const mPerLat = 111320;
            const mPerLng = Math.max(1, 111320 * Math.cos(rad));

            const pX = px * mPerLng, pY = py * mPerLat;
            const aX = ax * mPerLng, aY = ay * mPerLat;
            const bX = bx * mPerLng, bY = by * mPerLat;
            const dX = bX - aX, dY = bY - aY;
            const lenSq = dX * dX + dY * dY;

            if (lenSq <= 1e-6) {
                return { pt: [ay, ax], t: 0 };
            }

            let t = ((pX - aX) * dX + (pY - aY) * dY) / lenSq;
            t = Math.max(0, Math.min(1, t));
            const projX = aX + t * dX;
            const projY = aY + t * dY;
            return { pt: [projY / mPerLat, projX / mPerLng], t };
        }

        function snapToRoute(lat, lng, busNum) {
            const rid = busRouteMap[busNum];
            if (!rid) {
                delete busSnapLockState[busNum];
                return { pos: [lat, lng], segIdx: -1 };
            }
            const coords = routeCoordsCache[rid];
            if (!coords || coords.length < 2) {
                busSnapLockState[busNum] = { locked: false, routeId: String(rid) };
                return { pos: [lat, lng], segIdx: -1 };
            }
            const snapCfg = getEffectiveRouteSnapSettings(rid);
            if (!snapCfg.enabled) {
                busSnapLockState[busNum] = { locked: false, routeId: String(rid) };
                return { pos: [lat, lng], segIdx: -1 };
            }
            const snapDistM = Math.max(1, Number(snapCfg.distance_m) || DEFAULT_ROUTE_SNAP_SETTINGS.distance_m);
            const releaseDistM = Math.max(snapDistM + 4, Math.round(snapDistM * 1.35));

            const n = coords.length - 1;
            let bestDist = Infinity, bestPt = [lat, lng], bestSeg = -1;
            const lastSeg = (busSnapInfo[busNum] && busSnapInfo[busNum].segIdx >= 0) ? busSnapInfo[busNum].segIdx : -1;
            let lockState = busSnapLockState[busNum];
            if (!lockState || String(lockState.routeId || '') !== String(rid)) {
                lockState = { locked: false, routeId: String(rid) };
            }

            // Local search from last known segment (30)  fast path
            if (lastSeg >= 0) {
                const window = lockState.locked ? 45 : 32;
                const lo = Math.max(0, lastSeg - window), hi = Math.min(n - 1, lastSeg + window);
                for (let i = lo; i <= hi; i++) {
                    const ptObj = closestPointOnSegmentMeters(lng, lat, coords[i][1], coords[i][0], coords[i+1][1], coords[i+1][0]);
                    const pt = ptObj.pt;
                    const d = calcDistance(lat, lng, pt[0], pt[1]);
                    if (d < bestDist) { bestDist = d; bestPt = pt; bestSeg = i; }
                }
                const threshold = lockState.locked ? releaseDistM : snapDistM;
                if (bestDist <= threshold) {
                    busSnapLockState[busNum] = { locked: true, routeId: String(rid) };
                    return { pos: bestPt, segIdx: bestSeg };
                }
            }
            // Full scan fallback
            for (let i = 0; i < n; i++) {
                const ptObj = closestPointOnSegmentMeters(lng, lat, coords[i][1], coords[i][0], coords[i+1][1], coords[i+1][0]);
                const pt = ptObj.pt;
                const d = calcDistance(lat, lng, pt[0], pt[1]);
                if (d < bestDist) { bestDist = d; bestPt = pt; bestSeg = i; }
            }
            const finalThreshold = lockState.locked ? releaseDistM : snapDistM;
            if (bestDist <= finalThreshold) {
                busSnapLockState[busNum] = { locked: true, routeId: String(rid) };
                return { pos: bestPt, segIdx: bestSeg };
            }
            busSnapLockState[busNum] = { locked: false, routeId: String(rid) };
            return { pos: [lat, lng], segIdx: -1 };
        }

        // Extract sub-path along route between two snapped points
        function getRouteSubPath(rid, fromPos, fromSeg, toPos, toSeg) {
            const coords = routeCoordsCache[rid];
            if (!coords || fromSeg < 0 || toSeg < 0) return null;

            const path = [];
            // Determine direction (forward or backward along route)
            const forward = toSeg >= fromSeg;
            if (forward) {
                path.push(fromPos);
                for (let i = fromSeg + 1; i <= toSeg; i++) {
                    path.push(coords[i]);
                }
                path.push(toPos);
            } else {
                path.push(fromPos);
                for (let i = fromSeg; i >= toSeg + 1; i--) {
                    path.push(coords[i]);
                }
                path.push(toPos);
            }
            // Skip if path is too long (bus probably jumped routes)  max ~80 segments
            if (path.length > 80) return null;
            return path;
        }

        // Compute cumulative distances along a path for proportional interpolation
        function computePathDistances(path) {
            const dists = [0];
            for (let i = 1; i < path.length; i++) {
                dists.push(dists[i-1] + calcDistance(path[i-1][0], path[i-1][1], path[i][0], path[i][1]));
            }
            return dists;
        }

        // Interpolate position along a multi-point path at fraction t (0..1)
        function interpAlongPath(path, dists, t) {
            if (path.length < 2) return path[0];
            const totalLen = dists[dists.length - 1];
            if (totalLen === 0) return path[0];
            const targetDist = t * totalLen;
            for (let i = 1; i < dists.length; i++) {
                if (dists[i] >= targetDist) {
                    const segLen = dists[i] - dists[i-1];
                    const segT = segLen > 0 ? (targetDist - dists[i-1]) / segLen : 0;
                    return [
                        path[i-1][0] + (path[i][0] - path[i-1][0]) * segT,
                        path[i-1][1] + (path[i][1] - path[i-1][1]) * segT
                    ];
                }
            }
            return path[path.length - 1];
        }

        // Tween state for smooth marker movement along route paths
        const busTweens = {}; // busNum -> { path, dists, start, dur } or { from, to, start, dur }
        const busSnapInfo = {}; // busNum -> { segIdx }  last known segment index
        const busSnapLockState = {}; // busNum -> { locked: bool, routeId: string|null }
        const TWEEN_MS = 800; // base tween duration floor
        const DEFAULT_BUS_SPEED_MPS = 14 / 3.6; // dynamic movement fallback when speed is unknown
        function easeInOut(t){ return t<0.5 ? 2*t*t : -1+(4-2*t)*t; }
        function createKalmanAxis(initialValue) { return { x: initialValue, p: 1, q: 0.00014, r: 0.00016 }; }
        function kalmanAxisUpdate(state, measurement) { state.p += state.q; const k = state.p / (state.p + state.r); state.x = state.x + k * (measurement - state.x); state.p = (1 - k) * state.p; return state.x; }
        function kalmanFilterBusPosition(busNum, lat, lng) {
            let st = busKalmanState[busNum];
            if (!st) { st = { lat: createKalmanAxis(lat), lng: createKalmanAxis(lng) }; busKalmanState[busNum] = st; return [lat, lng]; }
            const fLat = kalmanAxisUpdate(st.lat, lat);
            const fLng = kalmanAxisUpdate(st.lng, lng);
            if (calcDistance(fLat, fLng, lat, lng) > 55) { busKalmanState[busNum] = { lat: createKalmanAxis(lat), lng: createKalmanAxis(lng) }; return [lat, lng]; }
            const trackedNow = trackedBus && String(trackedBus) === String(busNum);
            if (trackedNow) {
                // Latency-first blend for tracked transport: stay close to fresh GPS fix.
                return [lat * 0.88 + fLat * 0.12, lng * 0.88 + fLng * 0.12];
            }
            return [fLat, fLng];
        }
        function getDynamicSpeedMps(busNum) {
            let kmh = busSpeedCache[busNum];
            if (!(kmh > 0)) kmh = (busTweenSpeedCache[busNum] || (DEFAULT_BUS_SPEED_MPS * 3.6));
            kmh = Math.max(10, Math.min(46, kmh));
            const prev = busTweenSpeedCache[busNum] || kmh;
            const smoothed = prev + (kmh - prev) * 0.52;
            busTweenSpeedCache[busNum] = smoothed;
            return Math.max(2.8, smoothed / 3.6);
        }

        // --- Prediction animation state ---
        // When no SSE update received, buses keep moving along route at predicted speed
        const busPrediction = {}; // busNum -> { active, segIdx, t, lastRealPos, lastRealTime, routeId }
        const PREDICTION_TIMEOUT_MS = 3000; // start predicting after 3s with no update
        const PREDICTION_MAX_MS = 30000; // stop predicting after 30s
        let _predAnimRunning = false;

        // Server-sent heading cache
        const busServerHeading = {}; // busNum -> heading degrees from server

        function ensureTweenLoop() {
            if (_tweenAnimRunning) return;
            _tweenAnimRunning = true;
            _lastTweenFrameTs = 0;
            requestAnimationFrame(animateBusTweens);
        }

        function queueBusTween(busNum, toPos){
            try{
                const marker = busMarkers[busNum];
                const fromPos = marker ? [marker.getLatLng().lat, marker.getLatLng().lng] : toPos;
                const rid = busRouteMap[busNum];

                // Cancel any active prediction  real data arrived
                if (busPrediction[busNum]) { busPrediction[busNum].active = false; }

                // Skip tween if position hasn't meaningfully changed (<1m)
                const tweenDist = calcDistance(fromPos[0], fromPos[1], toPos[0], toPos[1]);
                if (tweenDist < 1) {
                    // Store real position for prediction system
                    updatePredictionState(busNum, toPos);
                    return;
                }

                // Anti-teleport: if jump > 500m, snap instantly instead of tweening
                if (tweenDist > 500) {
                    const snapResult = snapToRoute(toPos[0], toPos[1], busNum);
                    busSnapInfo[busNum] = { segIdx: snapResult.segIdx };
                    marker.setLatLng(snapResult.pos);
                    prevBusPositions[busNum] = snapResult.pos;
                    updatePredictionState(busNum, toPos);
                    return;
                }

                const fromSeg = busSnapInfo[busNum] ? busSnapInfo[busNum].segIdx : -1;

                // Try to get snap info for the destination
                const snapResult = snapToRoute(toPos[0], toPos[1], busNum);
                const snappedTo = snapResult.pos;
                const toSeg = snapResult.segIdx;
                busSnapInfo[busNum] = { segIdx: toSeg };

                // Try to build a route sub-path for curved animation
                let routePath = null;
                if (rid && fromSeg >= 0 && toSeg >= 0) {
                    routePath = getRouteSubPath(rid, fromPos, fromSeg, snappedTo, toSeg);
                }

                // Calculate tween duration using dynamic GPS-based speed (clamped for smoothness).
                const dynamicSpeedMps = getDynamicSpeedMps(busNum);
                const latencyBias = (trackedBus && String(trackedBus) === String(busNum)) ? 0.34 : 0.50;
                const dur = Math.max(80, Math.min(820, ((tweenDist / dynamicSpeedMps) * 1000) * latencyBias));

                if (routePath && routePath.length >= 2) {
                    const dists = computePathDistances(routePath);
                    busTweens[busNum] = { path: routePath, dists: dists, start: performance.now(), dur: dur };
                } else {
                    // Fallback: straight-line tween
                    busTweens[busNum] = { from: fromPos, to: snappedTo, start: performance.now(), dur: dur };
                }
                // Store real position for prediction system
                updatePredictionState(busNum, toPos);
                ensureTweenLoop();
            }catch(e){ /* ignore */ }
        }

        // --- Prediction animation helpers ---
        function updatePredictionState(busNum, realPos) {
            const rid = busRouteMap[busNum];
            const snapInfo = busSnapInfo[busNum];
            busPrediction[busNum] = {
                active: false,
                segIdx: snapInfo ? snapInfo.segIdx : -1,
                t: 0,
                lastRealPos: realPos,
                lastRealTime: Date.now(),
                routeId: rid || null,
                speedMps: getDynamicSpeedMps(busNum)
            };
        }

        function startPredictionLoop() {
            if (_predAnimRunning) return;
            _predAnimRunning = true;
            _lastPredictionFrameTs = 0;
            requestAnimationFrame(predictionTick);
        }

        function predictionTick(now) {
            const frameTs = (typeof now === 'number') ? now : performance.now();
            if (_lastPredictionFrameTs && (frameTs - _lastPredictionFrameTs) < _predFrameMinGapMs) {
                if (_predAnimRunning) requestAnimationFrame(predictionTick);
                return;
            }
            const dtSec = _lastPredictionFrameTs
                ? Math.min(0.12, (frameTs - _lastPredictionFrameTs) / 1000)
                : (1 / 30);
            _lastPredictionFrameTs = frameTs;
            let anyActive = false;
            const nowMs = Date.now();
            for (const busNum in busPrediction) {
                const pred = busPrediction[busNum];
                if (!pred || !pred.routeId) continue;
                const marker = busMarkers[busNum];
                if (!marker) continue;
                const timeSinceReal = nowMs - pred.lastRealTime;
                const status = busStatusCache[busNum];

                // Don't predict for idle/offline/at-stop buses
                if (status && (status === 'Idle' || status === 'Offline' || status === 'At Stop' ||
                    status === 'Reached Destination' || status === 'At Start' || status === 'Waiting for Update')) {
                    pred.active = false;
                    continue;
                }

                // Start predicting after PREDICTION_TIMEOUT_MS of no update
                if (timeSinceReal >= PREDICTION_TIMEOUT_MS && timeSinceReal <= PREDICTION_MAX_MS && !pred.active) {
                    // Activate prediction: initialize from current snap position
                    pred.active = true;
                    pred.predStartTime = nowMs;
                    const coords = routeCoordsCache[pred.routeId];
                    if (!coords || coords.length < 2 || pred.segIdx < 0) { pred.active = false; continue; }
                    // Find fractional position on segment
                    const curLL = marker.getLatLng();
                    const a = coords[pred.segIdx], b = coords[Math.min(pred.segIdx + 1, coords.length - 1)];
                    const dx = b[0] - a[0], dy = b[1] - a[1];
                    const lenSq = dx * dx + dy * dy;
                    pred.t = lenSq > 0 ? Math.max(0, Math.min(1, ((curLL.lat - a[0]) * dx + (curLL.lng - a[1]) * dy) / lenSq)) : 0;
                }

                if (!pred.active) continue;
                if (timeSinceReal > PREDICTION_MAX_MS) { pred.active = false; continue; }

                anyActive = true;
                const coords = routeCoordsCache[pred.routeId];
                if (!coords || coords.length < 2) { pred.active = false; continue; }

                // Move along route using last observed GPS-derived speed
                const dir = busDirection[busNum];
                const forward = dir !== 'up'; // default forward = down (increasing index)
                const speedDegPerSec = Math.max(2.8, pred.speedMps || DEFAULT_BUS_SPEED_MPS) / 111320;
                const dt = dtSec;
                let remaining = speedDegPerSec * dt;

                if (forward) {
                    while (remaining > 0 && pred.segIdx < coords.length - 1) {
                        const a = coords[pred.segIdx], b = coords[pred.segIdx + 1];
                        const segDx = b[0] - a[0], segDy = b[1] - a[1];
                        const segLen = Math.sqrt(segDx * segDx + segDy * segDy);
                        if (segLen === 0) { pred.segIdx++; pred.t = 0; continue; }
                        const left = (1 - pred.t) * segLen;
                        if (remaining >= left) { remaining -= left; pred.segIdx++; pred.t = 0; }
                        else { pred.t += remaining / segLen; remaining = 0; }
                    }
                    if (pred.segIdx >= coords.length - 1) { pred.segIdx = coords.length - 2; pred.t = 1; pred.active = false; }
                } else {
                    while (remaining > 0 && (pred.segIdx > 0 || pred.t > 0)) {
                        const a = coords[pred.segIdx], b = coords[pred.segIdx + 1];
                        const segDx = b[0] - a[0], segDy = b[1] - a[1];
                        const segLen = Math.sqrt(segDx * segDx + segDy * segDy);
                        if (segLen === 0) { if (pred.segIdx > 0) { pred.segIdx--; pred.t = 1; } else { pred.t = 0; } continue; }
                        const left = pred.t * segLen;
                        if (remaining >= left) { remaining -= left; if (pred.segIdx > 0) { pred.segIdx--; pred.t = 1; } else { pred.t = 0; pred.active = false; } }
                        else { pred.t -= remaining / segLen; remaining = 0; }
                    }
                }

                // Set marker position
                const sa = coords[pred.segIdx], sb = coords[Math.min(pred.segIdx + 1, coords.length - 1)];
                const pLat = sa[0] + pred.t * (sb[0] - sa[0]);
                const pLng = sa[1] + pred.t * (sb[1] - sa[1]);
                try { marker.setLatLng([pLat, pLng]); } catch(e) {}

                // Update snap info for when real data arrives (so tween routes correctly)
                busSnapInfo[busNum] = { segIdx: pred.segIdx };
            }
            if (anyActive) requestAnimationFrame(predictionTick);
            else { _predAnimRunning = false; _lastPredictionFrameTs = 0; }
        }

        function animateBusTweens(nowTs){
            const frameTs = (typeof nowTs === 'number') ? nowTs : performance.now();
            if (_lastTweenFrameTs && (frameTs - _lastTweenFrameTs) < _tweenFrameMinGapMs) {
                requestAnimationFrame(animateBusTweens);
                return;
            }
            _lastTweenFrameTs = frameTs;
            const now = Date.now();
            let any = false;
            for (const busNum in busTweens) {
                const tw = busTweens[busNum];
                const marker = busMarkers[busNum];
                if(!marker) { delete busTweens[busNum]; continue; }
                const t = Math.min(1, (frameTs - tw.start) / tw.dur);
                const k = easeInOut(t);
                let lat, lng;
                if (tw.path) {
                    const pos = interpAlongPath(tw.path, tw.dists, k);
                    lat = pos[0]; lng = pos[1];
                } else {
                    lat = tw.from[0] + (tw.to[0]-tw.from[0]) * k;
                    lng = tw.from[1] + (tw.to[1]-tw.from[1]) * k;
                }
                try{ marker.setLatLng([lat,lng]); if(t<1) any = true; }catch(e){}
                if (trackedBus && busNum === trackedBus && followEnabled && map) {
                    try {
                        const px = map.latLngToContainerPoint([lat, lng]);
                        const sz = map.getSize();
                        const margin = AUTO_PAN_PADDING_PX;
                        if ((now - _lastAutoPanMs) >= AUTO_PAN_MIN_INTERVAL_MS && (px.x < margin || px.x > sz.x - margin || px.y < margin || px.y > sz.y - margin)) {
                            map.panInside([lat, lng], {
                                paddingTopLeft: [margin, margin],
                                paddingBottomRight: [margin, margin],
                                animate: false
                            });
                            _lastAutoPanMs = now;
                        }
                    } catch(e) {}
                }
                if(t>=1){ delete busTweens[busNum]; }
            }
            if(any) requestAnimationFrame(animateBusTweens);
            else { _tweenAnimRunning = false; _lastTweenFrameTs = 0; }
        }

        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition((pos) => {
                userLocation = [pos.coords.latitude, pos.coords.longitude];
                refreshAssistantFromField();
                if (map) {
                    updateUserMarker(userLocation);
                    if (!selectedRouteId) applyMapViewportForContext(false);
                    scheduleSpatialSync();
                }
            }, (err) => console.log('Geolocation error:', err), { enableHighAccuracy: true, maximumAge: 1500, timeout: 6000 });
        }

        function updateUserMarker(latlng){
            try{
                if(!map) return;
                if(!userMarker){
                    userMarker = L.circleMarker(latlng, { radius: 6, color: '#ffffff', weight: 2, fillColor: '#34d399', fillOpacity: 1 }).addTo(map);
                }else{
                    userMarker.setLatLng(latlng);
                }
            }catch(e){ /* ignore */ }
        }

        function ensureTrailPane() {
            if (!map) return;
            if (!map.getPane('trailPane')) {
                map.createPane('trailPane');
                const pane = map.getPane('trailPane');
                if (pane) pane.style.zIndex = 380;
            }
        }
        function ensureBusTrail(busNum, color) {
            if (!map || isLowPerfMode()) return null;
            if (!busTrails[busNum]) {
                ensureTrailPane();
                const polyline = L.polyline([], {
                    pane: 'trailPane',
                    color: color,
                    weight: 3,
                    opacity: 0.16,
                    lineCap: 'round',
                    lineJoin: 'round',
                    className: 'bus-trail-line'
                }).addTo(map);
                busTrails[busNum] = { polyline, points: [] };
            } else {
                try { busTrails[busNum].polyline.setStyle({ color: color }); } catch(e) {}
            }
            return busTrails[busNum];
        }
        function updateBusTrail(busNum, position, color) {
            if (isLowPerfMode() || !position) return;
            const t = ensureBusTrail(busNum, color);
            if (!t) return;
            const now = Date.now();
            const pts = t.points;
            const last = pts.length ? pts[pts.length - 1] : null;
            if (last && calcDistance(last.lat, last.lng, position[0], position[1]) < TRAIL_MIN_MOVE_M) return;
            pts.push({ lat: position[0], lng: position[1], t: now });
            while (pts.length > TRAIL_MAX_POINTS) pts.shift();
            while (pts.length && (now - pts[0].t) > TRAIL_MAX_AGE_MS) pts.shift();
            try {
                t.polyline.setLatLngs(pts.map(p => [p.lat, p.lng]));
                const oldestAge = pts.length ? (now - pts[0].t) : TRAIL_MAX_AGE_MS;
                const fade = 1 - Math.min(1, oldestAge / TRAIL_MAX_AGE_MS);
                t.polyline.setStyle({ opacity: 0.08 + (fade * 0.14) });
            } catch(e) {}
        }
        function refreshBusTrails() {
            const now = Date.now();
            Object.keys(busTrails).forEach(busNum => {
                const t = busTrails[busNum];
                if (!t || !t.points) return;
                t.points = t.points.filter(p => (now - p.t) <= TRAIL_MAX_AGE_MS);
                if (t.points.length === 0) {
                    try { map.removeLayer(t.polyline); } catch(e) {}
                    delete busTrails[busNum];
                    return;
                }
                try {
                    t.polyline.setLatLngs(t.points.map(p => [p.lat, p.lng]));
                    const oldestAge = now - t.points[0].t;
                    const fade = 1 - Math.min(1, oldestAge / TRAIL_MAX_AGE_MS);
                    t.polyline.setStyle({ opacity: 0.08 + (fade * 0.14) });
                } catch(e) {}
            });
        }
        function removeBusTrail(busNum) {
            const t = busTrails[busNum];
            if (!t) return;
            try { map.removeLayer(t.polyline); } catch(e) {}
            delete busTrails[busNum];
        }
        function clearAllBusTrails() {
            Object.keys(busTrails).forEach(removeBusTrail);
        }

        async function loadBusRoutes() {
            try { const res = await fetch('/api/bus-routes'); busRouteMap = await res.json(); } catch(e) { console.error('Error loading bus routes:', e); }
        }

        // Fast equirectangular distance  accurate within 0.1% at campus scale
        const _DEG2RAD = Math.PI / 180;
        function calcDistance(lat1, lng1, lat2, lng2) {
            const dLat = (lat2 - lat1) * _DEG2RAD;
            const dLng = (lng2 - lng1) * _DEG2RAD;
            const x = dLng * Math.cos((lat1 + lat2) * 0.5 * _DEG2RAD);
            return 6371000 * Math.sqrt(dLat * dLat + x * x);
        }
        // Geographic bearing: 0=north, clockwise. Input: [lat,lng] pairs.
        function calcBearing(from, to) {
            const dLng = (to[1] - from[1]) * _DEG2RAD;
            const lat1 = from[0] * _DEG2RAD, lat2 = to[0] * _DEG2RAD;
            const y = Math.sin(dLng) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLng);
            return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360; // 0-360
        }

        // --- Route distance computation (along polyline) ---
        function ensureRouteCumulDist(routeId) {
            if (routeCumulDistCache[routeId]) return routeCumulDistCache[routeId];
            const coords = routeCoordsCache[routeId];
            if (!coords || coords.length < 2) return null;
            const cumul = [0];
            for (let i = 1; i < coords.length; i++) {
                cumul.push(cumul[i-1] + calcDistance(coords[i-1][0], coords[i-1][1], coords[i][0], coords[i][1]));
            }
            routeCumulDistCache[routeId] = cumul;
            return cumul;
        }
        function getDistAlongRoute(routeId, pos) {
            const coords = routeCoordsCache[routeId];
            const cumul = ensureRouteCumulDist(routeId);
            if (!coords || !cumul || coords.length < 2) return null;
            let bestDist = Infinity, bestSeg = 0, bestT = 0;
            for (let i = 0; i < coords.length - 1; i++) {
                const ax = coords[i][0], ay = coords[i][1], bx = coords[i+1][0], by = coords[i+1][1];
                const dx = bx - ax, dy = by - ay;
                const lenSq = dx * dx + dy * dy;
                let t = lenSq > 0 ? ((pos[0] - ax) * dx + (pos[1] - ay) * dy) / lenSq : 0;
                t = Math.max(0, Math.min(1, t));
                const px = ax + t * dx, py = ay + t * dy;
                const d = calcDistance(pos[0], pos[1], px, py);
                if (d < bestDist) { bestDist = d; bestSeg = i; bestT = t; }
            }
            const segLen = cumul[bestSeg + 1] - cumul[bestSeg];
            return cumul[bestSeg] + bestT * segLen;
        }
        function getRouteDistanceBetween(routeId, posA, posB) {
            if (!routeId) return null;
            const d1 = getDistAlongRoute(routeId, posA);
            const d2 = getDistAlongRoute(routeId, posB);
            if (d1 === null || d2 === null) return null;
            return Math.abs(d2 - d1);
        }

        // Get bearing for bus icon rotation.
        // Returns CSS rotation degrees (0 = arrow pointing right/east).
        // SVG arrow points right, so we subtract 90 from geographic bearing (0=north).
        function getRouteBearing(busNum) {
            let geoBearing;
            // Use server-sent heading if available (from driver's device)  already geographic
            if (busServerHeading[busNum] !== undefined && busServerHeading[busNum] !== null) {
                geoBearing = busServerHeading[busNum];
            } else {
                const rid = busRouteMap[busNum];
                if (!rid) return prevBusRotation[busNum] || 0;
                const coords = routeCoordsCache[rid];
                const snapInfo = busSnapInfo[busNum];
                if (!coords || !snapInfo || snapInfo.segIdx < 0 || snapInfo.segIdx >= coords.length - 1) return prevBusRotation[busNum] || 0;
                const i = snapInfo.segIdx;
                // Geographic bearing of this route segment (forward direction = 'down')
                const fwd = calcBearing(coords[i], coords[i + 1]);
                // If bus is going 'up' (toward index 0), flip 180
                const dir = busDirection[busNum];
                geoBearing = dir === 'up' ? (fwd + 180) % 360 : fwd;
            }
            // Convert geographic bearing (0=north) to CSS rotation (0=right/east)
            return (geoBearing - 90 + 360) % 360;
        }

        // Zoom-responsive icon sizing (~55% of original)
        let currentIconSize = 12;
        function getIconSizeForZoom(z) {
            if (z >= 18) return 16;
            if (z >= 17) return 14;
            if (z >= 16) return 12;
            if (z >= 15) return 11;
            return 10;
        }

        const _iconSvgCache = {};
        function createIcon(busNum, color, size, rotation = 0, glow = false) {
            size = size || currentIconSize;
            const cacheKey = `${busNum}_${color}_${size}_${glow ? 1 : 0}`;
            let cached = _iconSvgCache[cacheKey];
            if (!cached) {
                const h = size;
                const bodyW = Math.round(size * 1.2);
                const arrowW = Math.round(size * 0.5);
                const w = bodyW + arrowW;
                const r = Math.round(h * 0.38);
                const mid = Math.round(h / 2);
                const fontSize = Math.max(8, Math.round(h * 0.44));
                const shape = `M${r},0 H${bodyW} L${w},${mid} L${bodyW},${h} H${r} A${r},${r} 0 0,1 0,${h-r} V${r} A${r},${r} 0 0,1 ${r},0Z`;
                const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" style="filter:drop-shadow(0 1px 4px rgba(0,0,0,0.5))">
<path d="${shape}" fill="${color}" stroke="#fff" stroke-width="1.5" stroke-linejoin="round"/>
<text x="${Math.round(bodyW * 0.45)}" y="${mid}" text-anchor="middle" dominant-baseline="central" fill="#fff" font-family="Segoe UI,Arial" font-weight="800" font-size="${fontSize}" style="text-shadow:0 1px 2px rgba(0,0,0,0.6)">${busNum}</text></svg>`;
                const anchorX = Math.round(bodyW / 2);
                cached = { svg, w, h, anchorX, anchorY: mid };
                _iconSvgCache[cacheKey] = cached;
            }
            const rot = Math.round(rotation);
            const isTrackedTransport = trackedBus && String(trackedBus) === String(busNum);
            const hasTrackedSelection = !!trackedBus;
            const isDimmedTransport = hasTrackedSelection && !isTrackedTransport;
            const showPulse = !isLowPerfMode() && !!glow && (!hasTrackedSelection || isTrackedTransport);
            const showShadow = !isLowPerfMode();
            const showSelectionHalo = !isLowPerfMode() && !!isTrackedTransport;
            const haloSize = Math.max(30, Math.round(size * 2.55));
            const shadowHtml = showShadow ? '<span class="bus-marker-shadow"></span>' : '';
            const pulseHtml = showPulse ? `<span class="bus-marker-pulse" style="border-color:${color}66"></span>` : '';
            const selectedHtml = showSelectionHalo ? '<span class="bus-marker-selected"></span>' : '';
            const wrapClass = `bus-marker-wrap${isTrackedTransport ? ' is-tracked' : ''}${isDimmedTransport ? ' is-dimmed' : ''}`;
            return L.divIcon({
                className: 'bus-icon',
                html: `<div class="${wrapClass}" style="width:${cached.w}px;height:${cached.h}px;--marker-anchor-x:${cached.anchorX}px;--marker-anchor-y:${cached.anchorY}px;--marker-halo-size:${haloSize}px">${shadowHtml}${pulseHtml}${selectedHtml}<div style="transform:rotate(${rot}deg);transform-origin:${cached.anchorX}px ${cached.anchorY}px">${cached.svg}</div></div>`,
                iconSize: [cached.w, cached.h],
                iconAnchor: [cached.anchorX, cached.anchorY],
                popupAnchor: [0, -cached.anchorY - 4]
            });
        }

        function createLocationIcon(type) { const html = type === 'hostel' ? '<span class="tiny-marker tiny-hostel"></span>' : '<span class="tiny-marker tiny-class"></span>'; return L.divIcon({ className: 'marker-wrapper', html, iconSize: [10,10], iconAnchor: [5,5], popupAnchor: [0, -8] }); }

        let visibleLayers = { routes: true, hostels: true, classes: true };

        function parseIsoTime(iso) { try { const t = new Date(iso).getTime(); return isNaN(t) ? null : t; } catch(e) { return null; } }
        function computeSpeed(busNum, position, lastUpdateIso) {
            const prevPos = prevRawPositions[busNum]; const prevTime = prevBusTimes[busNum]; const currTime = parseIsoTime(lastUpdateIso);
            if (!prevPos || !prevTime || !currTime) return null;
            const timeDelta = (currTime - prevTime) / 1000;
            // Need at least 1.5s between samples for meaningful speed
            if (timeDelta < 1.5) return null;
            const meters = calcDistance(prevPos[0], prevPos[1], position[0], position[1]);
            const kmh = (meters / 1000) / (timeDelta / 3600);
            // Cap at 120 km/h  anything higher is GPS noise
            if (kmh > 120) return null;
            return Math.round(kmh);
        }
        // Cache speed and movement BEFORE overwriting prevRawPositions  fixes race condition
        function cacheSpeedAndMovement(busNum, newLat, newLng, lastUpdateIso) {
            const pRaw = prevRawPositions[busNum];
            const pTime = prevBusTimes[busNum];
            const cTime = parseIsoTime(lastUpdateIso);
            if (pRaw && pTime && cTime) {
                const dt = (cTime - pTime) / 1000;
                const dist = calcDistance(pRaw[0], pRaw[1], newLat, newLng);
                busMovedCache[busNum] = dist;
                if (dt >= 1.5) {
                    const kmh = (dist / 1000) / (dt / 3600);
                    busSpeedCache[busNum] = (kmh <= 120 && kmh > 0.1) ? Math.round(kmh) : (busSpeedCache[busNum] || null);
                }
            }
        }
        // Combined stop/direction update  prefer server-sent data, fallback to client computation
        function updateBusStopInfo(busNum, rawPosition, serverStopData) {
            const routeId = busRouteMap[busNum];
            const route = routeId ? getRouteById(routeId) : null;

            // If server sent stop info, use it directly (avoids redundant N-client computation)
            if (serverStopData && serverStopData.nearestStopIdx !== undefined && serverStopData.nearestStopIdx !== null) {
                const bestIdx = serverStopData.nearestStopIdx;
                const atStopName = serverStopData.atStop || null;
                const dir = serverStopData.direction || busDirection[busNum];
                if (dir) busDirection[busNum] = dir;
                busLastStopIdx[busNum] = bestIdx;
                busCurrentStop[busNum] = atStopName;
                // Terminal status detection
                const len = (route && route.waypoints) ? route.waypoints.length : 0;
                if (atStopName && len > 0) {
                    if (dir === 'down' && bestIdx === len - 1) { busTerminalStatus[busNum] = 'at_destination'; }
                    else if (dir === 'up' && bestIdx === 0) { busTerminalStatus[busNum] = 'at_destination'; }
                    else if (dir === 'down' && bestIdx === 0) { busTerminalStatus[busNum] = 'at_start'; }
                    else if (dir === 'up' && bestIdx === len - 1) { busTerminalStatus[busNum] = 'at_start'; }
                    else if (!dir && (bestIdx === 0 || bestIdx === len - 1)) { busTerminalStatus[busNum] = 'waiting'; }
                    else { busTerminalStatus[busNum] = null; }
                } else { busTerminalStatus[busNum] = null; }
                const bestD = route ? calcDistance(rawPosition[0], rawPosition[1], route.waypoints[bestIdx][0], route.waypoints[bestIdx][1]) : 0;
                busNearestStopCache[busNum] = { idx: bestIdx, dist: bestD, atStopName };
                return;
            }

            // Fallback: client-side computation (for polling responses without stop data)
            if (!route || !route.waypoints || route.waypoints.length < 2) return;
            const wps = route.waypoints, len = wps.length;
            let bestIdx = 0, bestD = Infinity;
            for (let i = 0; i < len; i++) {
                const d = calcDistance(rawPosition[0], rawPosition[1], wps[i][0], wps[i][1]);
                if (d < bestD) { bestD = d; bestIdx = i; }
            }
            // Direction
            const prevIdx = busLastStopIdx[busNum];
            if (prevIdx !== undefined && prevIdx !== bestIdx) {
                busDirection[busNum] = bestIdx > prevIdx ? 'down' : 'up';
            }
            busLastStopIdx[busNum] = bestIdx;
            // At-stop check
            const atStopName = bestD <= AT_STOP_THRESHOLD
                ? ((route.stops && route.stops[bestIdx]) ? route.stops[bestIdx] : `Stop ${bestIdx + 1}`)
                : null;
            if (atStopName) { busCurrentStop[busNum] = atStopName; } else { busCurrentStop[busNum] = null; }
            // Terminal status detection (first/last stop based on direction)
            const dir = busDirection[busNum];
            if (atStopName) {
                if (dir === 'down' && bestIdx === len - 1) { busTerminalStatus[busNum] = 'at_destination'; }
                else if (dir === 'up' && bestIdx === 0) { busTerminalStatus[busNum] = 'at_destination'; }
                else if (dir === 'down' && bestIdx === 0) { busTerminalStatus[busNum] = 'at_start'; }
                else if (dir === 'up' && bestIdx === len - 1) { busTerminalStatus[busNum] = 'at_start'; }
                else if (!dir && (bestIdx === 0 || bestIdx === len - 1)) { busTerminalStatus[busNum] = 'waiting'; }
                else { busTerminalStatus[busNum] = null; }
            } else { busTerminalStatus[busNum] = null; }
            busNearestStopCache[busNum] = { idx: bestIdx, dist: bestD, atStopName };
        }
        function determineStatus(busNum, rawPosition, lastUpdateIso) {
            const nowMs = Date.now();
            const lastSeen = busLastSeen[busNum] || 0;
            const serverTime = parseIsoTime(lastUpdateIso);
            const effectiveTime = Math.max(lastSeen, serverTime || 0);
            if (!effectiveTime || (nowMs - effectiveTime) > OFFLINE_MS) { busStatusCache[busNum] = 'Offline'; return 'Offline'; }
            // Terminal status from updateBusStopInfo
            const terminal = busTerminalStatus[busNum];
            if (terminal === 'at_destination') { busStatusCache[busNum] = 'Reached Destination'; return 'Reached Destination'; }
            if (terminal === 'at_start') { busStatusCache[busNum] = 'At Start'; return 'At Start'; }
            if (terminal === 'waiting') { busStatusCache[busNum] = 'Waiting for Update'; return 'Waiting for Update'; }
            // Use cached at-stop result from updateBusStopInfo
            if (busCurrentStop[busNum]) { busStatusCache[busNum] = 'At Stop'; return 'At Stop'; }
            // Use cached movement distance (computed BEFORE prevRawPositions was overwritten)
            const moved = busMovedCache[busNum];
            if (moved !== undefined && moved < 5) { busStatusCache[busNum] = 'Idle'; return 'Idle'; }
            busStatusCache[busNum] = 'Moving'; return 'Moving';
        }
        function getRouteById(id) { return routeMap[id] || allRoutes.find(r => r.id === id); }
        function getStopsForBus(route, position, busNum) {
            if (!route || !route.waypoints || route.waypoints.length === 0) return { last: null, next: null };
            // Terminal status handling
            const terminal = busNum ? busTerminalStatus[busNum] : null;
            const getName = (idx) => (route.stops && route.stops[idx]) ? route.stops[idx] : `Stop ${idx + 1}`;
            if (terminal === 'at_destination') {
                return { last: busCurrentStop[busNum] || 'Destination', next: null };
            }
            if (terminal === 'at_start') {
                const dirS = busDirection[busNum];
                const curIdx = busNearestStopCache[busNum] ? busNearestStopCache[busNum].idx : 0;
                const nextIdx = dirS === 'up' ? Math.max(0, curIdx - 1) : Math.min(route.waypoints.length - 1, curIdx + 1);
                return { last: null, next: nextIdx !== curIdx ? getName(nextIdx) : null };
            }
            // Use cached nearest stop from updateBusStopInfo if available
            const cached = busNum ? busNearestStopCache[busNum] : null;
            let bestIdx, bestD;
            if (cached) { bestIdx = cached.idx; bestD = cached.dist; }
            else { bestIdx = 0; bestD = Infinity; for (let i = 0; i < route.waypoints.length; i++) { const d = calcDistance(position[0], position[1], route.waypoints[i][0], route.waypoints[i][1]); if (d < bestD) { bestD = d; bestIdx = i; } } }
            const dir = busNum ? busDirection[busNum] : null;
            let lastIdx, nextIdx;
            if (dir === 'up') {
                // Moving toward index 0
                lastIdx = Math.min(route.waypoints.length - 1, bestIdx + 1);
                nextIdx = Math.max(0, bestIdx - 1);
                if (bestIdx === 0) { lastIdx = 1; nextIdx = 0; }
                if (bestIdx === route.waypoints.length - 1) { lastIdx = bestIdx; }
            } else {
                // Moving toward last stop ('down' or unknown)
                lastIdx = Math.max(0, bestIdx - 1);
                nextIdx = Math.min(route.waypoints.length - 1, bestIdx + 1);
                if (bestIdx === 0) { lastIdx = 0; }
                if (bestIdx === route.waypoints.length - 1) { lastIdx = bestIdx - 1; nextIdx = bestIdx; }
            }
            // If bus is AT the nearest stop, last=current stop, next=the one ahead in direction
            if (bestD <= AT_STOP_THRESHOLD) {
                lastIdx = bestIdx;
                if (dir === 'up') { nextIdx = Math.max(0, bestIdx - 1); }
                else { nextIdx = Math.min(route.waypoints.length - 1, bestIdx + 1); }
                // If at terminal, next is same as current
                if (nextIdx === bestIdx) nextIdx = bestIdx;
            }
            return {
                last: getName(lastIdx),
                next: (nextIdx !== lastIdx) ? getName(nextIdx) : null
            };
        }
        function buildBusPopup(busNum, busData) {
            const routeId = busRouteMap[busNum]; const route = getRouteById(routeId); const position = [busData.lat, busData.lng]; const status = determineStatus(busNum, position, busData.lastUpdate); const speed = busSpeedCache[busNum] || null; const routeName = route ? route.name : '--'; const last = busData.lastUpdate ? new Date(busData.lastUpdate).toLocaleTimeString() : '--';
            const statusColor = status==='Moving'?'#34d399':status==='At Stop'?'#5AC8FA':status==='Idle'?'#fbbf24':status==='Reached Destination'?'#a78bfa':status==='At Start'?'#60a5fa':status==='Waiting for Update'?'#fbbf24':'#fb7185';
            const atStopName = busCurrentStop[busNum];
            const speedDisplay = (speed !== null && speed !== undefined) ? speed + ' km/h' : '--';
            const stops = route ? getStopsForBus(route, position, busNum) : { last: null, next: null };
            const statusText = (status === 'Reached Destination' && atStopName) ? `Reached: ${atStopName}` : (status === 'At Start' && atStopName) ? `At Start: ${atStopName}` : (status === 'At Stop' && atStopName) ? `At Stop: ${atStopName}` : status;
            let html = `<div style="min-width:220px;background:#0f1220;color:#e6eef8;border:1px solid rgba(255,255,255,0.08);border-radius:10px;padding:10px">`;
            html += `<div style="font-weight:600;margin-bottom:6px">Transport ${busNum}</div>`;
            html += `<div style="font-size:13px;color:#9aa4b2">Route: <span style="color:#dbeafe">${routeName}</span></div>`;
            html += `<div style="font-size:13px;color:#9aa4b2">Status: <span style="color:${statusColor}">${statusText}</span></div>`;
            html += `<div style="font-size:13px;color:#9aa4b2">Speed: <span style="color:#dbeafe">${speedDisplay}</span></div>`;
            html += `<div style="font-size:13px;color:#9aa4b2">Last stop: <span style="color:#dbeafe">${stops.last || '--'}</span></div>`;
            html += `<div style="font-size:13px;color:#9aa4b2">Next stop: <span style="color:#dbeafe">${stops.next || '--'}</span></div>`;
            html += `<div style="font-size:11px;color:#667;margin-top:4px">Updated: ${last}</div>`;
            html += `</div>`;
            return html;
        }

        function updateLayerVisibility(layer, visible) {
            visibleLayers[layer] = visible;
            refreshLayerToggleUi();
            pulseLayerChangeUI();
            scheduleSpatialSync();
            refreshMapStatusPanel();
        }

        function loadHostels() {
            fetch('/api/hostels')
                .then(r => r.json())
                .then(hostels => {
                    Object.values(hostelMarkers).forEach(m => { try { map.removeLayer(m); } catch(e) {} });
                    hostelMarkers = {};
                    const ctx = getRenderContext();
                    hostels.forEach(hostel => {
                        const marker = L.marker([hostel.lat, hostel.lng], { icon: createLocationIcon('hostel'), title: hostel.name });
                        marker.bindPopup(`<b>${hostel.name}</b><br>Capacity: ${hostel.capacity}`);
                        hostelMarkers[hostel.id] = marker;
                        const show = !!visibleLayers.hostels && isPointRenderableByContext(hostel.lat, hostel.lng, null, ctx);
                        if (show) marker.addTo(map);
                    });
                    scheduleSpatialSync();
                })
                .catch(e => console.error('Error loading hostels:', e));
        }
        function loadClasses() {
            fetch('/api/classes')
                .then(r => r.json())
                .then(classes => {
                    Object.values(classMarkers).forEach(m => { try { map.removeLayer(m); } catch(e) {} });
                    classMarkers = {};
                    const ctx = getRenderContext();
                    classes.forEach(cls => {
                        const marker = L.marker([cls.lat, cls.lng], { icon: createLocationIcon('class'), title: cls.name });
                        marker.bindPopup(`<b>${cls.name}</b><br>Dept: ${cls.department}`);
                        classMarkers[cls.id] = marker;
                        const show = !!visibleLayers.classes && isPointRenderableByContext(cls.lat, cls.lng, null, ctx);
                        if (show) marker.addTo(map);
                    });
                    scheduleSpatialSync();
                })
                .catch(e => console.error('Error loading classes:', e));
        }

        function renderRoutesEmptyState(container, message = 'Search a destination to see route suggestions') {
            if (!container) return;
            container.innerHTML = `<div class="routes-empty-state"><span class="empty-icon" aria-hidden="true">&#128270;</span><span>${message}</span></div>`;
        }
        function animateRouteVisualIn(routeId, coords, polyline, glowLine, baseVisual) {
            if (!polyline || !glowLine || !Array.isArray(coords) || coords.length < 2) return;
            const rid = String(routeId);
            const prevState = routeLineAnimState[rid];
            if (prevState && prevState.raf) {
                try { cancelAnimationFrame(prevState.raf); } catch (e) {}
            }
            routeLineAnimState[rid] = { raf: null };
            if (isLowPerfMode() || coords.length < 3) {
                polyline.setLatLngs(coords);
                glowLine.setLatLngs(coords);
                polyline.setStyle({ opacity: baseVisual.mainOpacity, weight: baseVisual.mainWeight });
                glowLine.setStyle({ opacity: baseVisual.glowOpacity, weight: baseVisual.glowWeight });
                return;
            }
            const first = coords[0];
            polyline.setLatLngs([first, first]);
            glowLine.setLatLngs([first, first]);
            polyline.setStyle({ opacity: 0, weight: baseVisual.mainWeight });
            glowLine.setStyle({ opacity: 0, weight: baseVisual.glowWeight });
            const start = performance.now();
            const duration = 340;
            const step = (now) => {
                const t = Math.max(0, Math.min(1, (now - start) / duration));
                const drawCount = Math.max(2, Math.floor(1 + (coords.length - 1) * t));
                const slice = coords.slice(0, drawCount);
                polyline.setLatLngs(slice);
                glowLine.setLatLngs(slice);
                polyline.setStyle({ opacity: baseVisual.mainOpacity * t, weight: baseVisual.mainWeight });
                glowLine.setStyle({ opacity: baseVisual.glowOpacity * t, weight: baseVisual.glowWeight });
                if (t < 1) {
                    routeLineAnimState[rid].raf = requestAnimationFrame(step);
                } else {
                    polyline.setLatLngs(coords);
                    glowLine.setLatLngs(coords);
                    polyline.setStyle({ opacity: baseVisual.mainOpacity, weight: baseVisual.mainWeight });
                    glowLine.setStyle({ opacity: baseVisual.glowOpacity, weight: baseVisual.glowWeight });
                    routeLineAnimState[rid].raf = null;
                }
            };
            routeLineAnimState[rid].raf = requestAnimationFrame(step);
        }

        function getRouteDisplayCoords(route) {
            if (!route) return [];
            const followRoads = !!route.follow_roads;
            const pathPoints = Array.isArray(route.path_points) ? route.path_points : null;
            if (followRoads && pathPoints && pathPoints.length >= 2) return pathPoints;
            return Array.isArray(route.waypoints) ? route.waypoints : [];
        }

        function loadRoutes() {
            fetch('/api/routes').then(r => r.json()).then(routes => {
                Object.values(routePolylines).forEach(p => { try { map.removeLayer(p); } catch(e) {} });
                routePolylines = {};
                Object.values(routeLineAnimState).forEach((st) => {
                    if (!st || !st.raf) return;
                    try { cancelAnimationFrame(st.raf); } catch (e) {}
                });
                Object.keys(routeLineAnimState).forEach((k) => { delete routeLineAnimState[k]; });
                allRoutes = routes || [];
                allRoutesBounds = null;
                Object.keys(routeMap).forEach((k) => { delete routeMap[k]; });
                Object.keys(routeBoundsCache).forEach((k) => { delete routeBoundsCache[k]; });
                Object.keys(routeCoordsCache).forEach((k) => { delete routeCoordsCache[k]; });
                Object.keys(routeCumulDistCache).forEach((k) => { delete routeCumulDistCache[k]; });
                Object.keys(routeGeometryEnhanceState).forEach((k) => { delete routeGeometryEnhanceState[k]; });

                for (let i = 0; i < allRoutes.length; i++) {
                    const route = allRoutes[i];
                    routeMap[route.id] = route;
                    const displayCoords = getRouteDisplayCoords(route);
                    cacheRouteBounds(route.id, (displayCoords && displayCoords.length) ? displayCoords : route.waypoints);
                }
                rebuildAllRoutesBounds();
                if (!_initialViewportApplied) applyMapViewportForContext(false);

                const addRouteVisual = (route) => {
                    const displayCoords = getRouteDisplayCoords(route);
                    const safeCoords = (displayCoords && displayCoords.length >= 2) ? displayCoords : [];
                    if (!safeCoords.length) return;
                    cacheRouteCoords(route.id, safeCoords);
                    cacheRouteBounds(route.id, safeCoords);
                    const ctx = getRenderContext();
                    const showRoute = !!visibleLayers.routes && shouldRenderRouteByContext(route.id, ctx);
                    const glowLine = L.polyline(safeCoords, {
                        color: route.color,
                        weight: 12,
                        opacity: 0.16,
                        lineCap: 'round',
                        lineJoin: 'round',
                        interactive: false,
                        className: 'route-glow-line'
                    });
                    const polyline = L.polyline(safeCoords, {
                        color: route.color,
                        weight: 4,
                        opacity: 0.8,
                        dashArray: '5, 5',
                        className: 'route-main-line'
                    });

                    const getBaseRouteVisual = () => {
                        const isSelected = selectedRouteId && String(route.id) === String(selectedRouteId);
                        return {
                            mainOpacity: isSelected ? 1 : (selectedRouteId ? 0.3 : 0.8),
                            glowOpacity: isSelected ? 0.24 : (selectedRouteId ? 0.08 : 0.16),
                            mainWeight: isSelected ? 5 : 4,
                            glowWeight: isSelected ? 14 : 12
                        };
                    };
                    const baseVisual = getBaseRouteVisual();
                    polyline.setLatLngs(safeCoords);
                    glowLine.setLatLngs(safeCoords);
                    polyline.setStyle({ opacity: baseVisual.mainOpacity, weight: baseVisual.mainWeight });
                    glowLine.setStyle({ opacity: baseVisual.glowOpacity, weight: baseVisual.glowWeight });

                    polyline.bindPopup(`<b>${route.name}</b>`);
                    polyline.on('click', () => selectRoute(route.id));

                    const applyHoverVisual = (hovering) => {
                        if (isLowPerfMode()) return;
                        const v = getBaseRouteVisual();
                        polyline.setStyle({
                            opacity: Math.min(1, v.mainOpacity + (hovering ? 0.18 : 0)),
                            weight: (v.mainWeight === 5 || hovering) ? 5 : 4
                        });
                        glowLine.setStyle({
                            opacity: Math.min(0.35, v.glowOpacity + (hovering ? 0.10 : 0)),
                            weight: (v.glowWeight === 14 || hovering) ? 14 : 12
                        });
                    };
                    polyline.on('mouseover', () => applyHoverVisual(true));
                    polyline.on('mouseout', () => applyHoverVisual(false));

                    route.waypoints.forEach((wp, idx) => {
                        const stopName = (route.stops && route.stops[idx]) || `Stop ${idx + 1}`;
                        const icon = L.divIcon({
                            className: 'marker-wrapper',
                            html: `<span class=\"tiny-marker\" style=\"background:${route.color}\"></span>`,
                            iconSize: [10, 10],
                            iconAnchor: [5, 5]
                        });
                        const marker = L.marker([wp[0], wp[1]], { icon });
                        marker.bindTooltip(stopName, { direction: 'top', offset: [0, -8] });
                        marker.on('click', () => selectRoute(route.id));
                        routePolylines[`${route.id}-stop-${idx}`] = marker;
                        if (showRoute) marker.addTo(map);
                    });

                    routePolylines[`${route.id}-glow`] = glowLine;
                    routePolylines[route.id] = polyline;
                    if (showRoute) {
                        glowLine.addTo(map);
                        polyline.addTo(map);
                        try { glowLine.bringToBack(); } catch(e) {}
                        animateRouteVisualIn(route.id, safeCoords, polyline, glowLine, baseVisual);
                    }
                };

                renderRoutesList(allRoutes);
                let cursor = 0;
                const BATCH_SIZE = 3;
                const renderBatch = () => {
                    const end = Math.min(allRoutes.length, cursor + BATCH_SIZE);
                    for (; cursor < end; cursor++) {
                        addRouteVisual(allRoutes[cursor]);
                    }
                    if (cursor < allRoutes.length) {
                        setTimeout(renderBatch, 0);
                        return;
                    }
                    rebuildAllRoutesBounds();
                    scheduleSpatialSync();
                    if (!_initialViewportApplied) applyMapViewportForContext(false);
                    if (selectedRouteId) {
                        const routeObj = getRouteById(selectedRouteId);
                        if (routeObj) maybeEnhanceRouteGeometry(routeObj);
                    }
                };
                renderBatch();
            }).catch(e => console.error('Error loading routes:', e));
        }

        function setRouteGeometry(routeId, latlngs) {
            if (!latlngs || latlngs.length < 2) return;
            const rid = String(routeId);
            cacheRouteCoords(rid, latlngs);
            cacheRouteBounds(rid, latlngs);
            delete routeCumulDistCache[rid];
            const glow = routePolylines[`${rid}-glow`];
            const main = routePolylines[rid];
            if (glow && glow.setLatLngs) {
                try { glow.setLatLngs(latlngs); } catch (e) {}
            }
            if (main && main.setLatLngs) {
                try { main.setLatLngs(latlngs); } catch (e) {}
            }
        }
        function maybeEnhanceRouteGeometry(route) {
            if (!route || !route.waypoints || route.waypoints.length < 2 || isLowPerfMode()) return;
            if (!route.follow_roads) return;
            const rid = String(route.id);
            if (Array.isArray(route.path_points) && route.path_points.length >= 2) {
                setRouteGeometry(rid, route.path_points);
                routeGeometryEnhanceState[rid] = 'done';
                return;
            }
            const state = routeGeometryEnhanceState[rid];
            if (state === 'pending' || state === 'done') return;
            routeGeometryEnhanceState[rid] = 'pending';
            getOSRMRoute(route.waypoints)
                .then((routeCoords) => {
                    routeGeometryEnhanceState[rid] = 'done';
                    if (!routeCoords || routeCoords.length < 2) return;
                    setRouteGeometry(rid, routeCoords);
                    rebuildAllRoutesBounds();
                    scheduleSpatialSync();
                })
                .catch(() => {
                    routeGeometryEnhanceState[rid] = 'failed';
                });
        }

        // OSRM helpers with timeout + graceful fallback
        async function osrmFetch(url, timeoutMs=5000){
            const ctrl = new AbortController(); const t = setTimeout(()=>ctrl.abort(), timeoutMs);
            try{ const res = await fetch(url, { signal: ctrl.signal }); clearTimeout(t); if(!res.ok) throw new Error(`HTTP ${res.status}`); return await res.json(); }catch(e){ clearTimeout(t); throw e; }
        }
        async function getOSRMRoute(waypoints) {
            try { if (waypoints.length < 2) return waypoints; const coords = waypoints.map(wp => `${wp[1]},${wp[0]}`).join(';'); const url = `https://router.project-osrm.org/route/v1/driving/${coords}?geometries=geojson`; const data = await osrmFetch(url, 5000); if (data.routes && data.routes[0]) { return data.routes[0].geometry.coordinates.map(c => [c[1], c[0]]); } return waypoints; } catch(e) { console.warn('OSRM route fallback:', e); return waypoints; }
        }

        async function getOSRMDuration(fromLatLng, toLatLng) {
            try { const coords = `${fromLatLng[1]},${fromLatLng[0]};${toLatLng[1]},${toLatLng[0]}`; const url = `https://router.project-osrm.org/route/v1/driving/${coords}?overview=false`; const data = await osrmFetch(url, 5000); if (data.routes && data.routes[0]) { return { distance: data.routes[0].distance, duration: data.routes[0].duration }; } } catch(e) { console.warn('OSRM duration fallback:', e); }
            // Fallback: straight-line distance and average speed
            const meters = calcDistance(fromLatLng[0], fromLatLng[1], toLatLng[0], toLatLng[1]); const avgKmh = 25; const duration = Math.ceil((meters/1000)/avgKmh * 3600); return { distance: meters, duration };
        }
        async function getOSRMMinDurationToStop(busPoints, stopPoint) { try { if (!busPoints || busPoints.length === 0 || !stopPoint) return null; const points = [...busPoints, stopPoint]; const destIndex = points.length - 1; const coords = points.map(p => `${p[1]},${p[0]}`).join(';'); const sources = busPoints.map((_, i) => i).join(';'); const url = `https://router.project-osrm.org/table/v1/driving/${coords}?sources=${sources}&destinations=${destIndex}`; const res = await fetch(url); const data = await res.json(); if (data && data.durations && Array.isArray(data.durations)) { const mins = data.durations.map(row => row && row.length ? row[0] : Infinity).reduce((a, b) => Math.min(a, b), Infinity); return isFinite(mins) ? mins : null; } } catch(e) { console.error('OSRM table error:', e); } return null; }

        function renderRoutesList(routes) {
            const container = _dom.routesContainer || document.getElementById('routesContainer'); if (routes.length === 0) { container.innerHTML = '<div style="text-align:center; color:#666; font-size:12px">No routes available</div>'; return; }
            container.innerHTML = '';
            routes.forEach(route => {
                const chip = document.createElement('button');
                const isActive = String(selectedRouteId) === String(route.id);
                chip.className = `route-chip ${isActive ? 'active' : ''}`;
                chip.style.borderColor = route.color;
                chip.textContent = route.name;
                chip.setAttribute('aria-selected', isActive ? 'true' : 'false');
                if (isActive) {
                    chip.style.boxShadow = `0 0 0 2px ${route.color}55`;
                    chip.style.background = 'rgba(255,255,255,0.08)';
                }
                chip.addEventListener('click', () => { selectRoute(route.id); });
                container.appendChild(chip);
            });
        }
        function updateRouteSummaryPanel(route, busesOnRoute, pickupName, dropName) {
            const titleEl = _dom.routeSummaryTitle || document.getElementById('routeSummaryTitle');
            const metaEl = _dom.routeSummaryMeta || document.getElementById('routeSummaryMeta');
            const listEl = _dom.routeSummaryList || document.getElementById('routeSummaryList');
            if (!titleEl || !metaEl || !listEl) return;

            if (!route) {
                titleEl.textContent = 'Full route: Select a route';
                metaEl.textContent = 'Transports sorted by shortest total ETA';
                listEl.innerHTML = '<span class="route-summary-empty">Pick a route to see fastest transports.</span>';
                return;
            }

            const pickup = pickupName || '--';
            const drop = dropName || '--';
            const firstStop = (route.stops && route.stops.length > 0) ? route.stops[0] : 'Start';
            const lastStop = (route.stops && route.stops.length > 1) ? route.stops[route.stops.length - 1] : 'End';
            titleEl.textContent = `Full route: ${route.name} (${firstStop} \u2192 ${lastStop})`;
            metaEl.textContent = `Pickup: ${pickup} \u2192 Drop: ${drop}`;

            if (!Array.isArray(busesOnRoute) || busesOnRoute.length === 0) {
                listEl.innerHTML = '<span class="route-summary-empty">No active transport on this route.</span>';
                return;
            }

            listEl.innerHTML = busesOnRoute.slice(0, 6).map((bus, idx) => {
                const waitEta = bus.etaSecRaw === -1 ? 'Reached' : (bus.etaSec === 0 ? 'At stop' : formatEtaMinutes(bus.etaSec));
                const totalEta = formatEtaMinutes(bus.totalSec);
                const cls = idx === 0 ? 'route-summary-pill best' : 'route-summary-pill';
                return `<button type="button" class="${cls}" data-bus="${bus.busNum}"><span class="rs-bus">#${bus.busNum}</span><span class="rs-sep">\u2022</span><span class="rs-wait">${waitEta}</span><span class="rs-sep">\u2022</span><span class="rs-total">${totalEta}</span></button>`;
            }).join('');

            listEl.querySelectorAll('button[data-bus]').forEach((btn) => {
                btn.addEventListener('click', () => {
                    const busNum = String(btn.getAttribute('data-bus') || '');
                    if (!busNum) return;
                    const nextTracked = setTrackedBus(busNum, { toggleIfSame: true });
                    const busData = latestBuses[busNum];
                    if (nextTracked && busData && map) map.setView([busData.lat, busData.lng], DEFAULT_TILE_ZOOM);
                });
            });
        }

        function renderRouteBusByETA() {
            const container = _dom.routeBusList || document.getElementById('routeBusList');
            if (!container) return;
            if (!selectedRouteId) {
                renderRoutesEmptyState(container, 'Search a destination to see route suggestions');
                recommendedPulseRouteId = null;
                animatedCardsRouteId = null;
                setRouteStackFlowState(false);
                updateRouteSummaryPanel(null, [], '', '');
                return;
            }
            const route = getRouteById(selectedRouteId);
            if (!route || !route.waypoints || route.waypoints.length === 0) {
                renderRoutesEmptyState(container, 'Search a destination to see route suggestions');
                recommendedPulseRouteId = null;
                animatedCardsRouteId = null;
                setRouteStackFlowState(false);
                updateRouteSummaryPanel(null, [], '', '');
                return;
            }
            const refLocation = (userLocation && userLocation.length === 2) ? userLocation : (map ? [map.getCenter().lat, map.getCenter().lng] : null);
            let nearestStop = route.waypoints[0], nearestStopIdx = 0;
            if (refLocation) {
                let minD = Infinity;
                route.waypoints.forEach((wp, idx) => { const d = calcDistance(refLocation[0], refLocation[1], wp[0], wp[1]); if (d < minD) { minD = d; nearestStop = wp; nearestStopIdx = idx; } });
            }
            const destination = assistantDestinationPoint || nearestStop;
            const dropMeta = getNearestStopForRoute(route, destination);
            const dropStop = dropMeta.stop || nearestStop;
            const dropStopIdx = dropMeta.idx >= 0 ? dropMeta.idx : nearestStopIdx;
            const nowMs = Date.now();
            const walkStartSec = refLocation ? Math.ceil(calcDistance(refLocation[0], refLocation[1], nearestStop[0], nearestStop[1]) / WALK_SPEED_MPS) : 0;
            const walkEndSec = destination ? Math.ceil(calcDistance(destination[0], destination[1], dropStop[0], dropStop[1]) / WALK_SPEED_MPS) : 0;
            const busesOnRoute = [];
            Object.entries(latestBuses).forEach(([busNum, b]) => {
                if (!b || typeof b.lat !== 'number' || typeof b.lng !== 'number') return;
                const rid = (b.routeId != null) ? String(b.routeId) : (busRouteMap[busNum] != null ? String(busRouteMap[busNum]) : null);
                if (rid !== String(selectedRouteId)) return;
                const t = b.lastUpdate ? parseIsoTime(b.lastUpdate) : null;
                const lastSeen = busLastSeen[busNum] || 0;
                const effectiveTime = Math.max(lastSeen, t || 0);
                if (!effectiveTime || (nowMs - effectiveTime) > OFFLINE_MS) return;
                const rdId = rid;
                const distM = getRouteDistanceBetween(rdId, [b.lat, b.lng], nearestStop) || calcDistance(b.lat, b.lng, nearestStop[0], nearestStop[1]);
                const chosenTerminal = busTerminalStatus[busNum];
                let etaSecRaw;
                if (chosenTerminal === 'at_destination') etaSecRaw = -1;
                else if (distM <= AT_STOP_THRESHOLD) etaSecRaw = 0;
                else etaSecRaw = Math.ceil(((distM / 1000) / 12) * 3600);
                const rideDist = getRouteDistanceBetween(rdId, nearestStop, dropStop) || calcDistance(nearestStop[0], nearestStop[1], dropStop[0], dropStop[1]);
                const rideSec = Math.max(120, Math.ceil(((rideDist / 1000) / RIDE_SPEED_KMH) * 3600));
                const etaSec = applyLeaveOffsetToEta(etaSecRaw);
                const waitSec = etaSec >= 0 ? etaSec : 0;
                const totalSec = waitSec + rideSec + walkStartSec + walkEndSec;
                const status = busStatusCache[busNum] || determineStatus(busNum, [b.lat, b.lng], b.lastUpdate);
                const stops = getStopsForBus(route, [b.lat, b.lng], busNum);
                busesOnRoute.push({
                    busNum,
                    etaSecRaw,
                    etaSec,
                    waitSec,
                    rideSec,
                    totalSec,
                    status,
                    nextStop: stops.next || ((route.stops && route.stops[dropStopIdx]) ? route.stops[dropStopIdx] : `Stop ${dropStopIdx + 1}`),
                    traffic: estimateTrafficLevel(busNum, status),
                    delay: estimateDelayLevel(busNum, etaSecRaw),
                    crowd: estimateCrowdLevel()
                });
            });
            busesOnRoute.sort((a, b) => a.totalSec - b.totalSec);

            const nearestStopName = (route.stops && route.stops[nearestStopIdx]) || ('Stop ' + (nearestStopIdx + 1));
            const nextStopName = (route.stops && route.stops[dropStopIdx]) || (dropStopIdx >= 0 && dropStopIdx < route.waypoints.length ? ('Stop ' + (dropStopIdx + 1)) : null);
            if (busesOnRoute.length === 0) {
                renderRoutesEmptyState(container, 'Search a destination to see route suggestions');
                recommendedPulseRouteId = null;
                animatedCardsRouteId = null;
                setRouteStackFlowState(false);
                updateRouteSummaryPanel(route, [], nearestStopName, nextStopName || '--');
                return;
            }
            const sortLabel = document.getElementById('routeSortLabel');
            if (sortLabel) {
                const leaveOffset = getLeaveOffsetMinutes();
                sortLabel.textContent = leaveOffset > 0
                    ? `Routes sorted by fastest arrival - leave in ${leaveOffset} min - Pickup: ${nearestStopName} - Destination: ${nextStopName || '--'}`
                    : `Routes sorted by fastest arrival - Pickup: ${nearestStopName} - Destination: ${nextStopName || '--'}`;
            }

            const frag = document.createDocumentFragment();
            const shouldAnimateCards = animatedCardsRouteId !== String(selectedRouteId);
            const shouldPulseRecommended = recommendedPulseRouteId !== String(selectedRouteId);

            busesOnRoute.forEach((bus, idx) => {
                const colorIdx = (parseInt(bus.busNum) || 0);
                const color = colors[(colorIdx > 0 ? colorIdx - 1 : 0) % colors.length];
                const colorHex = (typeof color === 'string' && /^#[0-9a-fA-F]{6}$/.test(color)) ? color : '#9fa9ff';
                const etaDisplay = bus.etaSecRaw === -1 ? 'Reached' : bus.etaSec === 0 ? 'At Stop' : formatMinSec(bus.etaSec);
                const statusColor = bus.status==='Moving'?'#34d399':bus.status==='At Stop'?'#5AC8FA':bus.status==='Idle'?'#fbbf24':bus.status==='Reached Destination'?'#a78bfa':bus.status==='At Start'?'#60a5fa':bus.status==='Waiting for Update'?'#fbbf24':'#fb7185';
                const isTracked = trackedBus && trackedBus === bus.busNum;
                const card = document.createElement('div');
                card.className = idx === 0
                    ? 'route-result-card route-detail-card recommended'
                    : 'route-result-card transport-card';
                if (shouldAnimateCards) {
                    card.classList.add('route-card-enter');
                    card.style.animationDelay = `${Math.min(idx, 6) * 34}ms`;
                }
                if (idx === 0 && shouldPulseRecommended) {
                    card.classList.add('recommend-pop-once');
                }
                card.dataset.busNum = String(bus.busNum);
                card.setAttribute('aria-selected', isTracked ? 'true' : 'false');
                if (isTracked) {
                    card.classList.add('route-result-selected');
                    card.style.setProperty('--route-selected-border', `${colorHex}a8`);
                    card.style.setProperty('--route-selected-glow', `${colorHex}2f`);
                    card.style.setProperty('--route-selected-tint-strong', `${colorHex}26`);
                    card.style.setProperty('--route-selected-tint', `${colorHex}14`);
                }
                card.addEventListener('click', () => {
                    flashElement(card, `route_bus_pick_${bus.busNum}`, 220);
                    const nextTracked = setTrackedBus(bus.busNum, { toggleIfSame: true });
                    const bd = latestBuses[bus.busNum];
                    if (nextTracked && bd) map.setView([bd.lat, bd.lng], DEFAULT_TILE_ZOOM);
                });

                const trafficClass = statusLevelClass('traffic', bus.traffic);
                const delayClass = statusLevelClass('delay', bus.delay);
                const crowdClass = statusLevelClass('crowd', bus.crowd);
                const recommendedBadge = idx === 0 ? '<span class="route-badge-reco">Recommended</span>' : '';
                card.innerHTML = `
                    <div class="route-result-top">
                        <div class="route-result-left">
                            <div class="route-result-busdot" style="background:${color}">${bus.busNum}</div>
                            <div style="min-width:0">
                                <div class="route-result-name">${isTracked ? '&#10003; ' : ''}Transport ${bus.busNum}${recommendedBadge}</div>
                                <div class="route-result-nextstop">Next stop: ${bus.nextStop || '--'}</div>
                            </div>
                        </div>
                        <div style="text-align:right">
                            <div class="route-result-eta">${etaDisplay}</div>
                            <div style="font-size:10px;color:${statusColor}">${bus.status}</div>
                        </div>
                    </div>
                    <div class="timeline" aria-label="Journey flow">
                        <span title="Walk ${formatEtaMinutes(walkStartSec)}">Walk</span><span class="timeline-arrow" aria-hidden="true">&rarr;</span>
                        <span title="Wait ${formatEtaMinutes(bus.waitSec)}">Wait</span><span class="timeline-arrow" aria-hidden="true">&rarr;</span>
                        <span title="Ride ${formatEtaMinutes(bus.rideSec)}">Ride</span><span class="timeline-arrow" aria-hidden="true">&rarr;</span>
                        <span title="Walk ${formatEtaMinutes(walkEndSec)}">Walk</span>
                    </div>
                    <div class="route-status-tags">
                        <span class="status-pill ${trafficClass}">Traffic: ${bus.traffic}</span>
                        <span class="status-pill ${delayClass}">Delay: ${bus.delay}</span>
                        <span class="status-pill ${crowdClass}">Crowd: ${bus.crowd}</span>
                    </div>
                `;
                frag.appendChild(card);
            });
            container.textContent = '';
            container.appendChild(frag);
            setRouteStackFlowState(true);
            if (container.classList.contains('stack-flow')) applyRouteStackFlow(container);
            if (trackedBus) ensureTrackedRouteCardVisible(container, 'auto');
            updateRouteSummaryPanel(route, busesOnRoute, nearestStopName, nextStopName || '--');
            recommendedPulseRouteId = String(selectedRouteId);
            animatedCardsRouteId = String(selectedRouteId);
        }

        function selectRoute(routeId) {
            const newId = String(routeId);
            selectedRouteId = (selectedRouteId === newId) ? null : newId;
            if (selectedRouteId && trackedBus) {
                const trackedKey = String(trackedBus);
                const trackedData = latestBuses[trackedKey];
                const trackedRouteId = (trackedData && trackedData.routeId != null)
                    ? String(trackedData.routeId)
                    : (busRouteMap[trackedKey] != null ? String(busRouteMap[trackedKey]) : null);
                if (!trackedRouteId || trackedRouteId !== String(selectedRouteId)) {
                    setTrackedBus(null);
                }
            }
            syncRouteFocusedLayout();
            flashElement(_dom.mapStage || document.querySelector('.map-stage'), `route_select_${selectedRouteId || 'none'}`, 220);
            Object.entries(routePolylines).forEach(([id, polyline]) => {
                if (id.includes('-stop-')) return;
                try {
                    const isGlow = id.endsWith('-glow');
                    const routeKey = isGlow ? id.slice(0, -5) : id;
                    const isSelected = selectedRouteId === String(routeKey);
                    const opacity = isGlow
                        ? (isSelected ? 0.24 : (selectedRouteId ? 0.08 : 0.16))
                        : (isSelected ? 1 : (selectedRouteId ? 0.3 : 0.8));
                    const weight = isGlow ? (isSelected ? 14 : 12) : (isSelected ? 5 : 4);
                    polyline.setStyle({ opacity, weight });
                } catch(e) {}
            });
            renderRoutesList(allRoutes);
            renderRouteBusByETA();
            if (selectedRouteId) {
                const routeObj = getRouteById(routeId);
                if (routeObj) {
                    maybeEnhanceRouteGeometry(routeObj);
                    showRouteDetails(routeObj);
                    if(_dom.currentRouteOverlay) _dom.currentRouteOverlay.textContent = routeObj.name;
                    computeAndShowStudentETA();
                    flashElement(_dom.routeDetailsCard, `route_card_${selectedRouteId}`, 260);
                    setTimeout(ensureRouteDetailsVisible, 120);
                }
            } else {
                if (_dom.routeDetailsCard) _dom.routeDetailsCard.style.display = 'none';
                if (_dom.etaOverlay) _dom.etaOverlay.textContent = '--';
                if (_dom.etaValue) _dom.etaValue.textContent = '--';
                if (_dom.currentRouteOverlay) _dom.currentRouteOverlay.textContent = '--';
                if (walkingLine) { try { map.removeLayer(walkingLine); } catch(e){} walkingLine = null; }
            }
            // Blur non-selected route stops
            try {
                Object.entries(routePolylines).forEach(([id, marker]) => {
                    if (!id.includes('-stop-')) return;
                    const routeKey = id.split('-stop-')[0];
                    const isSelectedRoute = selectedRouteId && String(routeKey) === String(selectedRouteId);
                    if (marker && marker.getElement && marker.getElement()) {
                        const el = marker.getElement();
                        if (isSelectedRoute || !selectedRouteId) {
                            el.classList.remove('stop-blur');
                        } else {
                            el.classList.add('stop-blur');
                        }
                    }
                });
            } catch(e) { /* ignore */ }
            scheduleSpatialSync();
            applyMapViewportForContext(true);
            updateOperationalTiles();
        }

        async function showRouteDetails(route) {
            if(_dom.routeDetailsCard) _dom.routeDetailsCard.style.display = 'block'; const card = _dom.routeDetailsCard;
            const busesData = latestBuses || {};
            const busesOnRoute = Object.entries(busesData)
                .filter(([busNum, b]) => {
                    const rid = (b && b.routeId != null) ? b.routeId : busRouteMap[busNum];
                    return String(rid) === String(route.id);
                })
                .map(([busNum]) => busNum);
            if (_dom.busesOnRouteCount) _dom.busesOnRouteCount.textContent = busesOnRoute.length;
            let nearestStop = null; let minDist = Infinity; let nearestStopIdx = 0; const refLocation = (userLocation && userLocation.length === 2) ? userLocation : (map ? [map.getCenter().lat, map.getCenter().lng] : null);
            if (refLocation && route.waypoints.length > 0) {
                route.waypoints.forEach((stop, idx) => { const dist = calcDistance(refLocation[0], refLocation[1], stop[0], stop[1]); if (dist < minDist) { minDist = dist; nearestStop = stop; nearestStopIdx = idx; } });
                if (nearestStop) {
                    // Set nearest stop name and next stop name
                    const nearestStopName = (route.stops && route.stops[nearestStopIdx]) || (`Stop ${nearestStopIdx + 1}`);
                    const nextStopName = (route.stops && route.stops[nearestStopIdx + 1]) || (nearestStopIdx + 1 < route.waypoints.length ? `Stop ${nearestStopIdx + 2}` : null);
                    const walkMinutes = Math.max(1, Math.round((minDist / WALK_SPEED_MPS) / 60));
                    const walkProgress = Math.max(14, Math.min(100, Math.round((walkMinutes / 12) * 100)));
                    if (_dom.walkDistance) _dom.walkDistance.textContent = nearestStopName;
                    if (_dom.walkDuration) _dom.walkDuration.textContent = `~${walkMinutes} min walk`;
                    if (_dom.walkProgressFill) _dom.walkProgressFill.style.width = `${walkProgress}%`;
                    if (_dom.nextStop) _dom.nextStop.textContent = nextStopName ? `Next stop: ${nextStopName}` : '';

                    if (userLocation) {
                        if (walkingLine) map.removeLayer(walkingLine);
                        walkingLine = L.polyline([userLocation, nearestStop], { color: '#999999', weight: 2, opacity: 0.6, dashArray: '5, 5' }).addTo(map);
                    }
                }
            } else {
                if(_dom.walkDistance) _dom.walkDistance.textContent = '--';
                if(_dom.walkDuration) _dom.walkDuration.textContent = '~2 min walk';
                if(_dom.walkProgressFill) _dom.walkProgressFill.style.width = '22%';
                if(_dom.nextStop) _dom.nextStop.textContent = '';
            }
            // ETA computed separately to simplify: distance / speed
            if(_dom.etaValue) _dom.etaValue.innerHTML = '<span class="eta-spinner"></span>Updating'; if(_dom.etaOverlay) _dom.etaOverlay.innerHTML = '<span class="eta-spinner"></span>';
            studentEtaLastHtml = null; studentEtaLastTs = 0;
            computeAndShowStudentETA();
            requestAnimationFrame(() => {
                ensureRouteDetailsVisible();
                setTimeout(ensureRouteDetailsVisible, 120);
            });
        }
        function formatMinSec(totalSeconds){
            const m = Math.floor(totalSeconds/60);
            const s = totalSeconds % 60;
            return `${m}:${String(s).padStart(2,'0')}`;
        }

        // ETA smoothing to avoid flicker
        let studentEtaSmooth = null; let studentEtaLastTs = 0; const STUD_ETA_ALPHA = 0.62; const STUD_ETA_UPDATE_MS = 900; const STUD_ETA_MIN_STEP = 1; let studentEtaLastHtml = null;
        function smoothStudentEta(secs){ if(!isFinite(secs)) return secs; if(studentEtaSmooth==null){ studentEtaSmooth = secs; return secs; } const sm = STUD_ETA_ALPHA*secs + (1-STUD_ETA_ALPHA)*studentEtaSmooth; if(Math.abs(sm-studentEtaSmooth) < STUD_ETA_MIN_STEP){ studentEtaSmooth = studentEtaSmooth + Math.sign(sm-studentEtaSmooth) * STUD_ETA_MIN_STEP; } else { studentEtaSmooth = sm; } return Math.max(0, Math.round(studentEtaSmooth)); }
        function formatHHMM(totalSeconds){ const mins = Math.max(0, Math.round(totalSeconds/60)); const h = Math.floor(mins/60); const m = mins % 60; return h>0 ? `${h}:${String(m).padStart(2,'0')}` : `${m}m`; }
        function maybeUpdateStudentEta(html){
            const now = Date.now();
            const isFirst = studentEtaLastHtml === null;
            if((isFirst || now - studentEtaLastTs >= STUD_ETA_UPDATE_MS) && html !== studentEtaLastHtml){
                const decorated = decorateEtaHtml(html);
                if(_dom.etaValue) _dom.etaValue.innerHTML = decorated;
                if(_dom.etaOverlay) _dom.etaOverlay.innerHTML = decorated;
                studentEtaLastHtml = html;
                studentEtaLastTs = now;

                const plain = (typeof html === 'string') ? html.replace(/<[^>]*>/g, '').trim() : '';
                if (plain && plain !== '--' && !/updating/i.test(plain)) {
                    flashElement(_dom.routeDetailsCard, 'eta_update_card', 650);
                    flashElement(_dom.etaInfo, 'eta_update_overlay', 650);
                }
            }
        }

        async function computeAndShowStudentETA(busesDataParam){
            const busesData = busesDataParam || latestBuses || {};
            const nowMs = Date.now();
            const freshEntries = Object.entries(busesData).filter(([num,b])=>{ const t = b && b.lastUpdate ? parseIsoTime(b.lastUpdate) : null; const lastSeen = busLastSeen[num] || 0; const effectiveTime = Math.max(lastSeen, t || 0); return effectiveTime && (nowMs - effectiveTime) <= OFFLINE_MS; });
            const freshData = Object.fromEntries(freshEntries);

            // Determine active route context: tracked bus route first, else selected route
            let activeRoute = null; let nearestStop = null;
            let refLocation = (userLocation && userLocation.length === 2) ? userLocation : (map ? [map.getCenter().lat, map.getCenter().lng] : null);

            let chosenBusNum = trackedBus;
            let chosenBus = chosenBusNum ? freshData[chosenBusNum] : null;
            let routeId = chosenBus && chosenBus.routeId!=null ? chosenBus.routeId : (chosenBusNum ? busRouteMap[chosenBusNum] : null);

            if(routeId){ activeRoute = getRouteById(routeId); }
            if(!activeRoute && selectedRouteId){ activeRoute = getRouteById(selectedRouteId); }
            if(!activeRoute || !activeRoute.waypoints || activeRoute.waypoints.length===0){ maybeUpdateStudentEta('--'); return; }

            // Find nearest student stop
            if(refLocation){ let minD=Infinity; activeRoute.waypoints.forEach(stop=>{ const d = calcDistance(refLocation[0],refLocation[1], stop[0], stop[1]); if(d<minD){ minD=d; nearestStop=stop; } }); }
            if(!nearestStop){ nearestStop = activeRoute.waypoints[0]; }

            // Choose bus: if not tracked, pick bus on route nearest to that stop
            if(!chosenBusNum){
                const busesOnRoute = Object.entries(freshData).filter(([num,b])=>{ const rid = (b && b.routeId!=null) ? b.routeId : busRouteMap[num]; return String(rid) === String(activeRoute.id); });
                if(busesOnRoute.length===0){ maybeUpdateStudentEta('<span class="eta-spinner"></span>Updating'); return; }
                let bestNum=null, bestB=null, bestDist=Infinity;
                for(const [num,b] of busesOnRoute){ if(!b || typeof b.lat!=='number' || typeof b.lng!=='number') continue; const d = calcDistance(b.lat,b.lng, nearestStop[0], nearestStop[1]); if(d<bestDist){ bestDist=d; bestNum=num; bestB=b; } }
                chosenBusNum = bestNum; chosenBus = bestB;
                if(!chosenBus){ maybeUpdateStudentEta('<span class="eta-spinner"></span>Updating'); return; }
            }

            // Check terminal status
            const chosenTerminal = busTerminalStatus[chosenBusNum];
            if (chosenTerminal === 'at_destination') { maybeUpdateStudentEta('Reached'); return; }
            if (chosenTerminal === 'at_start') { maybeUpdateStudentEta('At Start'); return; }
            if (chosenTerminal === 'waiting') { maybeUpdateStudentEta('Waiting'); return; }

            // Route distance with dynamic speed when available (latency-first ETA response)
            const routeIdForDist = chosenBus.routeId || busRouteMap[chosenBusNum];
            const distMeters = getRouteDistanceBetween(routeIdForDist, [chosenBus.lat, chosenBus.lng], nearestStop) || calcDistance(chosenBus.lat, chosenBus.lng, nearestStop[0], nearestStop[1]);

            if (distMeters <= AT_STOP_THRESHOLD) { maybeUpdateStudentEta('At Stop'); return; }

            const speedKmh = Math.max(8, Math.min(45, busSpeedCache[chosenBusNum] || 12));
            const seconds = Math.ceil(((distMeters / 1000) / speedKmh) * 3600);
            const etaAdjustedSec = applyLeaveOffsetToEta(seconds);
            const smoothed = smoothStudentEta(etaAdjustedSec);
            const etaStr = formatMinSec(Math.round(smoothed));
            maybeUpdateStudentEta(etaStr);
        }

        function estimateRouteDistance(waypoints) { let total = 0; for (let i = 0; i < waypoints.length - 1; i++) { total += calcDistance(waypoints[i][0], waypoints[i][1], waypoints[i+1][0], waypoints[i+1][1]); } return total / 1000; }

        function getMarkerOpacity(isTracked, isOffline) {
            if (isOffline) return (trackedBus && !isTracked) ? 0.1 : 0.3;
            if (trackedBus) return isTracked ? 1 : 0.2;
            return isTracked ? 1 : 0.7;
        }
        function setTrackedBus(busNum, options = {}) {
            const nextBus = (busNum === null || busNum === undefined || busNum === '') ? null : String(busNum);
            const toggleIfSame = !!(options && options.toggleIfSame);
            trackedBus = (toggleIfSame && nextBus && trackedBus === nextBus) ? null : nextBus;
            Object.keys(busMarkers).forEach(num => { const marker = busMarkers[num]; const isTracked = trackedBus && num === trackedBus; const rawPos = prevRawPositions[num]; const busData = latestBuses[num]; const status = (rawPos && busData) ? determineStatus(num, rawPos, busData.lastUpdate) : 'Offline'; const isOffline = status === 'Offline'; try { marker.setOpacity(getMarkerOpacity(!!isTracked, isOffline)); } catch(e) {} const color = colors[(parseInt(num) - 1) % colors.length]; const rid = busRouteMap[num]; const onSelectedRoute = selectedRouteId && String(rid) === String(selectedRouteId); const newIcon = createIcon(num, color, currentIconSize, prevBusRotation[num] || 0, isTracked || onSelectedRoute); marker.setIcon(newIcon); prevTrackedState[num] = !!isTracked; prevRouteSelState[num] = !!onSelectedRoute; });
            const rid = trackedBus ? busRouteMap[trackedBus] : null; if (rid) { if (String(rid) !== String(selectedRouteId)) { selectRoute(rid); } const routeObj = getRouteById(rid); if(routeObj) showRouteDetails(routeObj); }
            computeAndShowStudentETA();
            renderRouteBusByETA();
            ensureTrackedRouteCardVisible(null, 'smooth');
            scheduleSpatialSync();
            return trackedBus;
        }

        async function loadMetrics(){
            try{
                const res = await fetch('/api/metrics');
                const data = await res.json();
                if(_dom.totalTransportCount && typeof data.total_transports === 'number') _dom.totalTransportCount.textContent = data.total_transports;
            }catch(e){ /* ignore */ }
        }

        let mapTileBase = null;
        let mapTileLabels = null;
        let mapTileLabelsTimerId = null;
        let mapIsDark = true;
        const PERF_MODE_KEY = 'ui_perf_mode';
        const DARK_TILES = 'https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png';
        const DARK_LABELS = 'https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}{r}.png';
        const LIGHT_TILES = 'https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png';
        const LIGHT_LABELS = 'https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png';
        const TILE_OPTS = { attribution: '', maxZoom: 19, updateWhenIdle: true, updateWhenZooming: false, keepBuffer: 0, detectRetina: false };

        function isLowPerfMode() {
            return document.documentElement.classList.contains('low-perf');
        }
        function shouldUseLabelTiles() {
            const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            const effectiveType = (conn && conn.effectiveType) ? String(conn.effectiveType).toLowerCase() : '';
            const slowNetwork = !!(conn && (conn.saveData || effectiveType.includes('2g') || effectiveType === '3g'));
            const lowDeviceMemory = (typeof navigator.deviceMemory === 'number') && navigator.deviceMemory <= 4;
            return !isLowPerfMode() && !slowNetwork && !lowDeviceMemory;
        }

        function applyLowPerfMode(enabled, persist = true) {
            document.documentElement.classList.toggle('low-perf', !!enabled);
            const btn = document.getElementById('lowPerfBtn');
            if (btn) {
                btn.classList.toggle('active', !!enabled);
                btn.setAttribute('aria-pressed', enabled ? 'true' : 'false');
                btn.title = enabled ? 'Low performance mode: On' : 'Low performance mode: Off';
            }
            if (persist) {
                try { localStorage.setItem(PERF_MODE_KEY, enabled ? 'low' : 'normal'); } catch (e) {}
            }
            refreshFramePacing();
            if (enabled) {
                clearAllBusTrails();
                Object.keys(busTweens).forEach((k) => { delete busTweens[k]; });
                _tweenAnimRunning = false;
                _lastTweenFrameTs = 0;
            } else {
                refreshBusTrails();
            }
            setRouteStackFlowState(!!selectedRouteId);
            if (map) setMapTiles(mapIsDark);
            scheduleSpatialSync();
        }

        function toggleLowPerfMode() {
            applyLowPerfMode(!isLowPerfMode());
        }

        function setMapTiles(dark) {
            mapIsDark = dark;
            if (mapTileBase) { map.removeLayer(mapTileBase); }
            if (mapTileLabels) { map.removeLayer(mapTileLabels); }
            if (mapTileLabelsTimerId) { try { clearTimeout(mapTileLabelsTimerId); } catch (e) {} mapTileLabelsTimerId = null; }
            mapTileBase = L.tileLayer(dark ? DARK_TILES : LIGHT_TILES, TILE_OPTS).addTo(map);
            // Keep tiles behind markers
            mapTileBase.setZIndex(0);
            mapTileLabels = null;
            if (shouldUseLabelTiles()) {
                const labelsUrl = dark ? DARK_LABELS : LIGHT_LABELS;
                mapTileLabelsTimerId = setTimeout(() => {
                    mapTileLabelsTimerId = null;
                    if (!map) return;
                    mapTileLabels = L.tileLayer(labelsUrl, { ...TILE_OPTS, attribution: '' }).addTo(map);
                    mapTileLabels.setZIndex(1);
                }, 240);
            }
            const btn = document.getElementById('mapThemeBtn');
            if (btn) btn.textContent = dark ? 'Map Light' : 'Map Dark';
        }

        function toggleMapTheme() {
            setMapTiles(!mapIsDark);
        }

        function toggleGlobalTheme() {
            const body = document.body;
            const goingLight = !body.classList.contains('light-mode');
            body.classList.toggle('light-mode');
            const btn = document.getElementById('globalThemeBtn');
            if (btn) btn.textContent = goingLight ? 'Light' : 'Dark';
            // Global toggle also sets map to match
            setMapTiles(!goingLight);
        }

        function initMap() {
            cacheDom();
            syncRouteFocusedLayout();
            bindRouteStackFlow();
            bindAssistantInteractions();
            initSidebarScrollStabilizer();
            calibrateFramePacing();
            refreshFramePacing();
            map = L.map('map', {
                zoomControl: false,
                attributionControl: false,
                preferCanvas: true,
                markerZoomAnimation: false,
                fadeAnimation: false,
                zoomAnimation: !isLowPerfMode(),
                maxBounds: BHUBANESWAR_LIMIT_BOUNDS,
                maxBoundsViscosity: 1.0
            }).setView([20.3549, 85.8161], DEFAULT_TILE_ZOOM);
            setMapTiles(true);
            L.rectangle(BHUBANESWAR_LIMIT_BOUNDS, {
                color: '#22c55e',
                weight: 2,
                opacity: 0.8,
                fill: false,
                dashArray: '8,6',
                interactive: false
            }).addTo(map);
            refreshMapStatusPanel();
            ensureTrailPane();
            if (trailRefreshTimerId) { clearInterval(trailRefreshTimerId); trailRefreshTimerId = null; }
            trailRefreshTimerId = setInterval(() => {
                if (!isLowPerfMode()) refreshBusTrails();
            }, 1200);

            // Responsive icon sizing on zoom
            currentIconSize = getIconSizeForZoom(map.getZoom());
            map.on('zoomend', () => {
                const newSize = getIconSizeForZoom(map.getZoom());
                if (newSize !== currentIconSize) {
                    currentIconSize = newSize;
                    // Rebuild all bus icons at new size
                    Object.keys(busMarkers).forEach(busNum => {
                        const color = colors[(parseInt(busNum) - 1) % colors.length];
                        const rid = busRouteMap[busNum];
                        const onSelectedRoute = selectedRouteId && String(rid) === String(selectedRouteId);
                        const isTracked = trackedBus && busNum === trackedBus;
                        const icon = createIcon(busNum, color, currentIconSize, prevBusRotation[busNum] || 0, isTracked || onSelectedRoute);
                        busMarkers[busNum].setIcon(icon);
                    });
                }
                refreshMapStatusPanel();
            });
            map.on('moveend', () => { refreshMapStatusPanel(); scheduleSpatialSync(); });
            map.on('dragstart', () => setManualTrackingWindow(9000));
            const mapContainerEl = map.getContainer();
            if (mapContainerEl) {
                mapContainerEl.addEventListener('touchstart', () => setManualTrackingWindow(9000), { passive: true });
                mapContainerEl.addEventListener('wheel', () => setManualTrackingWindow(9000), { passive: true });
            }
            if(userLocation){
                updateUserMarker(userLocation);
                if (!selectedRouteId) applyMapViewportForContext(false);
            }
            updateBuses();
            busesPollTimerId = setInterval(updateBuses, POLL_INTERVAL_MS);
            initSSE();
            updateOperationalTiles();
            // Start prediction animation loop
            startPredictionLoop();
            setInterval(() => { if (!_predAnimRunning) startPredictionLoop(); }, 5000);
            loadBusRoutes();
            loadRoutes();
            // Defer non-critical data to keep first paint responsive
            setTimeout(() => { loadHostels(); loadClasses(); }, 320);
            setTimeout(() => { loadMetrics(); }, 900);
            document.getElementById('hostelsToggle').addEventListener('change', (e) => { updateLayerVisibility('hostels', e.target.checked); });
            document.getElementById('classesToggle').addEventListener('change', (e) => { updateLayerVisibility('classes', e.target.checked); });
            document.getElementById('routesToggle').addEventListener('change', (e) => { updateLayerVisibility('routes', e.target.checked); });
            refreshLayerToggleUi();
            refreshMapStatusPanel();
            // Pause polling when tab hidden; resume and force resync on show
            window.addEventListener('beforeunload', () => {
                if (_eventSource) { try { _eventSource.close(); } catch(e) {} }
                if (trailRefreshTimerId) { try { clearInterval(trailRefreshTimerId); } catch(e) {} trailRefreshTimerId = null; }
                if (mapManualTimerId) { try { clearTimeout(mapManualTimerId); } catch(e) {} mapManualTimerId = null; }
                if (sidebarScrollTimerId) { try { clearTimeout(sidebarScrollTimerId); } catch(e) {} sidebarScrollTimerId = null; }
                if (_spatialSyncTimer) { try { clearTimeout(_spatialSyncTimer); } catch (e) {} _spatialSyncTimer = null; }
                if (_busUiRefreshTimer) { try { clearTimeout(_busUiRefreshTimer); } catch (e) {} _busUiRefreshTimer = null; }
                if (mapTileLabelsTimerId) { try { clearTimeout(mapTileLabelsTimerId); } catch (e) {} mapTileLabelsTimerId = null; }
                if (viewerPresenceTimerId) { try { clearInterval(viewerPresenceTimerId); } catch (e) {} viewerPresenceTimerId = null; }
                if (assistantSearchDebounceId) { try { clearTimeout(assistantSearchDebounceId); } catch (e) {} assistantSearchDebounceId = null; }
                if (assistantSearchAnimTimerId) { try { clearTimeout(assistantSearchAnimTimerId); } catch (e) {} assistantSearchAnimTimerId = null; }
                if (routeStackFlowScrollTimerId) { try { clearTimeout(routeStackFlowScrollTimerId); } catch (e) {} routeStackFlowScrollTimerId = null; }
                if (routeStackFlowMomentumRaf) { try { cancelAnimationFrame(routeStackFlowMomentumRaf); } catch (e) {} routeStackFlowMomentumRaf = null; }
                routeStackFlowMomentumVelocity = 0;
                clearAssistantPreviewLine();
                if (userWatchId && navigator.geolocation) {
                    try { navigator.geolocation.clearWatch(userWatchId); } catch (e) {}
                    userWatchId = null;
                }
                refreshViewerPresence(true);
                sendStudentPresence(false, true);
            });
            document.addEventListener('visibilitychange', ()=>{
                if(document.hidden){
                    if(busesPollTimerId){ try{ clearInterval(busesPollTimerId); }catch(e){} busesPollTimerId=null; }
                    if(trailRefreshTimerId){ try{ clearInterval(trailRefreshTimerId); }catch(e){} trailRefreshTimerId = null; }
                    if (_busUiRefreshTimer) { try { clearTimeout(_busUiRefreshTimer); } catch (e) {} _busUiRefreshTimer = null; }
                    refreshMapStatusPanel();
                } else {
                    calibrateFramePacing();
                    refreshFramePacing();
                    refreshViewerPresence(false);
                    sendStudentPresence(true);
                    // Immediate resync on tab refocus
                    updateBuses();
                    // If SSE died while hidden, restart it
                    if(_eventSource && _eventSource.readyState === 2){ initSSE(); }
                    // Always ensure polling is running as fallback
                    if(!busesPollTimerId){ busesPollTimerId = setInterval(updateBuses, POLL_INTERVAL_MS); }
                    if(!trailRefreshTimerId){ trailRefreshTimerId = setInterval(() => { if (!isLowPerfMode()) refreshBusTrails(); }, 1200); }
                    refreshMapStatusPanel();
                }
            });
        }

        function updateBuses(force = false) {
            if (!force && _busFetchInFlight) {
                _busFetchQueued = true;
                return;
            }
            _busFetchInFlight = true;
            fetch('/api/buses').then(response => response.json()).then(buses => {
                latestBuses = buses || {};
                const nowMs = Date.now();
                const busNumbers = Object.keys(latestBuses);
                // Keep buses that have data  don't filter by time here, let status handle it
                const visibleBusNumbers = busNumbers.filter(n => {
                    const b = latestBuses[n];
                    if (!b || typeof b.lat !== 'number' || typeof b.lng !== 'number') return false;
                    const iso = b.lastUpdate; const t = iso ? parseIsoTime(iso) : null;
                    const lastSeen = busLastSeen[n] || 0;
                    const effectiveTime = Math.max(lastSeen, t || 0);
                    // Only fully remove after REMOVE_MS
                    return effectiveTime && (nowMs - effectiveTime) <= REMOVE_MS;
                });
                // Mark local receive time for all buses in this response
                visibleBusNumbers.forEach(n => { busLastSeen[n] = nowMs; });
                const freshBusNumbers = visibleBusNumbers;
                const freshBusSet = new Set(freshBusNumbers);
                let activeCount = 0;
                // Remove markers for buses missing or fully stale (beyond REMOVE_MS)
                const existingBuses = Object.keys(busMarkers);
                existingBuses.forEach(busNum => {
                    if (!freshBusSet.has(busNum)) {
                        map.removeLayer(busMarkers[busNum]);
                        removeBusTrail(busNum);
                        delete busMarkers[busNum];
                        delete prevRawPositions[busNum];
                        delete prevBusPositions[busNum];
                        delete prevBusTimes[busNum];
                        delete busLastSeen[busNum];
                        delete busLastSSEUpdate[busNum];
                        delete busDirection[busNum];
                        delete busLastStopIdx[busNum];
                        delete busCurrentStop[busNum];
                        delete busSpeedCache[busNum];
                        delete busMovedCache[busNum];
                        delete busTerminalStatus[busNum];
                        delete busKalmanState[busNum];
                        delete busTweenSpeedCache[busNum];
                        delete busSnapInfo[busNum];
                        delete busSnapLockState[busNum];
                        delete busPrediction[busNum];
                    }
                });
                const renderCtx = getRenderContext();
                freshBusNumbers.forEach(busNum => {
                    const bus = latestBuses[busNum];
                    const rawPos = [bus.lat, bus.lng];
                    const filteredPos = kalmanFilterBusPosition(busNum, rawPos[0], rawPos[1]);
                    const color = colors[(parseInt(busNum) - 1) % colors.length];
                    const rid = (bus && bus.routeId != null) ? bus.routeId : busRouteMap[busNum];

                    // If SSE already updated this bus recently, skip poll processing to avoid teleporting
                    const lastSSE = busLastSSEUpdate[busNum] || 0;
                    if (sseConnected && (nowMs - lastSSE) < 10000 && busMarkers[busNum]) {
                        busLastSeen[busNum] = nowMs;
                        updateBusStopInfo(busNum, rawPos);
                        const status = determineStatus(busNum, rawPos, bus.lastUpdate);
                        if (status !== 'Offline') activeCount++;
                        const isTrackedNow = trackedBus && busNum === trackedBus;
                        const showBus = !!isTrackedNow || isPointRenderableByContext(rawPos[0], rawPos[1], rid, renderCtx);
                        ensureLayerVisibility(busMarkers[busNum], showBus);
                        if (!showBus) removeBusTrail(busNum);
                        try { busMarkers[busNum].setOpacity(getMarkerOpacity(!!isTrackedNow, status === 'Offline')); } catch(e) {}
                        return;
                    }

                    // Snap to route if close enough
                    const snapResult = snapToRoute(filteredPos[0], filteredPos[1], busNum);
                    const position = snapResult.pos;
                    busSnapInfo[busNum] = { segIdx: snapResult.segIdx };
                    const isTracked = trackedBus && busNum === trackedBus;
                    updateBusStopInfo(busNum, rawPos);
                    // Cache speed/movement BEFORE overwriting prev positions
                    cacheSpeedAndMovement(busNum, rawPos[0], rawPos[1], bus.lastUpdate);
                    const status = determineStatus(busNum, rawPos, bus.lastUpdate);
                    const isOffline = status === 'Offline';
                    if (!isOffline) activeCount++;
                    const rotation = getRouteBearing(busNum);
                    prevRawPositions[busNum] = rawPos;
                    prevBusPositions[busNum] = position;
                    if (bus.lastUpdate) prevBusTimes[busNum] = parseIsoTime(bus.lastUpdate);

                    const showBus = !!isTracked || isPointRenderableByContext(position[0], position[1], rid, renderCtx);
                    if (busMarkers[busNum]) {
                        ensureLayerVisibility(busMarkers[busNum], showBus);
                        if (showBus) {
                            queueBusTween(busNum, position);
                            const onSelectedRoute = selectedRouteId && String(rid) === String(selectedRouteId);
                            const rotationChanged = (prevBusRotation[busNum] === undefined) || (Math.abs(rotation - prevBusRotation[busNum]) > 5);
                            const trackingChanged = prevTrackedState[busNum] !== !!isTracked;
                            const routeSelChanged = prevRouteSelState[busNum] !== !!onSelectedRoute;
                            if (rotationChanged || trackingChanged || routeSelChanged) {
                                const newIcon = createIcon(busNum, color, currentIconSize, rotation, isTracked || onSelectedRoute);
                                busMarkers[busNum].setIcon(newIcon);
                                prevBusRotation[busNum] = rotation;
                                prevTrackedState[busNum] = !!isTracked;
                                prevRouteSelState[busNum] = !!onSelectedRoute;
                            }
                        } else {
                            removeBusTrail(busNum);
                        }
                    } else if (showBus) {
                        const onSelectedRoute = selectedRouteId && String(rid) === String(selectedRouteId);
                        const icon = createIcon(busNum, color, currentIconSize, rotation, isTracked || onSelectedRoute);
                        busMarkers[busNum] = L.marker(position, { icon: icon, title: `Transport ${busNum}` }).addTo(map);
                        prevBusRotation[busNum] = rotation;
                        prevTrackedState[busNum] = !!isTracked;
                        prevRouteSelState[busNum] = !!onSelectedRoute;
                        busMarkers[busNum].bindPopup(() => buildBusPopup(busNum, bus));
                        busMarkers[busNum].on('click', () => { const nextTracked = setTrackedBus(busNum, { toggleIfSame: true }); if (followEnabled && nextTracked) map.setView(busMarkers[busNum].getLatLng(), DEFAULT_TILE_ZOOM); busMarkers[busNum].openPopup(); });
                        busMarkers[busNum].on('mouseover', () => { followEnabled = false; }); busMarkers[busNum].on('mouseout', () => { followEnabled = true; });
                        flashElement(_dom.mapStage || document.querySelector('.map-stage'), `new_bus_${busNum}`, 220);
                    }

                    const marker = busMarkers[busNum];
                    if (marker && showBus) {
                        updateBusTrail(busNum, position, color);
                        const isTrackedNow = trackedBus && busNum === trackedBus;
                        try { marker.setOpacity(getMarkerOpacity(!!isTrackedNow, isOffline)); } catch(e) {}
                        if (isTrackedNow && followEnabled && !isOffline) {
                            map.panInside(position, {
                                paddingTopLeft: [AUTO_PAN_PADDING_PX, AUTO_PAN_PADDING_PX],
                                paddingBottomRight: [AUTO_PAN_PADDING_PX, AUTO_PAN_PADDING_PX],
                                animate: false
                            });
                        }
                    }
                });
                if (_dom.activeBusCount) _dom.activeBusCount.textContent = activeCount;
                if (_dom.activeCountOverlay) _dom.activeCountOverlay.textContent = activeCount;
                updateActiveBusList(freshBusNumbers, latestBuses);
                queueBusUiRefresh(120);
                scheduleSpatialSync();
                setLastSyncUI(getTimeString());
            }).catch(error => console.error('Error:', error))
              .finally(() => {
                  _busFetchInFlight = false;
                  if (_busFetchQueued) {
                      _busFetchQueued = false;
                      setTimeout(() => updateBuses(true), 80);
                  }
              });
        }

        let _lastBusListHash = '';
        function updateActiveBusList(busNumbers, buses) {
            const container = _dom.activeBuses || document.getElementById('activeBuses');
            if (busNumbers.length === 0) { if (_lastBusListHash !== 'empty') { container.innerHTML = `<div class="empty-state"><p>No Transports currently active</p></div>`; _lastBusListHash = 'empty'; } return; }
            // Build hash to skip DOM rebuild if nothing changed
            let hash = '';
            for (let i = 0; i < busNumbers.length; i++) { hash += busNumbers[i] + (busStatusCache[busNumbers[i]] || '') + (busCurrentStop[busNumbers[i]] || ''); }
            if (hash === _lastBusListHash) return;
            _lastBusListHash = hash;
            const frag = document.createDocumentFragment();
            const sorted = busNumbers.slice().sort((a, b) => parseInt(a) - parseInt(b));
            for (let ni = 0; ni < sorted.length; ni++) {
                const busNum = sorted[ni];
                const color = colors[(parseInt(busNum) - 1) % colors.length];
                const rid = (buses[busNum] && buses[busNum].routeId != null) ? buses[busNum].routeId : busRouteMap[busNum];
                const onSelectedRoute = selectedRouteId && String(rid) === String(selectedRouteId);
                const item = document.createElement('div');
                item.className = `bus-item ${onSelectedRoute ? 'active-route' : ''}`;
                item.style.borderLeftColor = color;
                item.onclick = () => { const position = [buses[busNum].lat, buses[busNum].lng]; map.setView(position, DEFAULT_TILE_ZOOM); };
                const rawPos = [buses[busNum].lat, buses[busNum].lng];
                const status = busStatusCache[busNum] || determineStatus(busNum, rawPos, buses[busNum].lastUpdate);
                const statusColor = status==='Moving'?'#34d399':status==='At Stop'?'#5AC8FA':status==='Idle'?'#fbbf24':status==='Reached Destination'?'#a78bfa':status==='At Start'?'#60a5fa':status==='Waiting for Update'?'#fbbf24':'#fb7185';
                const atStopName = busCurrentStop[busNum];
                const route = getRouteById(rid);
                const stops = route ? getStopsForBus(route, rawPos, busNum) : { last: null, next: null };
                const statusText = (status === 'Reached Destination' && atStopName) ? `Reached: ${atStopName}` : (status === 'At Start' && atStopName) ? `At Start: ${atStopName}` : (status === 'At Stop' && atStopName) ? `At Stop: ${atStopName}` : status;
                let statusHtml = `<div class="bus-status" style="color:${statusColor}"><div class="pulse" style="background:${statusColor}"></div>${statusText}</div>`;
                let detailRows = '';
                if (stops.last) {
                    detailRows += `<div style="font-size:11px;color:#9aa4b2;padding:1px 0 0 36px">Last: ${stops.last}</div>`;
                }
                if (stops.next) {
                    detailRows += `<div style="font-size:11px;color:#5AC8FA;padding:1px 0 0 36px;font-weight:500">Next: ${stops.next}</div>`;
                }
                item.innerHTML = `<div class="bus-info"><div class="bus-dot" style="background-color: ${color}; transform:${onSelectedRoute ? 'scale(1.08)' : 'scale(1)'}">${busNum}</div><div class="bus-name">Transport ${busNum}</div></div>${statusHtml}${detailRows}`;
                frag.appendChild(item);
            }
            container.textContent = '';
            container.appendChild(frag);
        }

        // Live updates via SSE for smooth animation
        let _sseLastMsg = 0; // timestamp of last SSE message for health check
        function initSSE(routeId){
            if (_eventSource) { try { _eventSource.close(); } catch(e) {} _eventSource = null; sseConnected = false; refreshMapStatusPanel(); }
            const sseUrl = routeId ? '/events?routeId=' + encodeURIComponent(routeId) : '/events';
            try{
                const es = new EventSource(sseUrl);
                _eventSource = es;
                _sseLastMsg = Date.now();
                es.onopen = ()=>{
                    sseConnected = true;
                    refreshMapStatusPanel();
                    _sseLastMsg = Date.now();
                    if(busesPollTimerId){ try{ clearInterval(busesPollTimerId); }catch(e){} busesPollTimerId=null; }
                    // Light resync every RESYNC_INTERVAL_MS to prune stale buses + SSE health check
                    if(window.__resyncTimer){ clearInterval(window.__resyncTimer); }
                    window.__resyncTimer = setInterval(()=>{
                        if(!document.hidden) updateBuses();
                        // SSE health: if no message in 45s (heartbeat should be 20s), reconnect
                        if(sseConnected && (Date.now() - _sseLastMsg) > 45000){
                            sseConnected = false;
                            refreshMapStatusPanel();
                            try { _eventSource.close(); } catch(e){}
                            _eventSource = null;
                            initSSE(selectedRouteId);
                        }
                    }, RESYNC_INTERVAL_MS);
                };
                es.onmessage = (ev)=>{
                    _sseLastMsg = Date.now();
                    try{
                        const msg = JSON.parse(ev.data);
                        if(msg.type === 'bus_update'){
                            const busNum = String(msg.bus);
                            const b = msg.data||{};
                            if(typeof b.lat !== 'number' || typeof b.lng !== 'number') return;
                            const filteredPos = kalmanFilterBusPosition(busNum, b.lat, b.lng);
                            // update route mapping if provided
                            if(b.routeId != null) busRouteMap[busNum] = b.routeId;
                            // Use server-sent heading if provided
                            if(b.heading !== undefined && b.heading !== null) busServerHeading[busNum] = b.heading;
                            // Track last seen time, direction, and raw position for status
                            busLastSeen[busNum] = Date.now();
                            busLastSSEUpdate[busNum] = Date.now();
                            // Use server-sent stop data (atStop, direction, nearestStopIdx)
                            const srvStop = { atStop: b.atStop, direction: b.direction, nearestStopIdx: b.nearestStopIdx, nearestStopName: b.nearestStopName };
                            updateBusStopInfo(busNum, [b.lat, b.lng], srvStop);
                            // Cache speed/movement BEFORE overwriting prev positions
                            cacheSpeedAndMovement(busNum, b.lat, b.lng, b.lastUpdate);
                            prevRawPositions[busNum] = [b.lat, b.lng];
                            if(b.lastUpdate) prevBusTimes[busNum] = parseIsoTime(b.lastUpdate);
                            // update cache and animate
                            latestBuses[busNum] = { ...(latestBuses[busNum]||{}), ...b };
                            const liveStatus = determineStatus(busNum, [b.lat, b.lng], b.lastUpdate);
                            const isLiveOffline = liveStatus === 'Offline';
                            const rid = (latestBuses[busNum] && latestBuses[busNum].routeId != null)
                                ? latestBuses[busNum].routeId
                                : busRouteMap[busNum];
                            const trackedNow = trackedBus && busNum === trackedBus;
                            const renderCtx = getRenderContext();
                            const sseSnap = snapToRoute(filteredPos[0], filteredPos[1], busNum);
                            busSnapInfo[busNum] = { segIdx: sseSnap.segIdx };
                            const snapPos = sseSnap.pos;
                            const showBus = !!trackedNow || isPointRenderableByContext(snapPos[0], snapPos[1], rid, renderCtx);
                            if(!busMarkers[busNum]){
                                if (showBus) {
                                    const color = colors[(parseInt(busNum) - 1) % colors.length];
                                    const onSelectedRoute = selectedRouteId && String(rid) === String(selectedRouteId);
                                    const icon = createIcon(busNum, color, currentIconSize, 0, trackedNow || onSelectedRoute);
                                    busMarkers[busNum] = L.marker(snapPos, { icon, title: `Transport ${busNum}` }).addTo(map);
                                    prevTrackedState[busNum] = !!trackedNow;
                                    prevRouteSelState[busNum] = !!onSelectedRoute;
                                    busMarkers[busNum].bindPopup(() => buildBusPopup(busNum, latestBuses[busNum] || b));
                                    busMarkers[busNum].on('click', () => { const nextTracked = setTrackedBus(busNum, { toggleIfSame: true }); if (followEnabled && nextTracked) map.setView(busMarkers[busNum].getLatLng(), DEFAULT_TILE_ZOOM); busMarkers[busNum].openPopup(); });
                                    busMarkers[busNum].on('mouseover', () => { followEnabled = false; }); busMarkers[busNum].on('mouseout', () => { followEnabled = true; });
                                    try { busMarkers[busNum].setOpacity(getMarkerOpacity(!!trackedNow, isLiveOffline)); } catch(e) {}
                                    flashElement(_dom.mapStage || document.querySelector('.map-stage'), `new_bus_sse_${busNum}`, 220);
                                    updateBusTrail(busNum, snapPos, color);
                                }
                            } else {
                                ensureLayerVisibility(busMarkers[busNum], showBus);
                                if (showBus) {
                                    // Snap to route and get route-locked bearing
                                    const _newRot = getRouteBearing(busNum);
                                    const _c = colors[(parseInt(busNum) - 1) % colors.length];
                                    const _onR = selectedRouteId && String(rid) === String(selectedRouteId);
                                    const _tr = trackedBus && busNum === trackedBus;
                                    const trackingChanged = prevTrackedState[busNum] !== !!_tr;
                                    const routeSelChanged = prevRouteSelState[busNum] !== !!_onR;
                                    if (prevBusRotation[busNum] === undefined || Math.abs(_newRot - (prevBusRotation[busNum]||0)) > 5 || trackingChanged || routeSelChanged) {
                                        busMarkers[busNum].setIcon(createIcon(busNum, _c, currentIconSize, _newRot, _tr || _onR));
                                        prevBusRotation[busNum] = _newRot;
                                        prevTrackedState[busNum] = !!_tr;
                                        prevRouteSelState[busNum] = !!_onR;
                                    }
                                    try { busMarkers[busNum].setOpacity(getMarkerOpacity(!!_tr, isLiveOffline)); } catch(e) {}
                                    queueBusTween(busNum, snapPos);
                                    updateBusTrail(busNum, snapPos, _c);
                                } else {
                                    removeBusTrail(busNum);
                                }
                            }
                            scheduleSpatialSync();
                            setLastSyncUI(getTimeString());
                            // Throttle ETA recomputation from SSE  at most once per second
                            queueBusUiRefresh(220);
                        } else if(msg.type === 'bus_stop'){
                            const busNum = String(msg.bus);
                            delete latestBuses[busNum];
                            delete busLastSeen[busNum];
                            delete busLastSSEUpdate[busNum];
                            delete prevRawPositions[busNum];
                            delete prevBusPositions[busNum];
                            delete prevBusTimes[busNum];
                            delete busDirection[busNum];
                            delete busLastStopIdx[busNum];
                            delete busCurrentStop[busNum];
                            delete busSpeedCache[busNum];
                            delete busMovedCache[busNum];
                            delete busTerminalStatus[busNum];
                            delete busKalmanState[busNum];
                            delete busTweenSpeedCache[busNum];
                            delete busSnapInfo[busNum];
                            delete busSnapLockState[busNum];
                            delete busPrediction[busNum];
                            removeBusTrail(busNum);
                            const m = busMarkers[busNum]; if(m){ try{ map.removeLayer(m); }catch(e){} delete busMarkers[busNum]; }
                            scheduleSpatialSync();
                        } else if(msg.type === 'route_set'){
                            const busNum = String(msg.bus);
                            if(msg.routeId != null) busRouteMap[busNum] = msg.routeId;
                            if(latestBuses[busNum]) latestBuses[busNum].routeId = msg.routeId;
                            delete busSnapInfo[busNum];
                            delete busSnapLockState[busNum];
                            if (busPrediction[busNum]) busPrediction[busNum].active = false;
                        } else if(msg.type === 'buses_clear'){
                            latestBuses = {};
                            Object.values(busMarkers).forEach(m=>{ try{ map.removeLayer(m); }catch(e){} }); busMarkers = {};
                            prevRawPositions = {}; prevBusPositions = {}; prevBusTimes = {}; busLastSeen = {}; busLastSSEUpdate = {};
                            busDirection = {}; busLastStopIdx = {}; busCurrentStop = {}; busTerminalStatus = {};
                            Object.keys(busSnapInfo).forEach((k) => { delete busSnapInfo[k]; });
                            Object.keys(busSnapLockState).forEach((k) => { delete busSnapLockState[k]; });
                            Object.keys(busPrediction).forEach((k) => { delete busPrediction[k]; });
                            clearAllBusTrails();
                            scheduleSpatialSync();
                        }
                    }catch(e){ /* ignore */ }
                };
                es.onerror = ()=>{
                    // If SSE fails, ensure polling is running
                    sseConnected = false;
                    refreshMapStatusPanel();
                    if(!busesPollTimerId){ busesPollTimerId = setInterval(updateBuses, POLL_INTERVAL_MS); }
                };
            }catch(e){ refreshMapStatusPanel(); /* SSE not available, keep polling */ }
        }

        async function locateMe() {
            if (!navigator.geolocation) return alert('Geolocation not supported');
            navigator.geolocation.getCurrentPosition((pos) => {
                userLocation = [pos.coords.latitude, pos.coords.longitude];
                refreshAssistantFromField();
                updateUserMarker(userLocation);
                scheduleSpatialSync();
                let best = { route: null, stop: null, dist: Infinity };
                allRoutes.forEach(route => { route.waypoints.forEach((wp) => { const d = calcDistance(userLocation[0], userLocation[1], wp[0], wp[1]); if (d < best.dist) best = { route, stop: wp, dist: d }; }); });
                if (best.route) { selectRoute(best.route.id); if (walkingLine) map.removeLayer(walkingLine); walkingLine = L.polyline([userLocation, best.stop], { color:'#999', weight:2, opacity:0.7, dashArray:'5,5' }).addTo(map); showRouteDetails(best.route); computeAndShowStudentETA(); }
                else { applyMapViewportForContext(true); }
                if(!userWatchId){
                    userWatchId = navigator.geolocation.watchPosition((p)=>{
                        userLocation = [p.coords.latitude, p.coords.longitude];
                        refreshAssistantFromField();
                        updateUserMarker(userLocation);
                        scheduleSpatialSync();
                    }, ()=>{}, { enableHighAccuracy:true, maximumAge:1500, timeout:6000 });
                }
            }, () => alert('Unable to get location'), { enableHighAccuracy: true, maximumAge: 1500, timeout: 6000 });
        }

        function getPreferredZoom16Center() {
            if (selectedRouteId) {
                const rid = String(selectedRouteId);
                let bounds = routeBoundsCache[rid] || null;
                if (!bounds) {
                    const cachedCoords = routeCoordsCache[rid];
                    if (cachedCoords && cachedCoords.length) bounds = computeBoundsFromLatLngs(cachedCoords);
                }
                if (!bounds) {
                    const route = getRouteById(rid);
                    if (route && route.waypoints && route.waypoints.length) bounds = computeBoundsFromLatLngs(route.waypoints);
                }
                if (bounds) {
                    return [
                        (bounds.minLat + bounds.maxLat) * 0.5,
                        (bounds.minLng + bounds.maxLng) * 0.5
                    ];
                }
            }
            if (userLocation && userLocation.length === 2) {
                return [Number(userLocation[0]), Number(userLocation[1])];
            }
            if (map) {
                const center = map.getCenter();
                return [center.lat, center.lng];
            }
            return null;
        }

        function zoomToDefaultTileCenter() {
            if (!map) return;
            const center = getPreferredZoom16Center();
            if (!center) return;
            const animate = !isLowPerfMode() && !document.hidden;
            try {
                map.setView(center, DEFAULT_TILE_ZOOM, {
                    animate,
                    duration: animate ? 0.25 : 0
                });
            } catch (e) {}
            setManualTrackingWindow(5000);
            refreshMapStatusPanel();
        }

        document.addEventListener('DOMContentLoaded', () => {
            loadGlobalUiTheme();
            loadRouteSnapSettings();
            window.addEventListener('storage', handleUiThemeBroadcastEvent);
            const locateBtn = document.getElementById('locateMeBtn');
            if (locateBtn) locateBtn.addEventListener('click', locateMe);
            const zoom16Btn = document.getElementById('zoom16Btn');
            if (zoom16Btn) zoom16Btn.addEventListener('click', zoomToDefaultTileCenter);
            applyLowPerfMode(isLowPerfMode(), false);
        });
        window.addEventListener('load', initMap);
    </script>
</body>
</html>
