<!DOCTYPE html>
<html>
<head>
    <title>Transport Tracker - Driver App</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        :root {
            --ui-theme-hue: 0deg;
            --ui-theme-saturation: 120%;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0b0c10;
            color: #e6eef8;
            padding: 16px 12px;
            filter: hue-rotate(var(--ui-theme-hue)) saturate(var(--ui-theme-saturation));
        }
        .container {
            width: 100%;
            max-width: 420px;
            margin: 0 auto;
            background: #0f1724;
            border-radius: 12px;
            padding: 18px;
            border: 1px solid #243149;
            box-shadow: 0 8px 24px rgba(2, 6, 23, 0.65);
        }
        h1 { font-size: 20px; color: #dbeafe; text-align: left; margin-bottom: 6px; }
        .subtitle { color: #9aa4b2; font-size: 13px; margin-bottom: 14px; }
        .bus-selector { padding: 8px 0; margin-bottom: 12px; }
        .bus-selector label { display: block; color: #9aa4b2; font-size: 13px; margin-bottom: 6px; }
        select {
            width: 100%;
            padding: 10px;
            font-size: 14px;
            border-radius: 8px;
            border: 1px solid #2b3b58;
            background: #0b1220;
            color: #e6eef8;
        }
        select option {
            background: #0b1220;
            color: #e6eef8;
        }
        .status-card {
            background: #111c2e;
            padding: 12px;
            border-radius: 10px;
            margin-bottom: 12px;
            border: 1px solid #2b3b58;
        }
        .status-card h3 { color: #dbeafe; margin-bottom: 6px; font-size: 14px; }
        .status-indicator { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 8px; vertical-align: middle; }
        .status-indicator.active { background: #34d399; box-shadow: 0 0 6px rgba(52, 211, 153, 0.20); }
        .status-indicator.inactive { background: #fb7185; }
        .status-indicator.slow { background: #fbbf24; }
        button {
            width: 100%;
            padding: 10px;
            font-size: 15px;
            border-radius: 8px;
            border: 1px solid #2d3e5e;
            cursor: pointer;
            background: #162338;
            color: #dbeafe;
        }
        button:hover:not(:disabled) { background: #1d2d46; }
        #stopBtn { background: #2a1622; border-color: #583547; color: #fda4af; }
        #startBtn:disabled, #stopBtn:disabled { opacity: 0.5; cursor: not-allowed; }
        #startDriveBtn { margin-top: 8px; }
        .card {
            background: #111c2e;
            padding: 12px;
            border-radius: 10px;
            margin-top: 12px;
            border: 1px solid #2b3b58;
        }
        #driverMap {
            height: 200px;
            border-radius: 10px;
            border: 2px solid #2b3b58;
            background: #05060a;
            margin-top: 8px;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
        }
        .progress-outer { width: 100%; height: 12px; background: #1a2539; border-radius: 8px; overflow: hidden; margin-top: 8px; }
        .progress-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #34d399, #60a5fa); transition: width 600ms linear; }
        .info {
            background: #111c2e;
            padding: 10px;
            border-radius: 10px;
            color: #b8c1d2;
            font-size: 13px;
            border: 1px solid #2b3b58;
        }
        .info p { margin: 6px 0; }
        #etaDisplay { font-weight: 500; color: #34d399; }
        .leaflet-control-zoom a {
            background: #111c2e !important;
            color: #e6eef8 !important;
            border-color: #2b3b58 !important;
        }
        .leaflet-popup-content-wrapper,
        .leaflet-popup-tip {
            background: #111c2e;
            color: #e6eef8;
            border: 1px solid #2b3b58;
        }
        @media (max-width: 520px) {
            body { padding: 12px; }
            .container { margin: 0; padding: 14px; border-radius: 10px; }
            #driverMap { height: 260px; }
            .bus-selector, .status-card, .info { margin-bottom: 10px; }
            select { font-size: 16px; padding: 12px; }
            button { font-size: 16px; padding: 12px; border-radius: 10px; }
            #startBtn, #stopBtn, #startDriveBtn, #stopDriveBtn { width: 100%; display: block; }
            .progress-outer { height: 14px; }
        }
    </style>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
</head>
<body>
    <div class="container">
        <div style="display:flex;justify-content:space-between;align-items:flex-start">
            <div>
                <h1>üöå {{ institute_name | default('INSTITUTE') }} Driver Companion</h1>
                <p class="subtitle">Campus Shuttle Tracking</p>
            </div>
            <a href="/admin/login" target="_blank" rel="noopener noreferrer" style="color:#9aa4b2;font-size:11px;text-decoration:none;margin-top:4px">Admin</a>
        </div>

        <div class="bus-selector">
            <label for="busNumber">Select Your Transport Number:</label>
            <select id="busNumber">
                <option value="">-- Choose Transport --</option>
            </select>
        </div>

        <div class="bus-selector">
            <label for="routeSelect">Select Route:</label>
            <select id="routeSelect">
                <option value="">-- Choose Route --</option>
            </select>
        </div>

        <div class="status-card">
            <h3>
                <span class="status-indicator" id="statusDot"></span>
                Status: <span id="trackingStatus">Inactive</span>
            </h3>
            <p style="color: #9aa4b2; margin-top: 10px;">Updates sent: <span id="updateCount">0</span></p>
        </div>

        <button id="startBtn" onclick="startTracking()">Start Shift</button>
        <button id="stopBtn" onclick="stopTracking()" disabled>End Shift</button>
        <!-- Removed Start/Stop Route buttons for driver UI -->

        <div class="card" style="margin-top:12px;">
            <h3>üó∫Ô∏è Driver Map & ETA</h3>
            <div id="driverMap"></div>
            <p style="color:#9aa4b2;margin-top:8px">ETA to next stop: <span id="etaDisplay">‚Äî</span></p>
            <p style="color:#9aa4b2;margin-top:6px">Progress: <strong id="progressPercent">‚Äî</strong></p>
            <div class="progress-outer"><div id="progressFill" class="progress-fill"></div></div>
            <p style="color:#9aa4b2;margin-top:6px">Next stop: <strong id="nextStopDisplay">‚Äî</strong></p>
            <div style="display:flex;gap:8px;margin-top:10px;align-items:center;flex-wrap:wrap">
                <label style="color:#9aa4b2;font-size:13px"><input type="checkbox" id="driverRoutesToggle" checked> Routes</label>
            </div>
        </div>

        <div class="info">
            <p><strong>‚ÑπÔ∏è How it works:</strong></p>
            <p>‚Ä¢ Select your transport number from the dropdown</p>
            <p>‚Ä¢ Click "Start Shift" to begin tracking</p>
            <p>‚Ä¢ Your location updates automatically</p>
            <p>‚Ä¢ Students can see your transport on the map</p>
            <p>‚Ä¢ Click "End Shift" when done</p>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
     
        let updateCount = 0;
        let watchId = null;
        let selectedBus = null;
        let selectedRoute = null;
        let allRoutes = [];
        const THEME_BROADCAST_KEY = 'kiit_ui_theme_broadcast_v1';

        let driverMap = null;
        let driverMarker = null;
        let driverRouteLine = null;
        let routesLayer = null;
        let routesPolylinesMap = {};
        // Buildings (hostels/classes) removed from driver map

        
        let driving = false;
        let lastSentPos = null;
        let lastSentTime = 0;
            const MIN_SEND_INTERVAL = 2000;
            const BACKGROUND_INTERVAL = 2000;
        const MIN_MOVE_DISTANCE = 5; 
            let backgroundTimerId = null;

        const busSelect = document.getElementById('busNumber');
        const routeSelect = document.getElementById('routeSelect');

        function normalizeThemeHexColor(value){
            let hex = String(value || '').trim();
            if(/^#[0-9a-fA-F]{3}$/.test(hex)){
                hex = '#' + hex.slice(1).split('').map(ch => ch + ch).join('');
            }
            if(!/^#[0-9a-fA-F]{6}$/.test(hex)) return '#8b64ff';
            return `#${hex.slice(1).toLowerCase()}`;
        }
        function clampThemeSaturation(value){
            const n = Number(value);
            if(!Number.isFinite(n)) return 120;
            return Math.max(20, Math.min(260, Math.round(n)));
        }
        function hexToRgb(hex){
            const clean = normalizeThemeHexColor(hex).slice(1);
            return {
                r: parseInt(clean.slice(0, 2), 16),
                g: parseInt(clean.slice(2, 4), 16),
                b: parseInt(clean.slice(4, 6), 16),
            };
        }
        function rgbToHue(r, g, b){
            const rn = r / 255;
            const gn = g / 255;
            const bn = b / 255;
            const max = Math.max(rn, gn, bn);
            const min = Math.min(rn, gn, bn);
            const d = max - min;
            if(d === 0) return 0;
            let h;
            if(max === rn) h = ((gn - bn) / d) % 6;
            else if(max === gn) h = ((bn - rn) / d) + 2;
            else h = ((rn - gn) / d) + 4;
            return ((h * 60) + 360) % 360;
        }
        function applyGlobalTheme(theme){
            const accentRgb = hexToRgb(theme && theme.accent_color);
            const baseRgb = hexToRgb('#8b64ff');
            const hueDelta = rgbToHue(accentRgb.r, accentRgb.g, accentRgb.b) - rgbToHue(baseRgb.r, baseRgb.g, baseRgb.b);
            const saturation = clampThemeSaturation(theme && theme.saturation);
            document.documentElement.style.setProperty('--ui-theme-hue', `${hueDelta.toFixed(1)}deg`);
            document.documentElement.style.setProperty('--ui-theme-saturation', `${saturation}%`);
        }
        async function loadGlobalTheme(){
            try{
                const res = await fetch('/api/ui-theme', { cache: 'no-store' });
                const data = await res.json();
                if(!res.ok) throw new Error(data.error || 'theme_load_failed');
                applyGlobalTheme(data);
            }catch(e){
                applyGlobalTheme({ accent_color: '#8b64ff', saturation: 120 });
            }
        }
        window.addEventListener('storage', (e) => {
            if (!e || e.key !== THEME_BROADCAST_KEY || !e.newValue) return;
            try {
                const payload = JSON.parse(e.newValue);
                applyGlobalTheme(payload || {});
            } catch (err) {}
        });

    
        async function loadRoutes(){
            try{
                const res = await fetch('/api/routes');
                allRoutes = await res.json();
                routeSelect.innerHTML = '<option value="">-- Choose Route --</option>';
                allRoutes.forEach(r=>{
                    const o = document.createElement('option'); o.value = r.id; o.textContent = r.name; routeSelect.appendChild(o);
                });
                initDriverMap();
                await loadMapLayers();
            }catch(e){console.error(e)}
        }

        function initDriverMap(){
            if(driverMap) return;
            const center = (allRoutes && allRoutes[0] && allRoutes[0].waypoints && allRoutes[0].waypoints[0]) ? [allRoutes[0].waypoints[0][0], allRoutes[0].waypoints[0][1]] : [20.355,85.819];
            try{
                driverMap = L.map('driverMap', { zoomControl: false }).setView(center, 15);
                L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', { maxZoom:19 }).addTo(driverMap);
                L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}{r}.png', { maxZoom:19, attribution:'' }).addTo(driverMap);
            }catch(e){ console.warn('Leaflet init failed', e); }
        }

        async function loadMapLayers(){
            if(!routesLayer) routesLayer = L.layerGroup().addTo(driverMap);

            await renderRoutes();

            document.getElementById('driverRoutesToggle').addEventListener('change', (e)=>{
                if(e.target.checked) driverMap.addLayer(routesLayer);
                else driverMap.removeLayer(routesLayer);
            });
        }

        // Removed building icons and renderers for a cleaner driver view

        // OSRM helpers with timeout + graceful fallback
        async function osrmFetch(url, timeoutMs=5000){
            const ctrl = new AbortController(); const t = setTimeout(()=>ctrl.abort(), timeoutMs);
            try{ const res = await fetch(url, { signal: ctrl.signal }); clearTimeout(t); if(!res.ok) throw new Error(`HTTP ${res.status}`); return await res.json(); }catch(e){ clearTimeout(t); throw e; }
        }
        async function getOSRMRoute(waypoints){
            try{
                if(!waypoints || waypoints.length<2) return waypoints;
                const coords = waypoints.map(w=>`${w[1]},${w[0]}`).join(';');
                const url = `https://router.project-osrm.org/route/v1/driving/${coords}?geometries=geojson`;
                const data = await osrmFetch(url, 5000);
                if(data.routes && data.routes[0]) return data.routes[0].geometry.coordinates.map(c=>[c[1],c[0]]);
            }catch(e){ console.warn('OSRM route fallback', e); }
            return waypoints;
        }

        async function renderRoutes(){
            if(!routesLayer) routesLayer = L.layerGroup().addTo(driverMap);
            routesLayer.clearLayers();
            routesPolylinesMap = {};
            for(const route of allRoutes){
                if(route.waypoints && route.waypoints.length){
                    const coords = await getOSRMRoute(route.waypoints);
                    const poly = L.polyline(coords||route.waypoints, { color: route.color||'#FF9800', weight:3, opacity:0.9, dashArray:'5,5' }).addTo(routesLayer);
                    const stops = [];
                    (route.stops||[]).forEach((s,i)=>{ if(route.waypoints[i]){ const m=L.circleMarker([route.waypoints[i][0], route.waypoints[i][1]], { radius:6, fillColor: route.color||'#FF9800', color:'#fff', weight:1, opacity:0.6, fillOpacity:0.6 }).bindTooltip(s,{direction:'top',offset:[0,-8]}).addTo(routesLayer); stops.push(m); } });
                    routesPolylinesMap[route.id] = { polyline: poly, stops: stops };
                }
            }
            if(selectedRoute) highlightRoute(selectedRoute);
        }

        // Hostels and classes rendering removed

        function highlightRoute(routeId){
            Object.entries(routesPolylinesMap).forEach(([id,obj])=>{
                try{
                    if(String(id)===String(routeId)){
                        // Ensure selected route is visible
                        if(obj.polyline && !driverMap.hasLayer(obj.polyline)) obj.polyline.addTo(routesLayer);
                        obj.polyline.setStyle({ opacity:1, weight:4 });
                        obj.stops.forEach(s=>{
                            if(!driverMap.hasLayer(s)) s.addTo(routesLayer);
                            s.setStyle({ opacity:1, fillOpacity:0.9 });
                        });
                    } else {
                        // Hide non-selected routes entirely
                        if(obj.polyline) obj.polyline.remove();
                        obj.stops.forEach(s=>{ try{ s.remove(); }catch(e){} });
                    }
                }catch(e){}
            });
            // if driver marker exists, focus map to driver and keep following
            if(driverMarker && routeId){ try{ driverMap.setView(driverMarker.getLatLng(), Math.max(driverMap.getZoom(),15)); }catch(e){} }
        }

        //
        for(let i=1;i<=20;i++){ const o=document.createElement('option'); o.value=i; o.textContent=`Transport ${i}`; busSelect.appendChild(o); }

        // Route select behavior
        routeSelect.addEventListener('change', async (e)=>{
            selectedRoute = e.target.value;
            if(selectedBus && selectedRoute){
                try{ await fetch(`/api/bus/${selectedBus}/route`, { method:'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ routeId: selectedRoute }) }); console.log(`Transport ${selectedBus} assigned to route ${selectedRoute}`); }catch(err){ console.error(err); }
            }
            // Highlight only the chosen route and follow driver
            if(selectedRoute) highlightRoute(selectedRoute);
            // Auto-enable driving progress when a route is chosen
            driving = true;
        });

        // Start tracking
        function startTracking(){
            selectedBus = busSelect.value;
            if(!selectedBus){ alert('Please select a transport number first!'); return; }
            if(!navigator.geolocation){ alert('Geolocation not supported'); return; }

            watchId = navigator.geolocation.watchPosition((pos)=>{
                const now = Date.now(); const lat = pos.coords.latitude, lng = pos.coords.longitude;
                let moved = true;
                if(lastSentPos){ const d = Math.sqrt(Math.pow(lat-lastSentPos.lat,2)+Math.pow(lng-lastSentPos.lng,2))*111000; moved = d>=MIN_MOVE_DISTANCE; }
                if(moved || now - lastSentTime >= MIN_SEND_INTERVAL){ updateDriverPosition(lat,lng); computeAndShowETA(lat,lng); if(driving) updateDriveProgress(lat,lng); sendLocation(pos); lastSentPos={lat,lng}; lastSentTime=now; }
            }, showError, { enableHighAccuracy:true, maximumAge:5000, timeout:15000 });

                    // Background updates every 2s even when tab is inactive
                    backgroundTimerId = setInterval(()=>{
                        if(!selectedBus) return;
                        try{
                            navigator.geolocation.getCurrentPosition((pos)=>{
                                const now = Date.now(); const lat = pos.coords.latitude, lng = pos.coords.longitude;
                                // Always send in background, even if position unchanged
                                sendLocation(pos);
                                updateDriverPosition(lat,lng); computeAndShowETA(lat,lng); if(driving) updateDriveProgress(lat,lng);
                                lastSentPos={lat,lng}; lastSentTime=now;
                            }, (err)=>{
                                // If geolocation fails (tab hidden or throttled), send last known position to keep bus online
                                if(lastSentPos){
                                    const synthetic = { coords: { latitude: lastSentPos.lat, longitude: lastSentPos.lng } };
                                    sendLocation(synthetic);
                                    updateDriverPosition(lastSentPos.lat,lastSentPos.lng);
                                }
                            }, { enableHighAccuracy:false, maximumAge:10000, timeout:8000 });
                        }catch(e){ /* ignore */ }
                    }, BACKGROUND_INTERVAL);

            document.getElementById('trackingStatus').textContent = `Active - Transport ${selectedBus}`;
            document.getElementById('statusDot').classList.add('active'); document.getElementById('statusDot').classList.remove('inactive');
            document.getElementById('startBtn').disabled = true; document.getElementById('stopBtn').disabled = false; busSelect.disabled = true;
            // keep routeSelect enabled so driver can choose route while tracking
        }

        function stopTracking(){
            if(watchId){ navigator.geolocation.clearWatch(watchId); watchId=null; }
                if(backgroundTimerId){ try{ clearInterval(backgroundTimerId); }catch(e){} backgroundTimerId=null; }
            if(selectedBus){ fetch(`/api/bus/${selectedBus}`, { method:'DELETE' }).then(()=>console.log(`Transport ${selectedBus} removed`)); }
            document.getElementById('trackingStatus').textContent='Inactive'; document.getElementById('statusDot').classList.remove('active'); document.getElementById('statusDot').classList.add('inactive');
            document.getElementById('startBtn').disabled=false; document.getElementById('stopBtn').disabled=true; busSelect.disabled=false; updateCount=0; document.getElementById('updateCount').textContent='0';
        }

        function sendLocation(position){
            if(!selectedBus) return;
            const location = { lat: position.coords.latitude, lng: position.coords.longitude, lastUpdate: new Date().toISOString(), routeId: selectedRoute || null };
            fetch(`/api/bus/${selectedBus}`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(location) })
            .then(res=>res.json()).then(()=>{ updateCount++; document.getElementById('updateCount').textContent = updateCount; updateDriverPosition(location.lat, location.lng); computeAndShowETA(location.lat, location.lng); if(driving) updateDriveProgress(location.lat, location.lng); const dot = document.getElementById('statusDot'); if(dot){ dot.classList.add('active'); dot.classList.remove('inactive'); dot.classList.remove('slow'); } })
            .catch(e=>console.error('send error',e));
        }

        // Smooth marker tween
        let tweenStart = 0, tweenDuration = 3000; let tweenFrom = null, tweenTo = null; function easeInOut(t){ return t<0.5 ? 2*t*t : -1+(4-2*t)*t; }
        function animateMarker(){
            if(!driverMarker || !tweenFrom || !tweenTo) return;
            const now = Date.now(); const elapsed = now - tweenStart; const t = Math.min(1, elapsed / tweenDuration); const k = easeInOut(t);
            const lat = tweenFrom[0] + (tweenTo[0]-tweenFrom[0]) * k;
            const lng = tweenFrom[1] + (tweenTo[1]-tweenFrom[1]) * k;
            try{ driverMarker.setLatLng([lat,lng]); }catch(e){}
            // soft follow: only pan near edges
            try{
                const pix = driverMap.latLngToContainerPoint([lat,lng]); const w = driverMap.getSize().x, h = driverMap.getSize().y; const m = 24;
                if(pix.x<m || pix.x>w-m || pix.y<m || pix.y>h-m){ driverMap.panTo([lat,lng], { animate:true }); }
            }catch(e){}
            if(t<1){ requestAnimationFrame(animateMarker); }
        }
        function updateDriverPosition(lat,lng){
            if(!driverMap) initDriverMap();
            let target = [lat,lng];
            // snap to route (approximate projection) if selected
            if(selectedRoute){ const route = allRoutes.find(r=>r.id===selectedRoute); if(route && route.waypoints){ const res = computeRouteProgress(lat,lng, route.waypoints); if(res && isFinite(res.projLat) && isFinite(res.projLng)){ target = [res.projLat, res.projLng]; }
                const coords = route.waypoints.map(w=>[w[0],w[1]]); if(driverRouteLine){ driverRouteLine.setLatLngs(coords); } else { driverRouteLine = L.polyline(coords, { color: route.color||'#2196F3', weight:4, opacity:0.9 }).addTo(driverMap); }
            } }
            if(!driverMarker){ driverMarker = L.circleMarker(target, { radius:7, color:'#34d399', fillColor:'#34d399', fillOpacity:1 }).addTo(driverMap); driverMap.setView(target, driverMap.getZoom()); tweenFrom = target; tweenTo = target; tweenStart = Date.now(); }
            else {
                tweenFrom = driverMarker.getLatLng() ? [driverMarker.getLatLng().lat, driverMarker.getLatLng().lng] : target;
                tweenTo = target; tweenStart = Date.now(); requestAnimationFrame(animateMarker);
            }
        }

        // ETA smoothing to avoid flicker
        let etaSmoothSecs = null; let etaLastTs = 0; const ETA_ALPHA = 0.35; const ETA_UPDATE_MS = 2500; const ETA_MIN_STEP = 3; let etaLastText = null;
        function smoothEta(secs){ if(!isFinite(secs)) return secs; if(etaSmoothSecs==null) { etaSmoothSecs = secs; return secs; } const sm = ETA_ALPHA*secs + (1-ETA_ALPHA)*etaSmoothSecs; // clamp minimal change
            if(Math.abs(sm-etaSmoothSecs) < ETA_MIN_STEP) { etaSmoothSecs = etaSmoothSecs + Math.sign(sm-etaSmoothSecs) * ETA_MIN_STEP; } else { etaSmoothSecs = sm; }
            return Math.max(0, Math.round(etaSmoothSecs)); }
        function formatHHMM(totalSeconds){ const mins = Math.max(0, Math.round(totalSeconds/60)); const h = Math.floor(mins/60); const m = mins % 60; return h>0 ? `${h}:${String(m).padStart(2,'0')}` : `${m}m`; }
        function maybeUpdateEtaDisplay(text){ const now = Date.now(); if(now - etaLastTs >= ETA_UPDATE_MS && text !== etaLastText){ const el = document.getElementById('etaDisplay'); if(el) el.textContent = text; etaLastText = text; etaLastTs = now; } }

        async function computeAndShowETA(lat,lng){
            const etaEl = document.getElementById('etaDisplay');
            if(!selectedRoute) return;
            const route = allRoutes.find(r=>r.id===selectedRoute); if(!route||!route.waypoints||!route.waypoints.length) return;
            // Direction-aware next stop: use progress along route
            const prog = computeRouteProgress(lat,lng, route.waypoints);
            const nextIdx = Math.min(route.waypoints.length-1, Math.max(1, prog.nextIdx));
            const target = route.waypoints[nextIdx]; if(!target) return;
            const url = `https://router.project-osrm.org/route/v1/driving/${lng},${lat};${target[1]},${target[0]}?overview=false`;
            try{
                const j = await osrmFetch(url, 5000);
                if(j && j.routes && j.routes.length){ const secs = Math.round(j.routes[0].duration); const disp = smoothEta(secs); const rounded = Math.round(disp/60)*60; maybeUpdateEtaDisplay(formatHHMM(rounded)); return; }
            }catch(e){ console.warn('OSRM duration fallback', e); }
            // Fallback: straight-line distance / avg speed (km/h)
            const meters = Math.sqrt(Math.pow(lat-target[0],2)+Math.pow(lng-target[1],2)) * 111000; const avgKmh = 20; const estSecs = Math.round(meters/ (avgKmh*1000/3600) ); const disp = smoothEta(estSecs); const rounded = Math.round(disp/60)*60; maybeUpdateEtaDisplay(formatHHMM(rounded));
        }

        function formatSeconds(s){ if(!isFinite(s)) return '‚Äî'; if(s<60) return `${s}s`; const m=Math.floor(s/60); const rem=s%60; return `${m}m ${rem}s`; }

        function showError(err){
            const statusEl = document.getElementById('trackingStatus');
            const dot = document.getElementById('statusDot');
            switch(err.code){
                case err.PERMISSION_DENIED:
                    alert('Please allow location access');
                    stopTracking();
                    break;
                case err.POSITION_UNAVAILABLE:
                    if(statusEl) statusEl.textContent = 'GPS unavailable, retrying‚Ä¶';
                    if(dot){ dot.classList.remove('active'); dot.classList.remove('inactive'); dot.classList.add('slow'); }
                    break;
                case err.TIMEOUT:
                    if(statusEl) statusEl.textContent = 'GPS slow, retrying‚Ä¶';
                    if(dot){ dot.classList.remove('active'); dot.classList.remove('inactive'); dot.classList.add('slow'); }
                    // Do not stop tracking on timeout; background timer will retry
                    break;
                default:
                    if(statusEl) statusEl.textContent = 'Tracking issue, retrying‚Ä¶';
                    if(dot){ dot.classList.remove('active'); dot.classList.remove('inactive'); dot.classList.add('slow'); }
            }
        }

        // Drive progress helpers (haversine and progress along route)
        function haversineMeters(aLat,aLng,bLat,bLng){ const R=6371000; const toRad=Math.PI/180; const dLat=(bLat-aLat)*toRad; const dLon=(bLng-aLng)*toRad; const lat1=aLat*toRad, lat2=bLat*toRad; const x=Math.sin(dLat/2)*Math.sin(dLat/2)+Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)*Math.sin(dLon/2); const c=2*Math.atan2(Math.sqrt(x),Math.sqrt(1-x)); return R*c; }
        function computeRouteTotals(waypoints){ let total=0; for(let i=0;i<waypoints.length-1;i++){ total+=haversineMeters(waypoints[i][0],waypoints[i][1],waypoints[i+1][0],waypoints[i+1][1]); } return total; }
        function computeRouteProgress(lat,lng,waypoints){ if(!waypoints||waypoints.length<2) return {pct:0,nextIdx:0,meters:0,projLat:lat,projLng:lng}; const avgLat=waypoints.reduce((s,w)=>s+w[0],0)/waypoints.length; const meterPerDegLat = 111132.92 - 559.82*Math.cos(2*avgLat*Math.PI/180) + 1.175*Math.cos(4*avgLat*Math.PI/180); const meterPerDegLon = 111412.84*Math.cos(avgLat*Math.PI/180) - 93.5*Math.cos(3*avgLat*Math.PI/180); function toXY(pt){ return {x: pt[1]*meterPerDegLon, y: pt[0]*meterPerDegLat}; } const pXY=toXY([lat,lng]); let cum=0,bestCum=0,bestDist=Infinity,bestNextIdx=1,bestProj={x:pXY.x,y:pXY.y}; for(let i=0;i<waypoints.length-1;i++){ const a=toXY(waypoints[i]); const b=toXY(waypoints[i+1]); const vx=b.x-a.x, vy=b.y-a.y; const wx=pXY.x-a.x, wy=pXY.y-a.y; const segLen2=vx*vx+vy*vy; let t = segLen2===0?0:((wx*vx+wy*vy)/segLen2); if(t<0) t=0; if(t>1) t=1; const projx=a.x+t*vx, projy=a.y+t*vy; const dx=pXY.x-projx, dy=pXY.y-projy; const dist=Math.sqrt(dx*dx+dy*dy); const distAlong = cum + Math.sqrt((projx-a.x)*(projx-a.x)+(projy-a.y)*(projy-a.y)); if(dist<bestDist){ bestDist=dist; bestCum=distAlong; bestNextIdx=i+1; bestProj={x:projx,y:projy}; } cum += Math.sqrt(vx*vx+vy*vy); } const total=computeRouteTotals(waypoints); const pct = total>0? Math.max(0,Math.min(100, Math.round((bestCum/total)*100))) : 0; const projLat = bestProj.y / meterPerDegLat; const projLng = bestProj.x / meterPerDegLon; return {pct, nextIdx: bestNextIdx, meters: Math.round(bestCum), totalMeters: Math.round(total), projLat, projLng}; }

        function startDrive(){ if(!selectedRoute){ alert('Select a route to start driving'); return; } driving=true; document.getElementById('startDriveBtn').disabled=true; document.getElementById('stopDriveBtn').disabled=false; const route = allRoutes.find(r=>r.id===selectedRoute); routeTotalMeters = route? computeRouteTotals(route.waypoints) : 0; if(lastSentPos) updateDriveProgress(lastSentPos.lat, lastSentPos.lng); }
        function stopDrive(){ driving=false; document.getElementById('startDriveBtn').disabled=false; document.getElementById('stopDriveBtn').disabled=true; document.getElementById('progressFill').style.width='0%'; document.getElementById('progressPercent').textContent='‚Äî'; document.getElementById('nextStopDisplay').textContent='‚Äî'; }
        function updateDriveProgress(lat,lng){ if(!selectedRoute) return; const route = allRoutes.find(r=>r.id===selectedRoute); if(!route) return; const res = computeRouteProgress(lat,lng, route.waypoints); document.getElementById('progressFill').style.width = `${res.pct}%`; document.getElementById('progressPercent').textContent = `${res.pct}%`; const nextName = (route.stops && route.stops[res.nextIdx]) ? route.stops[res.nextIdx] : `Stop ${res.nextIdx}`; document.getElementById('nextStopDisplay').textContent = nextName; }

        // initial load
        loadGlobalTheme();
        loadRoutes();

    </script>
</body>
</html>
