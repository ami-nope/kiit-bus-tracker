<!DOCTYPE html>
<html>
<head>
    <title>Transport Tracker - Admin</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        :root {
            --ui-theme-accent: #8b64ff;
            --ui-theme-accent-rgb: 139, 100, 255;
            --ui-theme-hue: 0deg;
            --ui-theme-saturation: 120%;
        }
        * { box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #0b0c10; color:#e6eef8; padding:24px; filter: hue-rotate(var(--ui-theme-hue)) saturate(var(--ui-theme-saturation)); }
        .panel { max-width:1400px; margin: 0 auto; background: #0d1117; border-radius:12px; padding:18px; border:1px solid rgba(255,255,255,0.04); box-shadow: none }
        body.gold-admin {
            position: relative;
            min-height: 100vh;
            color: #f6e6b8;
            background:
                radial-gradient(1200px 700px at 86% -8%, rgba(255, 220, 128, 0.22), transparent 56%),
                radial-gradient(940px 560px at -10% 100%, rgba(219, 155, 34, 0.18), transparent 54%),
                linear-gradient(160deg, #0f0b04 0%, #171106 42%, #120d05 100%);
        }
        body.gold-admin::before {
            content: '';
            position: fixed;
            inset: 0;
            pointer-events: none;
            opacity: 0.56;
            background:
                linear-gradient(115deg, rgba(255, 255, 255, 0.07) 0%, rgba(255, 255, 255, 0) 38%),
                repeating-linear-gradient(135deg, rgba(212, 164, 48, 0.05) 0 1px, transparent 1px 18px);
            mix-blend-mode: screen;
        }
        body.gold-admin .panel {
            position: relative;
            overflow: hidden;
            background:
                linear-gradient(180deg, rgba(40, 29, 11, 0.98) 0%, rgba(24, 18, 8, 0.98) 100%);
            border-color: rgba(212, 164, 48, 0.42);
            box-shadow:
                0 0 0 1px rgba(212, 164, 48, 0.2),
                0 16px 44px rgba(0, 0, 0, 0.45),
                0 0 44px rgba(212, 164, 48, 0.08);
        }
        body.gold-admin .panel::after {
            content: '';
            position: absolute;
            top: -140%;
            left: -40%;
            width: 62%;
            height: 320%;
            transform: rotate(16deg);
            background: linear-gradient(90deg, rgba(255,255,255,0), rgba(255,230,164,0.18), rgba(255,255,255,0));
            pointer-events: none;
            animation: goldSweep 8s linear infinite;
        }
        body.gold-admin .topbar {
            padding: 12px 14px;
            border-radius: 12px;
            border: 1px solid rgba(212, 164, 48, 0.26);
            background: linear-gradient(180deg, rgba(255, 220, 140, 0.09), rgba(255, 220, 140, 0.03));
            box-shadow: inset 0 1px 0 rgba(255, 243, 205, 0.12);
        }
        body.gold-admin .subtitle,
        body.gold-admin .muted,
        body.gold-admin .small {
            color: #c7b894;
        }
        body.gold-admin a {
            color: #f6d783 !important;
        }
        body.gold-admin .tabs {
            border-bottom-color: rgba(212, 164, 48, 0.24);
        }
        body.gold-admin .tab {
            color: #c8b17b;
            transition: color .2s ease, background .2s ease, border-color .2s ease, box-shadow .2s ease;
        }
        body.gold-admin .tab:hover {
            color: #f5df9f;
            background: rgba(212, 164, 48, 0.08);
        }
        body.gold-admin .tab.active {
            border-bottom-color: #d4a430;
            color: #ffe6a6;
            text-shadow: 0 0 10px rgba(255, 224, 140, 0.25);
            box-shadow: inset 0 -2px 0 rgba(212, 164, 48, 0.34);
        }
        body.gold-admin input,
        body.gold-admin select,
        body.gold-admin textarea {
            background: linear-gradient(180deg, #171005 0%, #100b04 100%);
            border-color: rgba(212, 164, 48, 0.36);
            color: #f9edc6;
        }
        body.gold-admin input:focus,
        body.gold-admin select:focus,
        body.gold-admin textarea:focus {
            outline: none;
            border-color: rgba(255, 214, 116, 0.78);
            box-shadow: 0 0 0 2px rgba(212, 164, 48, 0.18);
        }
        body.gold-admin button {
            color: #f5e5ba;
            border-color: rgba(212, 164, 48, 0.34);
            background: linear-gradient(180deg, #2b1f0c 0%, #1a1309 100%);
            box-shadow: inset 0 1px 0 rgba(255, 234, 179, 0.11);
            transition: transform .18s ease, box-shadow .18s ease, border-color .18s ease, background .18s ease;
        }
        body.gold-admin button:hover {
            transform: translateY(-1px);
            border-color: rgba(235, 188, 77, 0.62);
            background: linear-gradient(180deg, #38280f 0%, #21170a 100%);
            box-shadow: 0 6px 18px rgba(0,0,0,0.28), inset 0 1px 0 rgba(255, 236, 190, 0.18);
        }
        body.gold-admin .ok {
            color: #fff0c0;
            border-color: rgba(219, 170, 53, 0.68);
            background: linear-gradient(180deg, #8f6a19 0%, #6b4f12 100%);
        }
        body.gold-admin .ok:hover {
            border-color: rgba(245, 199, 90, 0.86);
            background: linear-gradient(180deg, #a2771b 0%, #785714 100%);
        }
        body.gold-admin .route-panel,
        body.gold-admin .perf-card,
        body.gold-admin .audit-wrap {
            background: linear-gradient(180deg, rgba(38, 28, 12, 0.84), rgba(23, 17, 8, 0.84));
            border-color: rgba(212, 164, 48, 0.26);
            box-shadow: inset 0 1px 0 rgba(255, 240, 194, 0.08);
        }
        body.gold-admin thead th {
            color: #e4ce90;
            border-bottom-color: rgba(212, 164, 48, 0.24);
        }
        body.gold-admin tbody td {
            border-bottom-color: rgba(212, 164, 48, 0.12);
        }
        .gold-badge {
            display:inline-block;
            margin-left:6px;
            padding:3px 10px;
            border-radius:999px;
            background: linear-gradient(120deg, #8d6314 0%, #f5d983 48%, #8d6314 100%);
            background-size: 210% 100%;
            color:#291b05;
            border:1px solid rgba(243, 210, 119, 0.74);
            box-shadow: 0 2px 10px rgba(212, 164, 48, 0.34);
            font-size:11px;
            font-weight:700;
            letter-spacing:0.05em;
            animation: goldPulse 3.2s ease-in-out infinite;
        }
        .gold-banner {
            position: relative;
            overflow: hidden;
            margin-bottom:12px;
            padding:11px 13px;
            border-radius:12px;
            border:1px solid rgba(236, 190, 79, 0.54);
            background: linear-gradient(95deg, rgba(112, 79, 17, 0.34), rgba(212, 164, 48, 0.2), rgba(112, 79, 17, 0.34));
            color:#f5db8d;
            font-size:13px;
            box-shadow: inset 0 1px 0 rgba(255, 239, 196, 0.12);
        }
        .gold-banner::after {
            content: '';
            position: absolute;
            top: 0;
            left: -50%;
            width: 46%;
            height: 100%;
            transform: skewX(-18deg);
            background: linear-gradient(90deg, rgba(255,255,255,0), rgba(255,246,219,0.2), rgba(255,255,255,0));
            animation: goldBannerSweep 4.8s linear infinite;
            pointer-events: none;
        }
        .pw-toggle-btn {
            margin-top:0;
            border: 1px solid rgba(230, 189, 85, 0.68);
            background: linear-gradient(180deg, #b8871e 0%, #936b16 100%);
            color:#fef3d0;
            padding:4px 8px;
            border-radius:6px;
            cursor:pointer;
            font-size:11px;
        }
        .pw-pill {
            display:inline-block;
            min-width:110px;
            font-family:monospace;
            font-size:12px;
        }
        @keyframes goldSweep {
            0% { transform: translateX(0) rotate(16deg); opacity: 0; }
            10% { opacity: 1; }
            50% { opacity: 1; }
            100% { transform: translateX(240%) rotate(16deg); opacity: 0; }
        }
        @keyframes goldPulse {
            0%, 100% { background-position: 0% 50%; box-shadow: 0 2px 10px rgba(212, 164, 48, 0.25); }
            50% { background-position: 100% 50%; box-shadow: 0 3px 14px rgba(212, 164, 48, 0.45); }
        }
        @keyframes goldBannerSweep {
            0% { left: -52%; }
            100% { left: 130%; }
        }
        h1 { margin:0 0 6px 0; font-size:20px }
        p.subtitle { margin:0 0 14px 0; color:#9aa4b2 }
        .controls { display:flex; gap:10px; align-items:center; margin-bottom:12px; flex-wrap:wrap }
        .theme-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            border-radius: 12px;
            border: 1px solid rgba(var(--ui-theme-accent-rgb), 0.35);
            background: linear-gradient(180deg, rgba(var(--ui-theme-accent-rgb), 0.18), rgba(255,255,255,0.03));
            min-width: 320px;
        }
        .theme-controls .field-label {
            margin: 0;
            font-size: 11px;
            line-height: 1.1;
            color: #d4ddf0;
        }
        .theme-controls input[type=color] {
            width: 46px;
            height: 34px;
            border-radius: 9px;
            border: 1px solid rgba(255,255,255,0.22);
            background: rgba(10,14,24,0.45);
            padding: 2px;
            cursor: pointer;
        }
        .theme-controls input[type=range] {
            width: 120px;
        }
        .theme-sat-value {
            min-width: 48px;
            text-align: right;
            font-size: 12px;
            color: #d6dff5;
        }
        .theme-save-status {
            min-width: 84px;
            font-size: 11px;
            color: #b6c2d8;
            white-space: nowrap;
        }
        .theme-save-timer {
            min-width: 92px;
            font-size: 11px;
            color: #d2dbf0;
            white-space: nowrap;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .theme-save-timer[hidden] {
            display: none !important;
        }
        .theme-save-timer .dot {
            width: 8px;
            height: 8px;
            border-radius: 999px;
            background: var(--ui-theme-accent);
            box-shadow: 0 0 0 rgba(var(--ui-theme-accent-rgb), 0.38);
            animation: themeApplyPulse 1s ease-in-out infinite;
        }
        @keyframes themeApplyPulse {
            0%, 100% { transform: scale(0.9); box-shadow: 0 0 0 0 rgba(var(--ui-theme-accent-rgb), 0.38); }
            50% { transform: scale(1.1); box-shadow: 0 0 0 6px rgba(var(--ui-theme-accent-rgb), 0); }
        }
        .theme-controls.is-applying button,
        .theme-controls.is-applying input {
            opacity: 0.82;
        }
        .theme-controls button {
            background: rgba(var(--ui-theme-accent-rgb), 0.24);
            border-color: rgba(var(--ui-theme-accent-rgb), 0.46);
        }
        .theme-controls button:hover {
            background: rgba(var(--ui-theme-accent-rgb), 0.34);
        }
        .theme-preview-dot {
            width: 12px;
            height: 12px;
            border-radius: 999px;
            background: var(--ui-theme-accent);
            box-shadow: 0 0 0 1px rgba(255,255,255,0.55), 0 0 12px rgba(var(--ui-theme-accent-rgb), 0.55);
        }
        input, select, textarea { padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.06); background:#0f0f23; color:#e6eef8 }
        button { background:#0f0f23; color:#e6eef8; border:1px solid rgba(255,255,255,0.06); padding:8px 12px; border-radius:10px; cursor:pointer }
        button:hover { background:rgba(255,255,255,0.05) }
        table { width:100%; border-collapse:collapse; margin-top:12px }
        thead th { text-align:left; padding:10px; font-size:13px; color:#9aa4b2; border-bottom:1px solid rgba(255,255,255,0.03) }
        tbody td { padding:10px; vertical-align:middle; border-bottom:1px dashed rgba(255,255,255,0.02) }
        .small { font-size:13px; color:#9aa4b2 }
        .muted { color:#8893a6 }
        .danger { color:#ff7b8a; border-color: rgba(255,123,138,0.12) }
        .ok { color:#34d399; border-color: rgba(52,211,153,0.08) }
        .row-actions button { margin-right:8px }
        .empty { text-align:center; color:#8290a3; padding:20px }
        .topbar { display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:20px }
        .tabs { display:flex; gap:8px; border-bottom:1px solid rgba(255,255,255,0.03); margin-bottom:18px }
        .tab { padding:10px 16px; cursor:pointer; color:#9aa4b2; border-bottom:2px solid transparent }
        .tab.active { color:#e6eef8; border-bottom-color: var(--ui-theme-accent) }
        .tab-content { display:none }
        .tab-content.active { display:block }
        .field-group { margin-bottom:12px }
        .field-label { font-size:12px; color:#9aa4b2; margin-bottom:4px; display:block; font-weight:600 }
        /* Solid surface overrides for standard admin mode */
        body:not(.gold-admin) .panel,
        body:not(.gold-admin) .route-panel,
        body:not(.gold-admin) .stops-list,
        body:not(.gold-admin) .route-card,
        body:not(.gold-admin) .perf-card,
        body:not(.gold-admin) .audit-wrap {
            background: #0d111b;
            border-color: #243149;
        }
        body:not(.gold-admin) .instruction-box {
            background: #16233b;
            border-color: #2d4c88;
        }
        body:not(.gold-admin) .stop-radius-wrap {
            background: #141f33;
            border-color: #2b467d;
        }
        body:not(.gold-admin) .draw-mode-hint kbd {
            background: #1a2539;
            border-color: #2b3b58;
            color: #dbeafe;
        }
        body:not(.gold-admin) input,
        body:not(.gold-admin) select,
        body:not(.gold-admin) textarea {
            background: #0f1728;
            border-color: #2b3b58;
            color: #e6eef8;
        }
        body:not(.gold-admin) select option {
            background: #0f1728;
            color: #e6eef8;
        }
        body:not(.gold-admin) button {
            background: #18253b;
            border-color: #2b3b58;
            color: #e6eef8;
        }
        body:not(.gold-admin) button:hover {
            background: #21314b;
        }
        .leaflet-control-zoom a {
            background: #111c2e !important;
            color: #e6eef8 !important;
            border-color: #2b3b58 !important;
        }
        .leaflet-popup-content-wrapper,
        .leaflet-popup-tip {
            background: #111c2e !important;
            color: #e6eef8 !important;
            border: 1px solid #2b3b58 !important;
        }
        
        /* Route Builder */
        #routeMap { height:500px; border-radius:8px; margin-bottom:16px; border:2px solid rgba(102,126,234,0.3) }
        .route-builder { display:grid; grid-template-columns:1.2fr 1fr; gap:20px; margin-bottom:20px }
        @media (max-width:1000px) { .route-builder { grid-template-columns:1fr } }
        
        .route-panel { background:#0f0f23; padding:18px; border-radius:10px; border:1px solid rgba(255,255,255,0.06) }
        .step-indicator { display:flex; gap:10px; margin-bottom:18px }
        .step { padding:8px 12px; border-radius:6px; font-size:12px; text-align:center; flex:1; background:#0d1117; color:#9aa4b2; font-weight:500 }
        .step.active { background:#667eea; color:#fff; box-shadow:0 0 12px rgba(102,126,234,0.4) }
        .step.done { background:#34d399; color:#fff }
        
        .instruction-box { background:rgba(102,126,234,0.1); padding:12px; border-radius:6px; border:1px solid rgba(102,126,234,0.2); margin-bottom:14px; font-size:13px; line-height:1.5 }
        .instruction-main { font-size:14px; font-weight:600; color:#667eea; margin-bottom:4px }
        .instruction-sub { color:#9aa4b2; margin-top:2px }
        .draw-mode-hint { margin-top:6px; font-size:11px; color:#9aa4b2 }
        .draw-mode-hint kbd {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 4px;
            padding: 1px 5px;
            font-family: monospace;
            font-size: 11px;
        }
        .stop-radius-wrap {
            margin-top: 8px;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(102,126,234,0.22);
            background: rgba(102,126,234,0.06);
        }
        .stop-radius-head {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #c7d2fe;
            user-select: none;
        }
        .stop-radius-head input[type=checkbox] {
            width: 14px;
            height: 14px;
            accent-color: #667eea;
            cursor: pointer;
        }
        .stop-radius-head .value {
            margin-left: auto;
            font-size: 10px;
            color: #dbe3ff;
            border: 1px solid rgba(102,126,234,0.36);
            border-radius: 999px;
            padding: 2px 7px;
            background: rgba(102,126,234,0.18);
        }
        .stop-radius-controls {
            margin-top: 8px;
            display: none;
            flex-direction: column;
            gap: 8px;
        }
        .stop-radius-controls.visible { display: flex; }
        .stop-radius-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .stop-radius-row input[type=range] {
            flex: 1;
            min-width: 0;
        }
        .stop-radius-row .meter {
            min-width: 54px;
            text-align: right;
            font-size: 11px;
            color: #9aa4b2;
        }
        .stop-radius-row input[type=number] {
            flex: 1;
            min-width: 0;
            font-size: 12px;
            padding: 6px 8px;
        }
        .stop-radius-row button {
            padding: 6px 10px;
            font-size: 11px;
            border-radius: 8px;
        }
        .route-snap-wrap {
            margin-top: 8px;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(102,126,234,0.24);
            background: rgba(102,126,234,0.05);
        }
        .route-snap-title {
            font-size: 12px;
            font-weight: 600;
            color: #d6e1ff;
            margin-bottom: 8px;
        }
        .route-snap-head {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #c7d2fe;
            user-select: none;
        }
        .route-snap-head input[type=checkbox] {
            width: 14px;
            height: 14px;
            accent-color: #667eea;
            cursor: pointer;
        }
        .route-snap-head .value {
            margin-left: auto;
            font-size: 10px;
            color: #dbe3ff;
            border: 1px solid rgba(102,126,234,0.36);
            border-radius: 999px;
            padding: 2px 7px;
            background: rgba(102,126,234,0.18);
        }
        .route-snap-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }
        .route-snap-row input[type=range] {
            flex: 1;
            min-width: 0;
        }
        .route-snap-row input[type=number] {
            flex: 1;
            min-width: 0;
            font-size: 12px;
            padding: 6px 8px;
        }
        .route-snap-row .meter {
            min-width: 54px;
            text-align: right;
            font-size: 11px;
            color: #9aa4b2;
        }
        .route-snap-row button {
            padding: 6px 10px;
            font-size: 11px;
            border-radius: 8px;
            white-space: nowrap;
        }
        .route-snap-sep {
            height: 1px;
            margin: 10px 0 8px 0;
            background: linear-gradient(90deg, rgba(255,255,255,0), rgba(102,126,234,0.32), rgba(255,255,255,0));
        }
        .route-snap-controls {
            margin-top: 8px;
            display: none;
            flex-direction: column;
            gap: 8px;
        }
        .route-snap-controls.visible {
            display: flex;
        }
        .route-follow-wrap {
            margin-top: 8px;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(102,126,234,0.20);
            background: rgba(102,126,234,0.05);
        }
        .follow-road-segments {
            margin-top: 8px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 172px;
            overflow-y: auto;
            padding-right: 2px;
        }
        .follow-road-empty {
            font-size: 11px;
            color: #9aa4b2;
            border: 1px dashed rgba(102,126,234,0.35);
            border-radius: 8px;
            padding: 8px;
            background: rgba(15, 23, 42, 0.35);
        }
        .follow-road-segment-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            color: #d8e2ff;
            border: 1px solid rgba(102,126,234,0.24);
            border-radius: 8px;
            padding: 7px 8px;
            background: rgba(10, 15, 30, 0.36);
        }
        .follow-road-segment-row input[type=checkbox] {
            width: 14px;
            height: 14px;
            accent-color: #667eea;
            cursor: pointer;
            flex: 0 0 auto;
        }
        .follow-road-segment-label {
            flex: 1;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .follow-road-segment-mode {
            flex: 0 0 auto;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.04em;
            border: 1px solid rgba(102,126,234,0.35);
            border-radius: 999px;
            padding: 2px 8px;
            color: #dbe3ff;
            background: rgba(102,126,234,0.18);
        }
        @media (max-width: 520px) {
            .route-snap-row,
            .stop-radius-row {
                flex-wrap: wrap;
            }
            .route-snap-row button,
            .stop-radius-row button {
                width: 100%;
            }
        }
        
        .stops-list { max-height:450px; overflow-y:auto; background:#0d1117; border-radius:6px; padding:10px }
        .stop-item { padding:10px; background:#07101a; border-radius:6px; margin-bottom:8px; border-left:4px solid; display:flex; gap:8px; align-items:center; font-size:13px }
        .stop-item.start { border-left-color:#4CAF50; background:#0d1117 }
        .stop-item input { flex:1; background:#0f0f23; border:1px solid rgba(255,255,255,0.04); color:#e6eef8; padding:6px 8px; border-radius:4px }
        .stop-num { min-width:28px; text-align:center; color:#9aa4b2; font-weight:bold; font-size:12px }
        .stop-icon { font-size:16px }
        /* Unified icon styling */
        .icon { display:inline-block; font-size:14px; line-height:1; vertical-align:middle; opacity:0.9; margin-right:6px }
        .tab .icon { font-size:16px; opacity:0.85 }
        .field-label .icon { font-size:14px }
        .route-panel h3 .icon { font-size:15px }
        .stop-icon { font-size:13px }
        /* Map tiny markers (fixed pixel size, crisp) */
        .tiny-marker { width:8px; height:8px; border-radius:50%; display:inline-block; border:1px solid rgba(255,255,255,0.5) }
        .tiny-marker:hover { transform: none; }
        .tiny-start { width:10px; height:10px; background:#4CAF50 }
        .tiny-hostel { background:#9C27B0 }
        .tiny-class { background:#2196F3 }
        .tiny-stop { background:#667eea }
        .marker-wrapper { width:10px; height:10px }
        /* Remove default white background from DivIcons */
        .leaflet-div-icon { background: transparent !important; border: none !important; }
        
        .button-group { display:flex; gap:8px; margin-top:14px }
        .button-group button { flex:1 }
        
        .routes-grid { display:grid; grid-template-columns:repeat(auto-fill, minmax(280px, 1fr)); gap:12px; margin-top:12px }
        .route-card { background:#0f0f23; padding:12px; border-radius:10px; border-left:5px solid; border:1px solid rgba(255,255,255,0.06) }
        .route-badge { display:inline-block; padding:4px 8px; border-radius:999px; font-size:11px; font-weight:600 }
        .badge-running { background:rgba(52,211,153,0.12); color:#34d399; border:1px solid rgba(52,211,153,0.25) }
        .badge-idle { background:rgba(255,154,162,0.1); color:#ff9aa2; border:1px solid rgba(255,154,162,0.25) }
        .route-name { font-weight:600; margin-bottom:4px }
        .route-info { font-size:12px; color:#9aa4b2; margin-bottom:8px }
        .route-actions { display:flex; gap:6px }
        .route-actions button { flex:1; font-size:12px; padding:6px }
        .perf-grid { display:grid; grid-template-columns:repeat(auto-fit, minmax(180px, 1fr)); gap:10px; margin-bottom:14px }
        .perf-card {
            background:#0f0f23;
            border:1px solid rgba(255,255,255,0.06);
            border-radius:10px;
            padding:12px;
        }
        .perf-k { font-size:11px; color:#9aa4b2; margin-bottom:6px; text-transform:uppercase; letter-spacing:0.04em }
        .perf-v { font-size:16px; font-weight:600; color:#e6eef8 }
        .perf-v.small { font-size:13px; font-weight:500; color:#c8d2e0 }
        .perf-two-col { display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:14px }
        @media (max-width:900px) { .perf-two-col { grid-template-columns:1fr; } }
        .sparkline-card { padding-bottom:10px; }
        .sparkline {
            width: 100%;
            height: 72px;
            display: block;
            border-radius: 8px;
            background: rgba(255,255,255,0.02);
            cursor: zoom-in;
        }
        .sparkline:focus-visible {
            outline: 2px solid #60a5fa;
            outline-offset: 2px;
        }
        .sparkline-meta {
            margin-top: 8px;
            display: flex;
            justify-content: space-between;
            gap: 10px;
            font-size: 11px;
            color: #9aa4b2;
        }
        .sparkline-value {
            font-size: 12px;
            font-weight: 600;
            color: #e6eef8;
        }
        body.gold-admin .sparkline {
            background: rgba(212, 164, 48, 0.08);
        }
        body.gold-admin .sparkline-meta {
            color: #c7b894;
        }
        body.perf-detail-open { overflow: hidden; }
        .perf-detail-modal {
            position: fixed;
            inset: 0;
            z-index: 1200;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(2, 6, 14, 0.78);
            backdrop-filter: blur(4px);
            padding: 24px;
        }
        .perf-detail-modal[hidden] { display: none !important; }
        .perf-detail-dialog {
            width: min(1080px, 96vw);
            height: min(78vh, 760px);
            background: #0b1220;
            border: 1px solid rgba(255,255,255,0.10);
            border-radius: 12px;
            box-shadow: 0 28px 80px rgba(0,0,0,0.55);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        body.gold-admin .perf-detail-dialog {
            background: #161107;
            border-color: rgba(212,164,48,0.35);
            box-shadow: 0 28px 80px rgba(0,0,0,0.60), 0 0 0 1px rgba(212,164,48,0.18) inset;
        }
        .perf-detail-head {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 12px;
            padding: 14px 16px;
            border-bottom: 1px solid rgba(255,255,255,0.08);
        }
        .perf-detail-title {
            margin: 0;
            font-size: 16px;
            font-weight: 700;
            color: #e6eef8;
        }
        .perf-detail-subtitle {
            margin-top: 4px;
            font-size: 12px;
            color: #9aa4b2;
        }
        .perf-detail-close {
            border: 1px solid rgba(255,255,255,0.16);
            background: rgba(255,255,255,0.06);
            color: #e6eef8;
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
        }
        .perf-detail-close:hover {
            background: rgba(255,255,255,0.12);
        }
        .perf-detail-body {
            flex: 1;
            padding: 14px 14px 16px 14px;
            min-height: 280px;
        }
        .perf-detail-canvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 10px;
            background: rgba(255,255,255,0.02);
        }
        @media (max-width: 768px) {
            .perf-detail-modal { padding: 12px; }
            .perf-detail-dialog { height: min(86vh, 760px); }
        }
        .audit-wrap {
            background:#0f0f23;
            border:1px solid rgba(255,255,255,0.06);
            border-radius:10px;
            padding:10px;
        }
        .audit-table-wrap { max-height:320px; overflow:auto; border-radius:8px; }
        #perfAuditTable { margin-top:0; font-size:12px; }
        #perfAuditTable td { font-size:12px; color:#c6d0df; }
        #perfAuditTable .status-ok { color:#34d399; font-weight:600; }
        #perfAuditTable .status-failed, #perfAuditTable .status-error { color:#ff7b8a; font-weight:600; }

        cursor-info { font-size:11px; color:#667eea; text-align:center; margin-top:8px; display:block }
    </style>
</head>
<body class="{% if is_gold_admin %}gold-admin{% endif %}">
    <div class="panel">
        <div class="topbar">
            <div>
                <div style="font-weight:700; font-size:14px; color:#e6eef8">{{ institute_name | default('INSTITUTE') }} TRANSPORT SYSTEM</div>
                <h1>üõ£Ô∏è Route Builder</h1>
                <p class="subtitle">Create routes by clicking on the map - no coordinates needed!</p>
                <div class="controls" style="margin-top:8px">
                    <label class="field-label" for="totalTransportsInput">Total Transports</label>
                    <button id="decTotalTransports">‚àí</button>
                    <input id="totalTransportsInput" type="number" min="0" value="100" style="width:100px">
                    <button id="incTotalTransports">+</button>
                    <button id="saveTotalTransports" class="ok">Save</button>
                    <div class="theme-controls" title="Global UI theme">
                        <span class="theme-preview-dot" id="themePreviewDot" aria-hidden="true"></span>
                        <div>
                            <label class="field-label" for="themeAccentInput">Global Color</label>
                            <input id="themeAccentInput" type="color" value="#8b64ff" aria-label="Global color picker">
                        </div>
                        <div>
                            <label class="field-label" for="themeSaturationInput">Saturation</label>
                            <input id="themeSaturationInput" type="range" min="20" max="260" step="1" value="120" aria-label="Global saturation slider">
                        </div>
                        <span class="theme-sat-value" id="themeSaturationValue">120%</span>
                        <button id="saveUiThemeBtn" type="button">Apply Theme</button>
                        <span class="theme-save-status" id="themeSaveStatus"></span>
                        <span class="theme-save-timer" id="themeSaveTimer" hidden><span class="dot" aria-hidden="true"></span><span id="themeSaveTimerText">Applying 0.0s</span></span>
                    </div>
                </div>
            </div>
            <div style="text-align:right">
                <a href="/" target="_blank" rel="noopener noreferrer" style="color:#9aa4b2; text-decoration:none; margin-right:12px">Student View</a>
                <a href="/driver" target="_blank" rel="noopener noreferrer" style="color:#9aa4b2; text-decoration:none; margin-right:12px">Driver View</a>
                <a href="/simulator" target="_blank" rel="noopener noreferrer" style="color:#9aa4b2; text-decoration:none; margin-right:12px">Simulator</a>
                <button onclick="showUsersSection()" style="background:#34d399;color:#042017;margin-right:12px;padding:8px 16px;border-radius:8px;border:none;cursor:pointer">Users</button>
                {% if is_gold_admin %}
                <button id="openAuditLogBtn" style="margin-right:8px;padding:8px 12px;border-radius:8px;border:none;cursor:pointer;background:#b8871e;color:#fff3d0">Audit Log</button>
                <button id="openAdminLogBtn" style="margin-right:12px;padding:8px 12px;border-radius:8px;border:none;cursor:pointer;background:#8f6a19;color:#fff3d0">Admin Log</button>
                {% endif %}
                {% if admin_user %}
                    <span style="color:#9aa4b2; margin-right:8px">{{ admin_user }}</span>
                    {% if is_gold_admin %}
                        <span class="gold-badge">GOLD ADMIN</span>
                    {% endif %}
                    <a href="/admin/logout" style="color:#ff9aa2; text-decoration:none">Logout</a>
                {% else %}
                    <a href="/admin/login" style="color:#9aa4b2; text-decoration:none">Admin Login</a>
                {% endif %}
            </div>
        </div>

        {% if is_gold_admin %}
        <div class="gold-banner">Gold Admin mode is active. You can manage admins, review all admin activity, and reveal stored admin passwords.</div>
        {% endif %}

        <div class="tabs">
            <div class="tab" data-tab="routes"><span class="icon">üó∫Ô∏è</span> Create Route</div>
            <div class="tab active" data-tab="buses"><span class="icon">üöå</span> Manage Transports</div>
            <div class="tab" data-tab="buildings"><span class="icon">üè†</span> Buildings</div>
            <div class="tab" data-tab="serverPerf"><span class="icon">‚ö°</span> Server Performance</div>
            {% if is_gold_admin %}
            <div class="tab" data-tab="adminConsole"><span class="icon">üõ°Ô∏è</span> Admin Console</div>
            {% endif %}
        </div>
        <div id="usersSection" style="display:none;background:#07101a;padding:18px;border-radius:8px;margin-bottom:18px">
            <h2 style="color:#34d399">All Users</h2>
            <div id="usersTable"></div>
            <h3 style="margin-top:16px;color:#e6eef8;font-size:16px">Manage Admins</h3>
            <div id="manageAdminControls" style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px;align-items:center">
                <input id="adminUsername" placeholder="Username" style="min-width:160px">
                <div style="display:flex;gap:8px;align-items:center">
                    <input id="adminPassword" type="password" placeholder="Password" style="min-width:160px">
                    <button type="button" onclick="toggleVisibility('adminPassword', this)" style="margin-top:0;background:#667eea;color:#fff">Show</button>
                </div>
                <input id="adminPin" placeholder="Role signup pin (6 digits)" style="min-width:220px">
                <button class="ok" onclick="addAdmin()">+ Add Admin</button>
            </div>
            <div id="manageAdminsHint" class="note" style="margin-bottom:8px;color:#b9c3d2">{% if is_gold_admin %}You can create admins using the active signup pins.{% else %}Admin account management is restricted for this account.{% endif %}</div>
            <div id="pinManager" style="display:none; margin:12px 0; padding:12px; border-radius:10px; border:1px solid rgba(212, 164, 48, 0.35); background:rgba(212, 164, 48, 0.08)">
                <div style="font-weight:700; margin-bottom:10px; color:#f2d27a">Security Pins</div>
                <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(220px, 1fr)); gap:10px; margin-bottom:10px">
                    <label class="note" style="margin:0">Admin Signup Pin
                        <input id="pinAdminSignup" type="password" maxlength="6" placeholder="6 digits">
                    </label>
                    <label class="note" style="margin:0">Gold Signup Pin
                        <input id="pinGoldSignup" type="password" maxlength="6" placeholder="6 digits">
                    </label>
                    <label class="note" style="margin:0">Admin Login Pin
                        <input id="pinAdminLogin" type="password" maxlength="6" placeholder="6 digits">
                    </label>
                    <label class="note" style="margin:0">Gold Login Pin
                        <input id="pinGoldLogin" type="password" maxlength="6" placeholder="6 digits">
                    </label>
                </div>
                <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap">
                    <button type="button" class="ok" onclick="savePinSettings()">Save Pins</button>
                    <button type="button" onclick="togglePinVisibility()">Show/Hide Pins</button>
                    <span id="pinSaveStatus" class="note"></span>
                </div>
            </div>
            <div id="adminsTable"></div>
            <button onclick="hideUsersSection()" style="margin-top:12px;background:#ff7b8a;color:#fff;padding:8px 16px;border-radius:8px;border:none;cursor:pointer">Close</button>
        </div>
        <script>
        const CURRENT_ADMIN = {{ (admin_user or '') | tojson }};
        const CAN_ACCESS_SECURE_ADMIN = {{ (is_gold_admin or false) | tojson }};
        const adminPasswordCache = {};

        function escapeHtml(v) {
            return String(v ?? '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function maskSecret(secret) {
            const raw = String(secret || '');
            if (!raw) return '(unavailable)';
            return '*'.repeat(Math.max(8, raw.length));
        }

        function toggleInlineSecret(spanId, btn) {
            const span = document.getElementById(spanId);
            if (!span) return;
            const secret = String(adminPasswordCache[spanId] || '');
            const isShowing = span.getAttribute('data-show') === '1';
            if (isShowing) {
                span.textContent = maskSecret(secret);
                span.setAttribute('data-show', '0');
                if (btn) btn.textContent = 'Show';
            } else {
                span.textContent = secret || '(unavailable)';
                span.setAttribute('data-show', '1');
                if (btn) btn.textContent = 'Hide';
            }
        }

        function applyAdminRoleUi() {
            const controls = document.getElementById('manageAdminControls');
            const hint = document.getElementById('manageAdminsHint');
            const pinManager = document.getElementById('pinManager');
            if (CAN_ACCESS_SECURE_ADMIN) {
                if (controls) controls.style.display = 'flex';
                if (hint) hint.textContent = 'Full admin security controls are enabled for this account.';
                if (pinManager) pinManager.style.display = 'block';
                return;
            }
            if (controls) controls.style.display = 'none';
            if (hint) hint.textContent = 'You do not have permission to manage admin accounts or security settings.';
            if (pinManager) pinManager.style.display = 'none';
        }

        function pinInputIds() {
            return ['pinAdminSignup', 'pinGoldSignup', 'pinAdminLogin', 'pinGoldLogin'];
        }

        function setPinSaveStatus(msg, isError = false) {
            const el = document.getElementById('pinSaveStatus');
            if (!el) return;
            el.textContent = msg || '';
            el.style.color = isError ? '#ff7b8a' : '#b9c3d2';
        }

        function togglePinVisibility() {
            for (const id of pinInputIds()) {
                const input = document.getElementById(id);
                if (!input) continue;
                input.type = input.type === 'password' ? 'text' : 'password';
            }
        }

        async function loadPinSettings() {
            if (!CAN_ACCESS_SECURE_ADMIN) return;
            try {
                const res = await fetch('/admin/pins', { cache: 'no-store' });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to load pins');
                const pins = data.pins || {};
                const map = {
                    pinAdminSignup: pins.admin_signup_pin || '',
                    pinGoldSignup: pins.gold_signup_pin || '',
                    pinAdminLogin: pins.admin_login_pin || '',
                    pinGoldLogin: pins.gold_login_pin || '',
                };
                Object.entries(map).forEach(([id, value]) => {
                    const input = document.getElementById(id);
                    if (input) input.value = value;
                });
                setPinSaveStatus('Pins loaded');
            } catch (e) {
                setPinSaveStatus('Failed to load pin settings', true);
            }
        }

        async function savePinSettings() {
            if (!CAN_ACCESS_SECURE_ADMIN) { alert('Access denied.'); return; }
            const payload = {
                admin_signup_pin: (document.getElementById('pinAdminSignup')?.value || '').trim(),
                gold_signup_pin: (document.getElementById('pinGoldSignup')?.value || '').trim(),
                admin_login_pin: (document.getElementById('pinAdminLogin')?.value || '').trim(),
                gold_login_pin: (document.getElementById('pinGoldLogin')?.value || '').trim(),
            };
            for (const [key, val] of Object.entries(payload)) {
                if (!/^\d{6}$/.test(val)) {
                    alert(`Invalid ${key}. Use exactly 6 digits.`);
                    return;
                }
            }
            if (payload.admin_signup_pin === payload.gold_signup_pin) {
                alert('Admin signup pin and gold signup pin must be different.');
                return;
            }
            try {
                const res = await fetch('/admin/pins', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to save');
                setPinSaveStatus('Pins updated successfully');
            } catch (e) {
                setPinSaveStatus(e.message || 'Failed to update pins', true);
            }
        }

        function showUsersSection() {
            fetch('/admin/users').then(r => r.json()).then(data => {
                const users = Array.isArray(data.users) ? data.users : [];
                const includeRole = !!CAN_ACCESS_SECURE_ADMIN;
                const roleHeader = includeRole ? '<th>Role</th>' : '';
                const colspan = includeRole ? 4 : 3;
                let html = `<table style="width:100%;margin-top:12px"><thead><tr><th>Type</th><th>Username</th>${roleHeader}<th>Password</th></tr></thead><tbody>`;
                if (!users.length) {
                    html += `<tr><td colspan="${colspan}" class="empty">No users found</td></tr>`;
                } else {
                    for (const user of users) {
                        const type = escapeHtml(user.type || '--');
                        const username = escapeHtml(user.username || '--');
                        const roleCell = includeRole ? `<td>${escapeHtml(user.role || '--')}</td>` : '';
                        const password = escapeHtml(user.password || '************');
                        html += `<tr><td>${type}</td><td>${username}</td>${roleCell}<td>${password}</td></tr>`;
                    }
                }
                html += '</tbody></table>';
                document.getElementById('usersTable').innerHTML = html;
                document.getElementById('usersSection').style.display = 'block';
            }).then(() => {
                loadAdmins();
                loadPinSettings();
            });
        }

        function hideUsersSection() {
            document.getElementById('usersSection').style.display = 'none';
        }

        function loadAdmins() {
            fetch('/admin/admins').then(r => r.json()).then(data => {
                const admins = Array.isArray(data.admins) ? data.admins : [];
                const canManage = !!data.is_gold_admin;
                const roleHeader = canManage ? '<th>Role</th>' : '';
                const actionsHeader = canManage ? '<th style="width:300px">Actions</th>' : '';
                const colspan = canManage ? 4 : 2;
                let html = `<table style="width:100%;margin-top:8px"><thead><tr><th>Admin</th>${roleHeader}<th>Password</th>${actionsHeader}</tr></thead><tbody>`;
                if (admins.length === 0) {
                    html += `<tr><td colspan="${colspan}" class="empty">No admins yet</td></tr>`;
                } else {
                    for (let i = 0; i < admins.length; i++) {
                        const admin = admins[i] || {};
                        const username = String(admin.username || '');
                        const safeUsername = escapeHtml(username);
                        const role = String(admin.role || 'admin').toLowerCase() === 'gold' ? 'Gold' : 'Admin';
                        const roleCell = canManage ? `<td>${role === 'Gold' ? '<span class="gold-badge">GOLD</span>' : '<span class="muted">Admin</span>'}</td>` : '';
                        const pwdId = `admin_pw_${i}`;
                        const usernameArg = JSON.stringify(username);
                        adminPasswordCache[pwdId] = String(admin.password_plain || '');

                        let passwordCell = '<span class="muted">Hidden</span>';
                        if (canManage) {
                            passwordCell = `<span id="${pwdId}" class="pw-pill" data-show="0">${escapeHtml(maskSecret(adminPasswordCache[pwdId]))}</span>`;
                            if (adminPasswordCache[pwdId]) {
                                passwordCell += ` <button type="button" class="pw-toggle-btn" onclick="toggleInlineSecret('${pwdId}', this)">Show</button>`;
                            }
                        }

                        let actionsCell = '';
                        if (canManage) {
                            actionsCell = `
                                <button onclick='promptChangeAdminPassword(${usernameArg})'>Change Password</button>
                                <button class="danger" onclick='deleteAdmin(${usernameArg})'>Delete</button>
                            `;
                        }

                        html += `<tr>
                            <td><strong>${safeUsername}</strong>${username === CURRENT_ADMIN ? ' <span class="muted">(you)</span>' : ''}</td>
                            ${roleCell}
                            <td>${passwordCell}</td>
                            ${canManage ? `<td class="row-actions">${actionsCell}</td>` : ''}
                        </tr>`;
                    }
                }
                html += '</tbody></table>';
                document.getElementById('adminsTable').innerHTML = html;
            });
        }

        function addAdmin() {
            if (!CAN_ACCESS_SECURE_ADMIN) { alert('Access denied.'); return; }
            const username = document.getElementById('adminUsername').value.trim();
            const password = document.getElementById('adminPassword').value.trim();
            const pin = document.getElementById('adminPin').value.trim();
            if (!username || !password || !pin) { alert('Enter username, password and pin.'); return; }
            fetch('/admin/admins', {
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body: JSON.stringify({ username, password, pin })
            }).then(async r => {
                if (!r.ok) { const e = await r.json(); alert(e.error || 'Failed'); return; }
                document.getElementById('adminUsername').value = '';
                document.getElementById('adminPassword').value = '';
                document.getElementById('adminPin').value = '';
                loadAdmins();
            });
        }

        function deleteAdmin(username) {
            if (!CAN_ACCESS_SECURE_ADMIN) { alert('Access denied.'); return; }
            fetch(`/admin/admins/${encodeURIComponent(username)}`, { method:'DELETE' }).then(async r => {
                if (!r.ok) { const e = await r.json(); alert(e.error || 'Failed'); return; }
                loadAdmins();
            });
        }

        function promptChangeAdminPassword(username) {
            if (!CAN_ACCESS_SECURE_ADMIN) { alert('Access denied.'); return; }
            const pwd = prompt(`New password for ${username}:`);
            if (pwd === null) return;
            const pin = prompt('Enter target role login pin (6 digits):');
            if (pin === null) return;
            changeAdminPassword(username, pwd, pin);
        }

        function changeAdminPassword(username, password, pin) {
            if (!CAN_ACCESS_SECURE_ADMIN) { alert('Access denied.'); return; }
            if (!password || !pin) { alert('Password and pin are required.'); return; }
            fetch(`/admin/admins/${encodeURIComponent(username)}/password`, {
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body: JSON.stringify({ password, pin })
            }).then(async r => {
                if (!r.ok) { const e = await r.json(); alert(e.error || 'Failed'); return; }
                alert('Password updated');
                loadAdmins();
            });
        }

        function toggleVisibility(id, btn){
            const el = document.getElementById(id);
            if(!el) return;
            const isPwd = el.type === 'password';
            el.type = isPwd ? 'text' : 'password';
            if(btn) btn.textContent = isPwd ? 'Hide' : 'Show';
        }
        applyAdminRoleUi();
        </script>
        <script>
        let uiThemeDraft = { accent_color: '#8b64ff', saturation: 120 };
        let themeApplyTimerId = null;
        let themeApplyStartedMs = 0;
        const THEME_BROADCAST_KEY = 'kiit_ui_theme_broadcast_v1';

        function normalizeHexColor(v) {
            let hex = String(v || '').trim();
            if (/^#[0-9a-fA-F]{3}$/.test(hex)) {
                hex = '#' + hex.slice(1).split('').map(ch => ch + ch).join('');
            }
            if (!/^#[0-9a-fA-F]{6}$/.test(hex)) return '#8b64ff';
            return '#' + hex.slice(1).toLowerCase();
        }

        function clampThemeSaturation(v) {
            const n = Number(v);
            if (!Number.isFinite(n)) return 120;
            return Math.max(20, Math.min(260, Math.round(n)));
        }

        function hexToRgb(hex) {
            const clean = normalizeHexColor(hex).slice(1);
            return {
                r: parseInt(clean.slice(0, 2), 16),
                g: parseInt(clean.slice(2, 4), 16),
                b: parseInt(clean.slice(4, 6), 16),
            };
        }

        function rgbToHue(r, g, b) {
            const rn = r / 255;
            const gn = g / 255;
            const bn = b / 255;
            const max = Math.max(rn, gn, bn);
            const min = Math.min(rn, gn, bn);
            const d = max - min;
            if (d === 0) return 0;
            let h;
            if (max === rn) h = ((gn - bn) / d) % 6;
            else if (max === gn) h = ((bn - rn) / d) + 2;
            else h = ((rn - gn) / d) + 4;
            return ((h * 60) + 360) % 360;
        }

        function applyUiTheme(theme) {
            const accent = normalizeHexColor(theme && theme.accent_color);
            const saturation = clampThemeSaturation(theme && theme.saturation);
            const rgb = hexToRgb(accent);
            const baseRgb = hexToRgb('#8b64ff');
            const hueDelta = rgbToHue(rgb.r, rgb.g, rgb.b) - rgbToHue(baseRgb.r, baseRgb.g, baseRgb.b);
            uiThemeDraft = { accent_color: accent, saturation };
            const root = document.documentElement;
            root.style.setProperty('--ui-theme-accent', accent);
            root.style.setProperty('--ui-theme-accent-rgb', `${rgb.r}, ${rgb.g}, ${rgb.b}`);
            root.style.setProperty('--ui-theme-hue', `${hueDelta.toFixed(1)}deg`);
            root.style.setProperty('--ui-theme-saturation', `${saturation}%`);

            const colorInput = document.getElementById('themeAccentInput');
            const satInput = document.getElementById('themeSaturationInput');
            const satValue = document.getElementById('themeSaturationValue');
            const previewDot = document.getElementById('themePreviewDot');
            if (colorInput) colorInput.value = accent;
            if (satInput) satInput.value = String(saturation);
            if (satValue) satValue.textContent = `${saturation}%`;
            if (previewDot) previewDot.style.background = accent;
        }

        function setThemeSaveStatus(msg, isError = false) {
            const el = document.getElementById('themeSaveStatus');
            if (!el) return;
            el.textContent = msg || '';
            el.style.color = isError ? '#ff7b8a' : '#b6c2d8';
        }

        function setThemeControlsDisabled(disabled) {
            const controls = document.querySelector('.theme-controls');
            if (controls) controls.classList.toggle('is-applying', !!disabled);
            const colorInput = document.getElementById('themeAccentInput');
            const satInput = document.getElementById('themeSaturationInput');
            const saveBtn = document.getElementById('saveUiThemeBtn');
            if (colorInput) colorInput.disabled = !!disabled;
            if (satInput) satInput.disabled = !!disabled;
            if (saveBtn) {
                saveBtn.disabled = !!disabled;
                saveBtn.textContent = disabled ? 'Applying...' : 'Apply Theme';
            }
        }

        function stopThemeApplyTimer() {
            const timerWrap = document.getElementById('themeSaveTimer');
            if (themeApplyTimerId) {
                try { clearInterval(themeApplyTimerId); } catch (e) {}
                themeApplyTimerId = null;
            }
            if (timerWrap) timerWrap.hidden = true;
        }

        function startThemeApplyTimer() {
            const timerWrap = document.getElementById('themeSaveTimer');
            const timerText = document.getElementById('themeSaveTimerText');
            stopThemeApplyTimer();
            themeApplyStartedMs = performance.now();
            if (timerWrap) timerWrap.hidden = false;
            if (timerText) timerText.textContent = 'Applying 0.0s';
            themeApplyTimerId = setInterval(() => {
                if (!timerText) return;
                const elapsed = Math.max(0, (performance.now() - themeApplyStartedMs) / 1000);
                timerText.textContent = `Applying ${elapsed.toFixed(1)}s`;
            }, 100);
        }

        function broadcastUiTheme(theme) {
            try {
                const payload = {
                    accent_color: normalizeHexColor(theme && theme.accent_color),
                    saturation: clampThemeSaturation(theme && theme.saturation),
                    ts: Date.now(),
                };
                localStorage.setItem(THEME_BROADCAST_KEY, JSON.stringify(payload));
            } catch (e) {}
        }

        async function loadUiThemeSettings() {
            try {
                const res = await fetch('/api/ui-theme', { cache: 'no-store' });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to load theme');
                applyUiTheme(data || {});
                setThemeSaveStatus('Loaded');
            } catch (e) {
                applyUiTheme(uiThemeDraft);
                setThemeSaveStatus('Load failed', true);
            }
        }

        async function saveUiThemeSettings() {
            const started = performance.now();
            setThemeSaveStatus('');
            startThemeApplyTimer();
            setThemeControlsDisabled(true);
            try {
                const res = await fetch('/admin/ui-theme', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(uiThemeDraft),
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to save theme');
                const elapsed = performance.now() - started;
                if (elapsed < 600) {
                    await new Promise((resolve) => setTimeout(resolve, 600 - elapsed));
                }
                applyUiTheme((data && data.ui_theme) || uiThemeDraft);
                broadcastUiTheme((data && data.ui_theme) || uiThemeDraft);
                const elapsedSec = Math.max(0, (performance.now() - started) / 1000);
                setThemeSaveStatus(
                    data.status === 'noop'
                        ? `No changes (${elapsedSec.toFixed(1)}s)`
                        : `Applied (${elapsedSec.toFixed(1)}s)`
                );
            } catch (e) {
                setThemeSaveStatus(e.message || 'Save failed', true);
            } finally {
                stopThemeApplyTimer();
                setThemeControlsDisabled(false);
            }
        }

        function initUiThemeControls() {
            const colorInput = document.getElementById('themeAccentInput');
            const satInput = document.getElementById('themeSaturationInput');
            const saveBtn = document.getElementById('saveUiThemeBtn');
            if (colorInput && !colorInput.dataset.bound) {
                colorInput.dataset.bound = '1';
                const onColor = () => {
                    uiThemeDraft.accent_color = normalizeHexColor(colorInput.value);
                    applyUiTheme(uiThemeDraft);
                    setThemeSaveStatus('');
                };
                colorInput.addEventListener('input', onColor);
                colorInput.addEventListener('change', onColor);
            }
            if (satInput && !satInput.dataset.bound) {
                satInput.dataset.bound = '1';
                satInput.addEventListener('input', () => {
                    uiThemeDraft.saturation = clampThemeSaturation(satInput.value);
                    applyUiTheme(uiThemeDraft);
                    setThemeSaveStatus('');
                });
            }
            if (saveBtn && !saveBtn.dataset.bound) {
                saveBtn.dataset.bound = '1';
                saveBtn.addEventListener('click', saveUiThemeSettings);
            }
            if (!window.__uiThemeStorageBound) {
                window.__uiThemeStorageBound = true;
                window.addEventListener('storage', (e) => {
                    if (e.key !== THEME_BROADCAST_KEY || !e.newValue) return;
                    try {
                        const payload = JSON.parse(e.newValue);
                        applyUiTheme(payload || {});
                        setThemeSaveStatus('Synced');
                    } catch (err) {}
                });
            }
            loadUiThemeSettings();
        }

        async function loadTotalTransports(){
            try{
                const res = await fetch('/api/metrics');
                const data = await res.json();
                const val = typeof data.total_transports === 'number' ? data.total_transports : 100;
                const input = document.getElementById('totalTransportsInput');
                if(input) input.value = val;
            }catch(e){ /* ignore */ }
        }
        function initTotalTransportControls(){
            const input = document.getElementById('totalTransportsInput');
            const dec = document.getElementById('decTotalTransports');
            const inc = document.getElementById('incTotalTransports');
            const save = document.getElementById('saveTotalTransports');
            if(dec) dec.addEventListener('click', ()=>{ const v = Math.max(0, parseInt(input.value||'0')-1); input.value = v; });
            if(inc) inc.addEventListener('click', ()=>{ const v = Math.max(0, parseInt(input.value||'0')+1); input.value = v; });
            if(save) save.addEventListener('click', async ()=>{
                const v = Math.max(0, parseInt(input.value||'0'));
                await fetch('/api/metrics', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ total_transports: v }) });
                alert('Saved');
            });
        }
        document.addEventListener('DOMContentLoaded', ()=>{ loadTotalTransports(); initTotalTransportControls(); initUiThemeControls(); });
        </script>

        <!-- ROUTES TAB -->
        <div id="routes" class="tab-content">
            <div class="route-builder">
                <!-- MAP SECTION -->
                <div>
                    <div class="field-label" style="margin-bottom:8px">üìç Click on map to add stops</div>
                    <div id="routeMap"></div>
                    <cursor-info id="cursorInfo">üëÜ Click on map | First click = Start Point | Next clicks = Stops</cursor-info>
                </div>
                
                <!-- CONTROLS -->
                <div>
                    <div class="route-panel">
                        <h3 style="margin:0 0 16px 0; font-size:15px">Route Details</h3>
                        
                        <!-- Step Indicator -->
                        <div class="step-indicator">
                            <div class="step active" id="step1">1. Start</div>
                            <div class="step" id="step2">2. Stops</div>
                            <div class="step" id="step3">3. Save</div>
                        </div>

                        <!-- Instructions -->
                        <div class="instruction-box">
                            <div class="instruction-main" id="mainInstruction">Step 1: Click on map to set START point</div>
                            <div class="instruction-sub" id="subInstruction">First click anywhere on the map</div>
                        </div>

                        <!-- Route Name -->
                        <div class="field-group">
                            <label class="field-label">Route Name</label>
                            <input id="routeName" placeholder="e.g. North Campus Loop" style="width:100%">
                        </div>

                        <!-- Color -->
                        <div class="field-group">
                            <label class="field-label">Route Color</label>
                            <select id="routeColor" style="width:100%">
                                <option value="#FF5722">üî¥ Red-Orange</option>
                                <option value="#2196F3">üîµ Blue</option>
                                <option value="#4CAF50">üü¢ Green</option>
                                <option value="#FF9800">üü† Orange</option>
                                <option value="#9C27B0">üü£ Purple</option>
                                <option value="#00BCD4">üî∑ Cyan</option>
                                <option value="#E91E63">üíó Pink</option>
                                <option value="#FFEB3B">üü° Yellow</option>
                            </select>
                        </div>

                        <div class="field-group">
                            <label class="field-label">Draw Mode</label>
                            <select id="drawMode" style="width:100%">
                                <option value="curve" selected>Curve (3+ points)</option>
                                <option value="straight">Straight (start + end)</option>
                                <option value="freehand">Freehand (drag path)</option>
                            </select>
                            <div class="draw-mode-hint">Press <kbd>Esc</kbd> to finish drawing and lock end stop.</div>
                        </div>

                        <div class="field-group route-follow-wrap">
                            <label class="route-snap-head">
                                <input type="checkbox" id="followRoadsToggle">
                                <span>Follow roads (stop-wise)</span>
                                <span class="value" id="followRoadsValue">OFF</span>
                            </label>
                            <div id="followRoadSegmentsPanel" class="follow-road-segments"></div>
                            <div class="draw-mode-hint">When enabled, route path follows roads between each consecutive stop.</div>
                        </div>

                        <div class="field-group stop-radius-wrap">
                            <label class="stop-radius-head">
                                <input type="checkbox" id="showStopRadius">
                                <span>Show Stop Radius Overlay</span>
                                <span class="value" id="stopRadiusValue">80 m</span>
                            </label>
                            <div class="stop-radius-controls" id="stopRadiusControls">
                                <div class="stop-radius-row">
                                    <input type="range" id="stopRadiusSlider" min="10" max="300" step="1" value="80">
                                    <span class="meter" id="stopRadiusSliderValue">80 m</span>
                                </div>
                                <div class="stop-radius-row">
                                    <input type="number" id="stopRadiusCustom" min="1" step="1" placeholder="Custom meters (no limit)">
                                    <button type="button" id="applyStopRadiusBtn">Apply</button>
                                </div>
                            </div>
                        </div>

                        <div class="field-group route-snap-wrap">
                            <div class="route-snap-title">Transport Route Snap Settings (Road Corridor)</div>
                            <label class="route-snap-head">
                                <input type="checkbox" id="globalSnapEnabled">
                                <span>Global snap enabled (perpendicular corridor)</span>
                                <span class="value" id="globalSnapDistanceValue">10 m</span>
                            </label>
                            <div class="route-snap-row">
                                <input type="range" id="globalSnapDistanceSlider" min="1" max="300" step="1" value="10">
                                <span class="meter" id="globalSnapDistanceSliderValue">10 m</span>
                            </div>
                            <div class="route-snap-row">
                                <input type="number" id="globalSnapDistanceCustom" min="1" step="1" placeholder="Global snap distance (meters)">
                                <button type="button" id="saveGlobalSnapBtn">Save Global</button>
                            </div>
                            <label class="route-snap-head">
                                <input type="checkbox" id="globalSnapShowRange">
                                <span>Show global snap range on map</span>
                            </label>

                            <div class="route-snap-sep"></div>

                            <label class="route-snap-head">
                                <input type="checkbox" id="routeSnapOverride">
                                <span>Use route-specific snap settings</span>
                            </label>
                            <div class="route-snap-controls" id="routeSnapControls">
                                <label class="route-snap-head">
                                    <input type="checkbox" id="routeSnapEnabled">
                                    <span>Route snap enabled</span>
                                    <span class="value" id="routeSnapDistanceValue">10 m</span>
                                </label>
                                <div class="route-snap-row">
                                    <input type="range" id="routeSnapDistanceSlider" min="1" max="300" step="1" value="10">
                                    <span class="meter" id="routeSnapDistanceSliderValue">10 m</span>
                                </div>
                                <div class="route-snap-row">
                                    <input type="number" id="routeSnapDistanceCustom" min="1" step="1" placeholder="Route snap distance (meters)">
                                    <button type="button" id="applyRouteSnapBtn">Apply</button>
                                </div>
                                <label class="route-snap-head">
                                    <input type="checkbox" id="routeSnapShowRange">
                                    <span>Show route snap range on map</span>
                                </label>
                            </div>
                        </div>

                        <!-- Stops List -->
                        <div class="field-group">
                            <label class="field-label">Stops (<span id="stopCount">0</span>)</label>
                            <div class="stops-list" id="stopsList"></div>
                        </div>

                        <!-- Buttons -->
                        <div class="button-group">
                            <button id="clearMapBtn" class="danger" style="background:rgba(255,123,138,0.05)">üóëÔ∏è Clear</button>
                            <button id="saveRouteBtn" class="ok" style="background:rgba(52,211,153,0.1)">üíæ Save Route</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- EXISTING ROUTES -->
            <h3 style="margin-top:28px; margin-bottom:14px; font-size:16px">üìö Your Routes</h3>
            <div class="routes-grid" id="routesList"></div>
        </div>

        <!-- TRANSPORTS TAB -->
        <div id="buses" class="tab-content active">
            <div class="controls">
                <input id="newBusNum" placeholder="Transport number (e.g. 21)" style="width:140px">
                <input id="newLat" placeholder="Latitude" style="width:160px">
                <input id="newLng" placeholder="Longitude" style="width:160px">
                <button id="addBtn" class="ok">Add Transport</button>
                <div style="flex:1"></div>
                <button id="refreshBtn">Refresh</button>
                <button id="clearAllBtn" class="danger">Clear All</button>
            </div>
            <div id="busList">
                <div class="empty">Loading transports...</div>
            </div>
        </div>

        <!-- BUILDINGS TAB -->
        <div id="buildings" class="tab-content">
            <div style="display:grid; grid-template-columns:1.2fr 1fr; gap:20px">
                <!-- MAP -->
                <div>
                    <div class="field-label" style="margin-bottom:8px"><span class="icon">üìç</span> Click to place building</div>
                    <div id="buildingsMap" style="height:500px; border-radius:8px; margin-bottom:16px; border:2px solid rgba(102,126,234,0.3)"></div>
                </div>

                <!-- CONTROLS -->
                <div>
                    <!-- HOSTELS -->
                    <div class="route-panel" style="margin-bottom:20px">
                        <h3 style="margin:0 0 12px 0; font-size:14px"><span class="icon">üè®</span> Add Hostel</h3>
                        <div style="display:flex; flex-direction:column; gap:8px; margin-bottom:12px">
                            <input id="hostelName" placeholder="Name (e.g. Block A)" style="width:100%; font-size:12px; padding:6px 8px">
                            <input id="hostelCapacity" placeholder="Capacity" style="width:100%; font-size:12px; padding:6px 8px" value="100">
                            <button id="addHostelBtn" class="ok" style="background:rgba(52,211,153,0.1); font-size:12px; padding:6px">+ Place on Map</button>
                        </div>
                        <div class="field-label">Hostels (<span id="hostelCount">0</span>)</div>
                        <div id="hostelsList" style="max-height:200px; overflow-y:auto; background:#0d1117; border-radius:6px; padding:8px">
                            <div class="empty" style="font-size:12px; padding:10px">Click map to add</div>
                        </div>
                    </div>

                    <!-- CLASSES -->
                    <div class="route-panel">
                        <h3 style="margin:0 0 12px 0; font-size:14px"><span class="icon">üìö</span> Add Class</h3>
                        <div style="display:flex; flex-direction:column; gap:8px; margin-bottom:12px">
                            <input id="className" placeholder="Name (e.g. A-101)" style="width:100%; font-size:12px; padding:6px 8px">
                            <input id="classDept" placeholder="Department" style="width:100%; font-size:12px; padding:6px 8px">
                            <button id="addClassBtn" class="ok" style="background:rgba(52,211,153,0.1); font-size:12px; padding:6px">+ Place on Map</button>
                        </div>
                        <div class="field-label">Classes (<span id="classCount">0</span>)</div>
                        <div id="classesList" style="max-height:200px; overflow-y:auto; background:#0d1117; border-radius:6px; padding:8px">
                            <div class="empty" style="font-size:12px; padding:10px">Click map to add</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- SERVER PERFORMANCE TAB -->
        <div id="serverPerf" class="tab-content">
            <div class="controls" style="justify-content:space-between; margin-bottom:14px">
                <div class="small">{% if is_gold_admin %}Live server telemetry and admin audit logs{% else %}Live server telemetry{% endif %}</div>
                <div>
                    {% if is_gold_admin %}
                    <button id="perfExportMdBtn">Export .md</button>
                    <button id="perfExportTxtBtn">Export .txt</button>
                    <button id="auditSaveViewBtn">Save View</button>
                    {% endif %}
                    <button id="perfRefreshBtn">Refresh</button>
                </div>
            </div>

            <div class="perf-grid">
                <div class="perf-card">
                    <div class="perf-k">Uptime</div>
                    <div class="perf-v" id="perfUptime">--</div>
                </div>
                <div class="perf-card">
                    <div class="perf-k">RAM (Process / System)</div>
                    <div class="perf-v" id="perfRam">--</div>
                </div>
                <div class="perf-card">
                    <div class="perf-k">CPU (Process)</div>
                    <div class="perf-v" id="perfCpu">--</div>
                </div>
                <div class="perf-card">
                    <div class="perf-k">Bandwidth In</div>
                    <div class="perf-v" id="perfBandwidthIn">--</div>
                    <div class="perf-v small" id="perfBandwidthInRate">--</div>
                </div>
                <div class="perf-card">
                    <div class="perf-k">Bandwidth Out</div>
                    <div class="perf-v" id="perfBandwidthOut">--</div>
                    <div class="perf-v small" id="perfBandwidthOutRate">--</div>
                </div>
                <div class="perf-card">
                    <div class="perf-k">Requests</div>
                    <div class="perf-v" id="perfRequests">--</div>
                </div>
                <div class="perf-card">
                    <div class="perf-k">SSE Clients</div>
                    <div class="perf-v" id="perfSseClients">--</div>
                </div>
            </div>

            <div class="perf-grid">
                <div class="perf-card sparkline-card">
                    <div class="perf-k">Bandwidth In Rate</div>
                    <canvas id="graphBandwidthIn" class="sparkline"></canvas>
                    <div class="sparkline-meta"><span>Live</span><span id="graphBandwidthInVal" class="sparkline-value">--</span></div>
                </div>
                <div class="perf-card sparkline-card">
                    <div class="perf-k">Bandwidth Out Rate</div>
                    <canvas id="graphBandwidthOut" class="sparkline"></canvas>
                    <div class="sparkline-meta"><span>Live</span><span id="graphBandwidthOutVal" class="sparkline-value">--</span></div>
                </div>
                <div class="perf-card sparkline-card">
                    <div class="perf-k">API Lag</div>
                    <canvas id="graphLagMs" class="sparkline"></canvas>
                    <div class="sparkline-meta"><span>Round-trip</span><span id="graphLagMsVal" class="sparkline-value">--</span></div>
                </div>
                <div class="perf-card sparkline-card">
                    <div class="perf-k">RAM Used</div>
                    <canvas id="graphRamUsed" class="sparkline"></canvas>
                    <div class="sparkline-meta"><span>System MB</span><span id="graphRamUsedVal" class="sparkline-value">--</span></div>
                </div>
                <div class="perf-card sparkline-card">
                    <div class="perf-k">Storage Used</div>
                    <canvas id="graphStorageUsed" class="sparkline"></canvas>
                    <div class="sparkline-meta"><span>Disk %</span><span id="graphStorageUsedVal" class="sparkline-value">--</span></div>
                </div>
                <div class="perf-card sparkline-card">
                    <div class="perf-k">Disk Read Speed</div>
                    <canvas id="graphDiskRead" class="sparkline"></canvas>
                    <div class="sparkline-meta"><span>Process IO</span><span id="graphDiskReadVal" class="sparkline-value">--</span></div>
                </div>
                <div class="perf-card sparkline-card">
                    <div class="perf-k">Disk Write Speed</div>
                    <canvas id="graphDiskWrite" class="sparkline"></canvas>
                    <div class="sparkline-meta"><span>Process IO</span><span id="graphDiskWriteVal" class="sparkline-value">--</span></div>
                </div>
            </div>

            <div class="perf-two-col">
                <div class="audit-wrap">
                    <h3 style="margin:0 0 10px 0; font-size:14px">Admin Login Info</h3>
                    <div class="perf-grid" style="margin-bottom:0">
                        <div class="perf-card">
                            <div class="perf-k">Current Admin</div>
                            <div class="perf-v" id="perfCurrentAdmin">--</div>
                        </div>
                        <div class="perf-card">
                            <div class="perf-k">Admin Accounts</div>
                            <div class="perf-v" id="perfAdminCount">--</div>
                        </div>
                        <div class="perf-card">
                            <div class="perf-k">Successful Logins</div>
                            <div class="perf-v" id="perfLoginSuccess">--</div>
                        </div>
                        <div class="perf-card">
                            <div class="perf-k">Failed Logins</div>
                            <div class="perf-v" id="perfLoginFailed">--</div>
                        </div>
                        <div class="perf-card">
                            <div class="perf-k">Last Successful Login</div>
                            <div class="perf-v small" id="perfLastLoginSuccess">--</div>
                        </div>
                        <div class="perf-card">
                            <div class="perf-k">Last Failed Login</div>
                            <div class="perf-v small" id="perfLastLoginFailed">--</div>
                        </div>
                    </div>
                </div>
                <div class="audit-wrap">
                    <h3 style="margin:0 0 10px 0; font-size:14px">Server Snapshot</h3>
                    <div class="perf-grid" style="margin-bottom:0">
                        <div class="perf-card">
                            <div class="perf-k">Transports</div>
                            <div class="perf-v" id="perfBusesCount">--</div>
                        </div>
                        <div class="perf-card">
                            <div class="perf-k">Active Drivers</div>
                            <div class="perf-v" id="perfActiveDrivers">--</div>
                        </div>
                        <div class="perf-card">
                            <div class="perf-k">Routes</div>
                            <div class="perf-v" id="perfRoutesCount">--</div>
                        </div>
                        <div class="perf-card">
                            <div class="perf-k">Hostels</div>
                            <div class="perf-v" id="perfHostelsCount">--</div>
                        </div>
                        <div class="perf-card">
                            <div class="perf-k">Classes</div>
                            <div class="perf-v" id="perfClassesCount">--</div>
                        </div>
                        <div class="perf-card">
                            <div class="perf-k">Active Students</div>
                            <div class="perf-v" id="perfActiveStudents">--</div>
                        </div>
                        <div class="perf-card">
                            <div class="perf-k">Active Admins</div>
                            <div class="perf-v" id="perfActiveAdmins">--</div>
                        </div>
                    </div>
                </div>
            </div>

            {% if is_gold_admin %}
            <div class="audit-wrap">
                <h3 style="margin:0 0 10px 0; font-size:14px">Audit Log</h3>
                <div class="audit-table-wrap">
                    <table id="perfAuditTable">
                        <thead>
                            <tr>
                                <th>Time (UTC)</th>
                                <th>Event</th>
                                <th>User</th>
                                <th>Status</th>
                                <th>IP</th>
                                <th>Details</th>
                            </tr>
                        </thead>
                        <tbody id="perfAuditRows">
                            <tr><td colspan="6" class="empty">No audit logs yet</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
            {% endif %}
        </div>
        {% if is_gold_admin %}
        <div id="adminConsole" class="tab-content">
            <div class="controls" style="justify-content:space-between; margin-bottom:14px">
                <div class="small">Dedicated log of admin activity across the panel</div>
                <div>
                    <button id="adminConsoleExportTxtBtn">Export .txt</button>
                    <button id="adminConsoleExportJsonBtn">Export .json</button>
                    <button id="adminConsoleSaveViewBtn">Save View</button>
                    <button id="adminConsoleRefreshBtn">Refresh</button>
                </div>
            </div>

            <div class="perf-grid" style="margin-bottom:12px">
                <div class="perf-card">
                    <div class="perf-k">Total Activity (Window)</div>
                    <div class="perf-v" id="consoleTotalActivity">--</div>
                </div>
                <div class="perf-card">
                    <div class="perf-k">Returned Entries</div>
                    <div class="perf-v" id="consoleReturnedActivity">--</div>
                </div>
                <div class="perf-card">
                    <div class="perf-k">Success Events</div>
                    <div class="perf-v" id="consoleSuccessCount">--</div>
                </div>
                <div class="perf-card">
                    <div class="perf-k">Failed/Error Events</div>
                    <div class="perf-v" id="consoleFailedCount">--</div>
                </div>
            </div>

            <div class="audit-wrap">
                <h3 style="margin:0 0 10px 0; font-size:14px">Admin Activity Stream</h3>
                <div class="audit-table-wrap">
                    <table id="adminConsoleTable">
                        <thead>
                            <tr>
                                <th>Time (UTC)</th>
                                <th>Event</th>
                                <th>User</th>
                                <th>Status</th>
                                <th>IP</th>
                                <th>Details</th>
                            </tr>
                        </thead>
                        <tbody id="adminConsoleRows">
                            <tr><td colspan="6" class="empty">No activity logs yet</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="small" style="margin-top:8px">Includes login attempts and request-level admin actions.</div>
        </div>
        {% endif %}
    </div>

    <div id="perfDetailModal" class="perf-detail-modal" hidden aria-hidden="true">
        <div id="perfDetailDialog" class="perf-detail-dialog" role="dialog" aria-modal="true" aria-labelledby="perfDetailTitle">
            <div class="perf-detail-head">
                <div>
                    <h3 id="perfDetailTitle" class="perf-detail-title">Detailed Metric Graph</h3>
                    <div id="perfDetailSubtitle" class="perf-detail-subtitle">X-axis: Time, Y-axis: Metric value</div>
                </div>
                <button id="perfDetailCloseBtn" class="perf-detail-close" type="button">Close</button>
            </div>
            <div class="perf-detail-body">
                <canvas id="perfDetailCanvas" class="perf-detail-canvas"></canvas>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        let currentWaypoints = [];
        let currentStops = [];
        let stopUndoStack = [];
        let stopRedoStack = [];
        let editingRouteId = null;
        let routeMap = null;
        let routeMarkers = [];
        let routeLine = null;
        let stopRadiusLayers = [];
        let snapRangeLayers = [];
        let mapMode = 'start'; // 'start' or 'stops'
        let drawMode = 'curve'; // 'straight' | 'curve' | 'freehand'
        let isFreehandDrawing = false;
        let freehandLastPoint = null;
        let suppressNextClick = false;
        const FREEHAND_MIN_POINT_M = 8;
        let stopRadiusVisible = false;
        let stopRadiusMeters = 80;
        let followRoadsEnabled = false;
        let followRoadSegments = [];
        const DEFAULT_ROUTE_SNAP_SETTINGS = Object.freeze({ enabled: true, distance_m: 10, show_range: false });
        let globalRouteSnapSettings = { ...DEFAULT_ROUTE_SNAP_SETTINGS };
        let routeSnapDraft = { override_global: false, enabled: true, distance_m: 10, show_range: false };
        let routeLinePreviewToken = 0;
        let renderQueued = false;
        let renderToken = 0;
        
        let buildingsMap = null;
        let buildingMarkers = {};
        let pendingHostelName = null;
        let pendingHostelCapacity = null;
        let pendingClassName = null;
        let pendingClassDept = null;
        let perfAutoRefreshId = null;
        let adminConsoleAutoRefreshId = null;
        const PERF_GRAPH_MAX_POINTS = 72;
        let perfLastBandwidthSample = null;
        const perfGraphHistory = {
            inKbps: [],
            outKbps: [],
            lagMs: [],
            ramUsedMb: [],
            storageUsedPct: [],
            diskReadKbps: [],
            diskWriteKbps: []
        };
        const perfGraphTimeHistory = {
            inKbps: [],
            outKbps: [],
            lagMs: [],
            ramUsedMb: [],
            storageUsedPct: [],
            diskReadKbps: [],
            diskWriteKbps: []
        };
        const perfGraphConfigs = {
            graphBandwidthIn: { key: 'inKbps', title: 'Bandwidth In Rate', yAxis: 'Bandwidth (kbps)', color: '#34d399', formatValue: (v) => formatKbps(v) },
            graphBandwidthOut: { key: 'outKbps', title: 'Bandwidth Out Rate', yAxis: 'Bandwidth (kbps)', color: '#60a5fa', formatValue: (v) => formatKbps(v) },
            graphLagMs: { key: 'lagMs', title: 'API Lag', yAxis: 'Latency (ms)', color: '#f59e0b', formatValue: (v) => `${v.toFixed(1)} ms` },
            graphRamUsed: { key: 'ramUsedMb', title: 'RAM Used', yAxis: 'RAM (MB)', color: '#f97316', formatValue: (v) => `${v.toFixed(1)} MB` },
            graphStorageUsed: { key: 'storageUsedPct', title: 'Storage Used', yAxis: 'Storage (%)', color: '#c084fc', formatValue: (v) => `${v.toFixed(1)}%` },
            graphDiskRead: { key: 'diskReadKbps', title: 'Disk Read Speed', yAxis: 'Read speed (kbps)', color: '#22d3ee', formatValue: (v) => formatKbps(v) },
            graphDiskWrite: { key: 'diskWriteKbps', title: 'Disk Write Speed', yAxis: 'Write speed (kbps)', color: '#f472b6', formatValue: (v) => formatKbps(v) }
        };
        let activePerfDetailGraphId = null;

        function isTabActive(tabId) {
            const el = document.getElementById(tabId);
            return !!(el && el.classList.contains('active'));
        }

        function setText(id, value) {
            const el = document.getElementById(id);
            if (!el) return;
            el.textContent = (value === null || value === undefined || value === '') ? '--' : String(value);
        }

        function formatBytes(bytes) {
            const v = Number(bytes) || 0;
            if (v < 1024) return `${v} B`;
            if (v < 1024 * 1024) return `${(v / 1024).toFixed(2)} KB`;
            if (v < 1024 * 1024 * 1024) return `${(v / (1024 * 1024)).toFixed(2)} MB`;
            return `${(v / (1024 * 1024 * 1024)).toFixed(2)} GB`;
        }

        function formatKbps(v) {
            const n = Number(v) || 0;
            return `${n.toFixed(2)} kbps`;
        }

        function formatPercent(v) {
            const n = Number(v);
            if (!Number.isFinite(n)) return '--';
            return `${n.toFixed(1)}%`;
        }

        function formatUptime(seconds) {
            const sec = Math.max(0, Number(seconds) || 0);
            const d = Math.floor(sec / 86400);
            const h = Math.floor((sec % 86400) / 3600);
            const m = Math.floor((sec % 3600) / 60);
            const s = sec % 60;
            if (d > 0) return `${d}d ${h}h ${m}m ${s}s`;
            if (h > 0) return `${h}h ${m}m ${s}s`;
            if (m > 0) return `${m}m ${s}s`;
            return `${s}s`;
        }

        function formatIsoUtc(iso) {
            if (!iso) return '--';
            const d = new Date(iso);
            if (isNaN(d.getTime())) return iso;
            const pad = (v) => String(v).padStart(2, '0');
            const dd = pad(d.getUTCDate());
            const mm = pad(d.getUTCMonth() + 1);
            const yy = String(d.getUTCFullYear()).slice(-2);
            const hh = pad(d.getUTCHours());
            const min = pad(d.getUTCMinutes());
            const ss = pad(d.getUTCSeconds());
            return `${dd}/${mm}/${yy} ${hh}/${min}/${ss}`;
        }

        function latestNumeric(values) {
            return (Array.isArray(values) && values.length) ? values[values.length - 1] : null;
        }

        function pushPerfGraphSample(key, value, sampleTsMs = null) {
            const arr = perfGraphHistory[key];
            const tsArr = perfGraphTimeHistory[key];
            if (!arr || !tsArr) return;
            const n = Number(value);
            if (!Number.isFinite(n)) return;
            const ts = Number(sampleTsMs);
            arr.push(n);
            tsArr.push(Number.isFinite(ts) ? ts : Date.now());
            if (arr.length > PERF_GRAPH_MAX_POINTS) arr.shift();
            if (tsArr.length > PERF_GRAPH_MAX_POINTS) tsArr.shift();
        }

        function hexToRgba(hex, alpha) {
            const raw = String(hex || '').trim().replace('#', '');
            if (!/^[0-9a-fA-F]{6}$/.test(raw)) return `rgba(102,126,234,${alpha})`;
            const r = parseInt(raw.slice(0, 2), 16);
            const g = parseInt(raw.slice(2, 4), 16);
            const b = parseInt(raw.slice(4, 6), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function drawSparkline(canvasId, values, colorHex) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const cssW = Math.max(140, Math.floor(canvas.clientWidth || 220));
            const cssH = Math.max(48, Math.floor(canvas.clientHeight || 72));
            const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
            const pxW = cssW * dpr;
            const pxH = cssH * dpr;
            if (canvas.width !== pxW || canvas.height !== pxH) {
                canvas.width = pxW;
                canvas.height = pxH;
            }
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.clearRect(0, 0, cssW, cssH);
            ctx.fillStyle = 'rgba(255,255,255,0.01)';
            ctx.fillRect(0, 0, cssW, cssH);

            const arr = Array.isArray(values) ? values.filter(v => Number.isFinite(v)) : [];
            if (arr.length < 2) return;

            const minV = Math.min(...arr);
            const maxV = Math.max(...arr);
            const safeMax = (maxV - minV) < 0.0001 ? (minV + 1) : maxV;
            const range = safeMax - minV;
            const padX = 6;
            const padY = 6;
            const w = cssW - (padX * 2);
            const h = cssH - (padY * 2);
            const stepX = arr.length > 1 ? (w / (arr.length - 1)) : w;

            const toX = (idx) => padX + (idx * stepX);
            const toY = (v) => padY + h - (((v - minV) / range) * h);

            ctx.beginPath();
            ctx.moveTo(toX(0), toY(arr[0]));
            for (let i = 1; i < arr.length; i++) ctx.lineTo(toX(i), toY(arr[i]));
            ctx.lineWidth = 2;
            ctx.strokeStyle = colorHex;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(toX(0), toY(arr[0]));
            for (let i = 1; i < arr.length; i++) ctx.lineTo(toX(i), toY(arr[i]));
            ctx.lineTo(toX(arr.length - 1), padY + h);
            ctx.lineTo(toX(0), padY + h);
            ctx.closePath();
            ctx.fillStyle = hexToRgba(colorHex, 0.18);
            ctx.fill();
        }

        function formatClockTime(tsMs) {
            const d = new Date(Number(tsMs) || Date.now());
            if (Number.isNaN(d.getTime())) return '--:--:--';
            const hh = String(d.getHours()).padStart(2, '0');
            const mm = String(d.getMinutes()).padStart(2, '0');
            const ss = String(d.getSeconds()).padStart(2, '0');
            return `${hh}:${mm}:${ss}`;
        }

        function closePerfDetailGraph() {
            const modal = document.getElementById('perfDetailModal');
            if (!modal) return;
            modal.hidden = true;
            modal.setAttribute('aria-hidden', 'true');
            document.body.classList.remove('perf-detail-open');
            activePerfDetailGraphId = null;
        }

        function openPerfDetailGraph(canvasId) {
            const cfg = perfGraphConfigs[canvasId];
            if (!cfg) return;
            const modal = document.getElementById('perfDetailModal');
            if (!modal) return;
            activePerfDetailGraphId = canvasId;
            setText('perfDetailTitle', `${cfg.title} (Detailed)`);
            setText('perfDetailSubtitle', `X-axis: Time | Y-axis: ${cfg.yAxis}`);
            modal.hidden = false;
            modal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('perf-detail-open');
            drawPerfDetailGraph();
        }

        function drawPerfDetailGraph() {
            if (!activePerfDetailGraphId) return;
            const cfg = perfGraphConfigs[activePerfDetailGraphId];
            if (!cfg) return;
            const modal = document.getElementById('perfDetailModal');
            const canvas = document.getElementById('perfDetailCanvas');
            if (!modal || modal.hidden || !canvas) return;
            const values = Array.isArray(perfGraphHistory[cfg.key]) ? perfGraphHistory[cfg.key].slice() : [];
            const times = Array.isArray(perfGraphTimeHistory[cfg.key]) ? perfGraphTimeHistory[cfg.key].slice() : [];

            const cssW = Math.max(240, Math.floor(canvas.clientWidth || 920));
            const cssH = Math.max(220, Math.floor(canvas.clientHeight || 520));
            const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
            const pxW = cssW * dpr;
            const pxH = cssH * dpr;
            if (canvas.width !== pxW || canvas.height !== pxH) {
                canvas.width = pxW;
                canvas.height = pxH;
            }
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.clearRect(0, 0, cssW, cssH);
            ctx.fillStyle = 'rgba(255,255,255,0.02)';
            ctx.fillRect(0, 0, cssW, cssH);
            if (!values.length || values.length !== times.length) {
                ctx.fillStyle = '#9aa4b2';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = '14px Segoe UI, sans-serif';
                ctx.fillText('Waiting for data points...', cssW / 2, cssH / 2);
                return;
            }

            const padLeft = 84;
            const padRight = 22;
            const padTop = 24;
            const padBottom = 58;
            const chartW = Math.max(30, cssW - padLeft - padRight);
            const chartH = Math.max(30, cssH - padTop - padBottom);

            let minV = Math.min(...values);
            let maxV = Math.max(...values);
            if ((maxV - minV) < 0.000001) maxV = minV + 1;
            const spread = maxV - minV;
            const yPad = spread * 0.1;
            let yMin = minV - yPad;
            let yMax = maxV + yPad;
            if (yMin > 0 && minV >= 0) yMin = Math.max(0, yMin);
            const yRange = Math.max(0.000001, yMax - yMin);

            const toX = (idx) => padLeft + ((chartW * idx) / Math.max(1, values.length - 1));
            const toY = (v) => padTop + chartH - (((v - yMin) / yRange) * chartH);

            ctx.strokeStyle = 'rgba(255,255,255,0.14)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padLeft, padTop);
            ctx.lineTo(padLeft, padTop + chartH);
            ctx.lineTo(padLeft + chartW, padTop + chartH);
            ctx.stroke();

            const yTicks = 5;
            ctx.font = '11px Segoe UI, sans-serif';
            ctx.fillStyle = '#9aa4b2';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for (let i = 0; i <= yTicks; i++) {
                const r = i / yTicks;
                const y = padTop + chartH - (chartH * r);
                const v = yMin + (yRange * r);
                ctx.strokeStyle = 'rgba(255,255,255,0.08)';
                ctx.beginPath();
                ctx.moveTo(padLeft, y);
                ctx.lineTo(padLeft + chartW, y);
                ctx.stroke();
                const label = cfg.formatValue ? cfg.formatValue(v) : v.toFixed(2);
                ctx.fillText(label, padLeft - 10, y);
            }

            const xTicks = Math.min(6, values.length);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            for (let i = 0; i < xTicks; i++) {
                const idx = Math.round(((values.length - 1) * i) / Math.max(1, xTicks - 1));
                const x = toX(idx);
                const ts = times[idx];
                ctx.strokeStyle = 'rgba(255,255,255,0.10)';
                ctx.beginPath();
                ctx.moveTo(x, padTop);
                ctx.lineTo(x, padTop + chartH);
                ctx.stroke();
                ctx.fillStyle = '#9aa4b2';
                ctx.fillText(formatClockTime(ts), x, padTop + chartH + 8);
            }

            ctx.beginPath();
            ctx.moveTo(toX(0), toY(values[0]));
            for (let i = 1; i < values.length; i++) {
                ctx.lineTo(toX(i), toY(values[i]));
            }
            ctx.lineWidth = 2.4;
            ctx.strokeStyle = cfg.color;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(toX(0), toY(values[0]));
            for (let i = 1; i < values.length; i++) ctx.lineTo(toX(i), toY(values[i]));
            ctx.lineTo(toX(values.length - 1), padTop + chartH);
            ctx.lineTo(toX(0), padTop + chartH);
            ctx.closePath();
            ctx.fillStyle = hexToRgba(cfg.color, 0.20);
            ctx.fill();

            const lastIdx = values.length - 1;
            const lastX = toX(lastIdx);
            const lastY = toY(values[lastIdx]);
            ctx.beginPath();
            ctx.arc(lastX, lastY, 4, 0, Math.PI * 2);
            ctx.fillStyle = cfg.color;
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1.2;
            ctx.stroke();

            ctx.fillStyle = '#c9d3e3';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.font = '12px Segoe UI, sans-serif';
            ctx.fillText('Time', padLeft + (chartW / 2), cssH - 8);

            ctx.save();
            ctx.translate(22, padTop + (chartH / 2));
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#c9d3e3';
            ctx.fillText(cfg.yAxis, 0, 0);
            ctx.restore();
        }

        function bindPerfGraphDetailInteractions() {
            Object.keys(perfGraphConfigs).forEach((canvasId) => {
                const canvas = document.getElementById(canvasId);
                if (!canvas || canvas.dataset.detailBound === '1') return;
                canvas.dataset.detailBound = '1';
                canvas.tabIndex = 0;
                canvas.setAttribute('role', 'button');
                canvas.setAttribute('aria-label', 'Open detailed metric graph');
                canvas.setAttribute('title', 'Open detailed graph');
                canvas.addEventListener('click', () => openPerfDetailGraph(canvasId));
                canvas.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        openPerfDetailGraph(canvasId);
                    }
                });
            });

            const modal = document.getElementById('perfDetailModal');
            const closeBtn = document.getElementById('perfDetailCloseBtn');
            if (modal && modal.dataset.bound !== '1') {
                modal.dataset.bound = '1';
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) closePerfDetailGraph();
                });
            }
            if (closeBtn && closeBtn.dataset.bound !== '1') {
                closeBtn.dataset.bound = '1';
                closeBtn.addEventListener('click', closePerfDetailGraph);
            }
            if (!document.body.dataset.perfDetailEscBound) {
                document.body.dataset.perfDetailEscBound = '1';
                document.addEventListener('keydown', (e) => {
                    if (e.key !== 'Escape' || !activePerfDetailGraphId) return;
                    e.preventDefault();
                    e.stopPropagation();
                    closePerfDetailGraph();
                }, true);
            }
        }

        function renderPerfGraphs() {
            drawSparkline('graphBandwidthIn', perfGraphHistory.inKbps, '#34d399');
            drawSparkline('graphBandwidthOut', perfGraphHistory.outKbps, '#60a5fa');
            drawSparkline('graphLagMs', perfGraphHistory.lagMs, '#f59e0b');
            drawSparkline('graphRamUsed', perfGraphHistory.ramUsedMb, '#f97316');
            drawSparkline('graphStorageUsed', perfGraphHistory.storageUsedPct, '#c084fc');
            drawSparkline('graphDiskRead', perfGraphHistory.diskReadKbps, '#22d3ee');
            drawSparkline('graphDiskWrite', perfGraphHistory.diskWriteKbps, '#f472b6');

            const inKbps = latestNumeric(perfGraphHistory.inKbps);
            const outKbps = latestNumeric(perfGraphHistory.outKbps);
            const lagMs = latestNumeric(perfGraphHistory.lagMs);
            const ramUsedMb = latestNumeric(perfGraphHistory.ramUsedMb);
            const storageUsedPct = latestNumeric(perfGraphHistory.storageUsedPct);
            const diskReadKbps = latestNumeric(perfGraphHistory.diskReadKbps);
            const diskWriteKbps = latestNumeric(perfGraphHistory.diskWriteKbps);

            setText('graphBandwidthInVal', Number.isFinite(inKbps) ? formatKbps(inKbps) : '--');
            setText('graphBandwidthOutVal', Number.isFinite(outKbps) ? formatKbps(outKbps) : '--');
            setText('graphLagMsVal', Number.isFinite(lagMs) ? `${lagMs.toFixed(1)} ms` : '--');
            setText('graphRamUsedVal', Number.isFinite(ramUsedMb) ? `${ramUsedMb.toFixed(1)} MB` : '--');
            setText('graphStorageUsedVal', Number.isFinite(storageUsedPct) ? `${storageUsedPct.toFixed(1)}%` : '--');
            setText('graphDiskReadVal', Number.isFinite(diskReadKbps) ? formatKbps(diskReadKbps) : '--');
            setText('graphDiskWriteVal', Number.isFinite(diskWriteKbps) ? formatKbps(diskWriteKbps) : '--');
            if (activePerfDetailGraphId) drawPerfDetailGraph();
        }

        function updatePerfGraphHistory(data, lagMs) {
            const bandwidth = (data && data.bandwidth) || {};
            const nowSec = Date.now() / 1000;
            const sampleTs = Date.now();
            const totalInBytes = Number(bandwidth.in_bytes);
            const totalOutBytes = Number(bandwidth.out_bytes);
            let inKbps = Number(bandwidth.avg_in_kbps);
            let outKbps = Number(bandwidth.avg_out_kbps);

            if (Number.isFinite(totalInBytes) && Number.isFinite(totalOutBytes)) {
                if (perfLastBandwidthSample && Number.isFinite(perfLastBandwidthSample.ts)) {
                    const dt = nowSec - perfLastBandwidthSample.ts;
                    if (dt > 0.5) {
                        const deltaIn = Math.max(0, totalInBytes - perfLastBandwidthSample.inBytes);
                        const deltaOut = Math.max(0, totalOutBytes - perfLastBandwidthSample.outBytes);
                        inKbps = ((deltaIn * 8) / 1000) / dt;
                        outKbps = ((deltaOut * 8) / 1000) / dt;
                    }
                }
                perfLastBandwidthSample = { ts: nowSec, inBytes: totalInBytes, outBytes: totalOutBytes };
            }
            if (!Number.isFinite(inKbps)) inKbps = 0;
            if (!Number.isFinite(outKbps)) outKbps = 0;

            pushPerfGraphSample('inKbps', inKbps, sampleTs);
            pushPerfGraphSample('outKbps', outKbps, sampleTs);
            pushPerfGraphSample('lagMs', lagMs, sampleTs);

            const memory = (data && data.memory) || {};
            const ramUsed = (memory.system_used_mb != null) ? Number(memory.system_used_mb) : Number(memory.process_rss_mb);
            pushPerfGraphSample('ramUsedMb', ramUsed, sampleTs);

            const storage = (data && data.storage) || {};
            pushPerfGraphSample('storageUsedPct', Number(storage.used_percent), sampleTs);

            const disk = (data && data.disk) || {};
            pushPerfGraphSample('diskReadKbps', Number(disk.process_read_kbps), sampleTs);
            pushPerfGraphSample('diskWriteKbps', Number(disk.process_write_kbps), sampleTs);
            renderPerfGraphs();
        }

        function renderPerfAuditRows(logs, canViewAudit = false) {
            const tbody = document.getElementById('perfAuditRows');
            if (!tbody) return;
            if (!canViewAudit) {
                tbody.innerHTML = '<tr><td colspan="6" class="empty">Activity logs are restricted.</td></tr>';
                return;
            }
            const rows = Array.isArray(logs) ? logs : [];
            if (!rows.length) {
                tbody.innerHTML = '<tr><td colspan="6" class="empty">No audit logs yet</td></tr>';
                return;
            }
            tbody.innerHTML = rows.map((entry) => {
                const status = String(entry && entry.status ? entry.status : '').toLowerCase();
                const statusClass = (status === 'success' || status === 'ok') ? 'status-ok' : `status-${status || 'failed'}`;
                return `<tr>
                    <td>${formatIsoUtc(entry.ts)}</td>
                    <td>${entry.event || '--'}</td>
                    <td>${entry.username || '--'}</td>
                    <td class="${statusClass}">${entry.status || '--'}</td>
                    <td>${entry.ip || '--'}</td>
                    <td>${entry.details || '--'}</td>
                </tr>`;
            }).join('');
        }

        function renderAdminConsoleRows(logs) {
            const tbody = document.getElementById('adminConsoleRows');
            if (!tbody) return;
            const rows = Array.isArray(logs) ? logs : [];
            if (!rows.length) {
                tbody.innerHTML = '<tr><td colspan="6" class="empty">No activity logs yet</td></tr>';
                return;
            }
            tbody.innerHTML = rows.map((entry) => {
                const status = String(entry && entry.status ? entry.status : '').toLowerCase();
                const statusClass = (status === 'success' || status === 'ok') ? 'status-ok' : `status-${status || 'failed'}`;
                return `<tr>
                    <td>${formatIsoUtc(entry.ts)}</td>
                    <td>${entry.event || '--'}</td>
                    <td>${entry.username || '--'}</td>
                    <td class="${statusClass}">${entry.status || '--'}</td>
                    <td>${entry.ip || '--'}</td>
                    <td>${entry.details || '--'}</td>
                </tr>`;
            }).join('');
        }

        async function loadAdminConsole() {
            if (!CAN_ACCESS_SECURE_ADMIN) return;
            try {
                const res = await fetch('/admin/console/activity?limit=350', { cache: 'no-store' });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                setText('consoleTotalActivity', data.total_activity);
                setText('consoleReturnedActivity', data.returned);
                setText('consoleSuccessCount', data.success_count);
                setText('consoleFailedCount', data.failed_count);
                renderAdminConsoleRows(data.activity_logs);
            } catch (e) {
                setText('consoleTotalActivity', 'Failed to load');
                renderAdminConsoleRows([]);
            }
        }

        async function loadServerPerformance() {
            const reqStart = (window.performance && typeof performance.now === 'function') ? performance.now() : Date.now();
            try {
                const res = await fetch('/admin/performance', { cache: 'no-store' });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                const reqEnd = (window.performance && typeof performance.now === 'function') ? performance.now() : Date.now();
                const lagMs = Math.max(0, reqEnd - reqStart);
                setText('perfUptime', formatUptime(data.uptime_sec));
                const processRam = data.memory && data.memory.process_rss_mb != null ? `${data.memory.process_rss_mb} MB` : '--';
                const systemRam = data.memory && data.memory.system_total_mb != null ? `${data.memory.system_total_mb} MB` : '--';
                const systemRamUsed = data.memory && data.memory.system_used_mb != null ? `${data.memory.system_used_mb} MB` : null;
                const memorySource = (data.memory && data.memory.source) ? ` (${data.memory.source})` : '';
                setText('perfRam', (systemRamUsed ? `${processRam} / ${systemRamUsed} of ${systemRam}` : `${processRam} / ${systemRam}`) + memorySource);
                const cpuPercent = data.cpu && data.cpu.process_percent != null ? formatPercent(data.cpu.process_percent) : '--';
                const cpuCores = data.cpu && data.cpu.cores != null ? ` (${data.cpu.cores} cores)` : '';
                setText('perfCpu', `${cpuPercent}${cpuCores}`);
                setText('perfBandwidthIn', formatBytes(data.bandwidth && data.bandwidth.in_bytes));
                setText('perfBandwidthOut', formatBytes(data.bandwidth && data.bandwidth.out_bytes));
                setText('perfBandwidthInRate', formatKbps(data.bandwidth && data.bandwidth.avg_in_kbps));
                setText('perfBandwidthOutRate', formatKbps(data.bandwidth && data.bandwidth.avg_out_kbps));
                setText('perfRequests', data.requests_total);
                setText('perfSseClients', data.sse_clients);
                setText('perfCurrentAdmin', data.admin && data.admin.current_admin);
                setText('perfAdminCount', data.admin && data.admin.admins_count);
                setText('perfLoginSuccess', data.admin && data.admin.successful_logins);
                setText('perfLoginFailed', data.admin && data.admin.failed_logins);
                setText('perfLastLoginSuccess', formatIsoUtc(data.admin && data.admin.last_success_login));
                setText('perfLastLoginFailed', formatIsoUtc(data.admin && data.admin.last_failed_login));
                setText('perfBusesCount', data.buses_count);
                setText('perfActiveDrivers', data.active_drivers);
                setText('perfRoutesCount', data.routes_count);
                setText('perfHostelsCount', data.hostels_count);
                setText('perfClassesCount', data.classes_count);
                setText('perfActiveStudents', data.active_students);
                setText('perfActiveAdmins', data.active_admins);
                const canViewAudit = !!CAN_ACCESS_SECURE_ADMIN;
                renderPerfAuditRows(data.audit_logs, canViewAudit);
                updatePerfGraphHistory(data, lagMs);
            } catch (e) {
                const reqEnd = (window.performance && typeof performance.now === 'function') ? performance.now() : Date.now();
                pushPerfGraphSample('lagMs', Math.max(0, reqEnd - reqStart), Date.now());
                renderPerfGraphs();
                setText('perfUptime', 'Failed to load');
                setText('perfCpu', '--');
                renderPerfAuditRows([], CAN_ACCESS_SECURE_ADMIN);
            }
        }

        async function downloadPerfExport(format) {
            if (!CAN_ACCESS_SECURE_ADMIN) {
                alert('Access denied.');
                return;
            }
            const fmt = (format === 'txt') ? 'txt' : 'md';
            try {
                const res = await fetch(`/admin/performance/export?format=${fmt}`, { cache: 'no-store' });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const stamp = new Date().toISOString().replace(/[:.]/g, '-');
                a.href = url;
                a.download = `admin-audit-${stamp}.${fmt}`;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
            } catch (e) {
                alert(`Export failed (${fmt.toUpperCase()})`);
            }
        }

        async function downloadAdminConsoleExport(format) {
            if (!CAN_ACCESS_SECURE_ADMIN) {
                alert('Access denied.');
                return;
            }
            const fmt = (format === 'json') ? 'json' : 'txt';
            try {
                const res = await fetch(`/admin/console/activity/export?format=${fmt}`, { cache: 'no-store' });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const stamp = new Date().toISOString().replace(/[:.]/g, '-');
                a.href = url;
                a.download = `admin-console-activity-${stamp}.${fmt}`;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
            } catch (e) {
                alert(`Export failed (${fmt.toUpperCase()})`);
            }
        }

        function exportTableView(tableId, filePrefix) {
            if (!CAN_ACCESS_SECURE_ADMIN) {
                alert('Access denied.');
                return;
            }
            const table = document.getElementById(tableId);
            if (!table) {
                alert('Nothing to export.');
                return;
            }
            const rows = Array.from(table.querySelectorAll('tr'));
            if (!rows.length) {
                alert('Nothing to export.');
                return;
            }
            const csvRows = rows
                .map((row) => Array.from(row.querySelectorAll('th,td')).map((cell) => {
                    const raw = String(cell.textContent || '').replace(/\r?\n/g, ' ').trim();
                    const escaped = raw.replace(/"/g, '""');
                    return `"${escaped}"`;
                }).join(','))
                .filter((line) => line !== '""');
            if (!csvRows.length) {
                alert('Nothing to export.');
                return;
            }
            const body = csvRows.join('\n') + '\n';
            const blob = new Blob([body], { type: 'text/csv;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const stamp = new Date().toISOString().replace(/[:.]/g, '-');
            a.href = url;
            a.download = `${filePrefix}-${stamp}.csv`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }

        function startPerfAutoRefresh() {
            stopPerfAutoRefresh();
            loadServerPerformance();
            perfAutoRefreshId = setInterval(() => {
                if (!isTabActive('serverPerf') || document.hidden) return;
                loadServerPerformance();
            }, 5000);
        }

        function stopPerfAutoRefresh() {
            if (perfAutoRefreshId) {
                try { clearInterval(perfAutoRefreshId); } catch (e) {}
                perfAutoRefreshId = null;
            }
        }

        function startAdminConsoleAutoRefresh() {
            if (!CAN_ACCESS_SECURE_ADMIN) return;
            stopAdminConsoleAutoRefresh();
            loadAdminConsole();
            adminConsoleAutoRefreshId = setInterval(() => {
                if (!isTabActive('adminConsole') || document.hidden) return;
                loadAdminConsole();
            }, 5000);
        }

        function stopAdminConsoleAutoRefresh() {
            if (adminConsoleAutoRefreshId) {
                try { clearInterval(adminConsoleAutoRefreshId); } catch (e) {}
                adminConsoleAutoRefreshId = null;
            }
        }

        function activateTab(tabId) {
            const tab = document.querySelector(`.tab[data-tab="${tabId}"]`);
            const content = document.getElementById(tabId);
            if (!tab || !content) return;
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            tab.classList.add('active');
            content.classList.add('active');
            if (tabId !== 'serverPerf' && activePerfDetailGraphId) closePerfDetailGraph();

            if (tabId === 'routes') {
                setTimeout(initRouteMap, 100);
                loadRoutes();
                stopBusesAutoRefresh();
                stopPerfAutoRefresh();
                stopAdminConsoleAutoRefresh();
            } else if (tabId === 'buildings') {
                setTimeout(initBuildingsMap, 100);
                loadHostels();
                loadClasses();
                stopBusesAutoRefresh();
                stopPerfAutoRefresh();
                stopAdminConsoleAutoRefresh();
            } else if (tabId === 'buses') {
                startBusesAutoRefresh();
                stopPerfAutoRefresh();
                stopAdminConsoleAutoRefresh();
            } else if (tabId === 'serverPerf') {
                stopBusesAutoRefresh();
                startPerfAutoRefresh();
                stopAdminConsoleAutoRefresh();
            } else if (tabId === 'adminConsole') {
                stopBusesAutoRefresh();
                stopPerfAutoRefresh();
                startAdminConsoleAutoRefresh();
            }
        }

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => activateTab(tab.getAttribute('data-tab')));
        });

        // ==== ROUTE MAP ====
        function pointDistanceMeters(a, b) {
            const dLat = (b[0] - a[0]) * Math.PI / 180;
            const dLng = (b[1] - a[1]) * Math.PI / 180;
            const x = dLng * Math.cos(((a[0] + b[0]) * 0.5) * Math.PI / 180);
            return 6371000 * Math.sqrt((dLat * dLat) + (x * x));
        }

        function getNamedStopCount() {
            let count = 0;
            for (let i = 1; i < currentStops.length; i++) {
                if (currentStops[i] && String(currentStops[i]).trim()) count++;
            }
            return count;
        }

        function nextStopName() {
            return `Stop ${getNamedStopCount() + 1}`;
        }

        function normalizeFollowRoadSegments(rawSegments, waypointCount, defaultValue = false) {
            const segmentCount = Math.max(0, Number(waypointCount || 0) - 1);
            const fallback = !!defaultValue;
            const normalized = [];
            if (Array.isArray(rawSegments)) {
                for (let i = 0; i < Math.min(rawSegments.length, segmentCount); i++) {
                    normalized.push(!!rawSegments[i]);
                }
            }
            while (normalized.length < segmentCount) normalized.push(fallback);
            return normalized;
        }

        function ensureFollowRoadSegments() {
            followRoadSegments = normalizeFollowRoadSegments(followRoadSegments, currentWaypoints.length, followRoadsEnabled);
        }

        function ensureStopsArraySize() {
            while (currentStops.length < currentWaypoints.length) currentStops.push('');
            if (currentStops.length > currentWaypoints.length) currentStops.length = currentWaypoints.length;
            if (currentWaypoints.length > 0 && (!currentStops[0] || !String(currentStops[0]).trim())) {
                currentStops[0] = 'START';
            }
            ensureFollowRoadSegments();
        }

        function addOrFixStopName(idx) {
            if (idx < 0 || idx >= currentWaypoints.length) return;
            if (idx === 0) {
                currentStops[idx] = 'START';
                return;
            }
            const existing = currentStops[idx] ? String(currentStops[idx]).trim() : '';
            currentStops[idx] = existing || nextStopName();
        }

        function getStopListEntries() {
            const entries = [];
            for (let idx = 0; idx < currentWaypoints.length; idx++) {
                const isStart = idx === 0;
                const isEnd = idx === currentWaypoints.length - 1;
                const name = currentStops[idx] ? String(currentStops[idx]).trim() : '';
                if (isStart || name || (drawMode === 'freehand' && isEnd)) {
                    entries.push({ idx, wp: currentWaypoints[idx], isStart, isEnd });
                }
            }
            return entries;
        }

        function scheduleRouteRender() {
            if (renderQueued) return;
            renderQueued = true;
            requestAnimationFrame(() => {
                renderQueued = false;
                renderMapWaypoints();
                renderStopsList();
            });
        }

        function cloneStopState() {
            return {
                waypoints: currentWaypoints.map((wp) => [wp[0], wp[1]]),
                stops: currentStops.map((s) => (s == null ? '' : String(s))),
                mapMode: mapMode,
                followRoadsEnabled: !!followRoadsEnabled,
                followRoadSegments: followRoadSegments.map((flag) => !!flag)
            };
        }

        function resetStopHistory() {
            stopUndoStack = [];
            stopRedoStack = [];
        }

        function pushStopUndoState() {
            stopUndoStack.push(cloneStopState());
            if (stopUndoStack.length > 200) stopUndoStack.shift();
            stopRedoStack = [];
        }

        function applyStopState(state) {
            if (!state) return;
            currentWaypoints = (state.waypoints || []).map((wp) => [wp[0], wp[1]]);
            currentStops = (state.stops || []).map((s) => (s == null ? '' : String(s)));
            mapMode = state.mapMode || (currentWaypoints.length ? 'stops' : 'start');
            followRoadsEnabled = !!state.followRoadsEnabled;
            followRoadSegments = normalizeFollowRoadSegments(state.followRoadSegments, currentWaypoints.length, followRoadsEnabled);
            isFreehandDrawing = false;
            freehandLastPoint = null;
            suppressNextClick = false;
            if (routeMap && routeMap.dragging) {
                try { routeMap.dragging.enable(); } catch (e) {}
            }
            ensureStopsArraySize();
            updateSteps();
            updateInstructions();
            refreshFollowRoadUi();
            scheduleRouteRender();
        }

        function undoStopCreation() {
            if (!stopUndoStack.length) return;
            stopRedoStack.push(cloneStopState());
            const prev = stopUndoStack.pop();
            applyStopState(prev);
        }

        function redoStopCreation() {
            if (!stopRedoStack.length) return;
            stopUndoStack.push(cloneStopState());
            const next = stopRedoStack.pop();
            applyStopState(next);
        }

        function isTextInputTarget(target) {
            if (!target) return false;
            const tag = (target.tagName || '').toLowerCase();
            if (tag === 'input' || tag === 'textarea') return true;
            if (target.isContentEditable) return true;
            return false;
        }

        function updateCursorInfo() {
            const el = document.getElementById('cursorInfo');
            if (!el) return;
            if (drawMode === 'straight') {
                el.textContent = 'Straight mode: click START, then click END (single segment).';
                return;
            }
            if (drawMode === 'curve') {
                el.textContent = 'Curve mode: click 3+ points. Press Esc to finish.';
                return;
            }
            if (isFreehandDrawing) {
                el.textContent = 'Freehand mode: drag to draw. Release mouse or press Esc to finish.';
                return;
            }
            el.textContent = 'Freehand mode: hold mouse and drag to draw path. Press Esc to finish.';
        }

        function formatStopRadiusText(meters) {
            const v = Math.max(1, Math.round(Number(meters) || 0));
            return `${v} m`;
        }

        function clearStopRadiusLayers() {
            if (!routeMap || !stopRadiusLayers.length) return;
            stopRadiusLayers.forEach((layer) => {
                try { routeMap.removeLayer(layer); } catch (e) {}
            });
            stopRadiusLayers = [];
        }

        function drawStopRadiusLayers(entries) {
            clearStopRadiusLayers();
            if (!routeMap || !stopRadiusVisible || !entries || !entries.length) return;
            const color = document.getElementById('routeColor').value || '#667eea';
            entries.forEach(({ wp, isStart }) => {
                if (!wp || wp.length < 2) return;
                const layer = L.circle([wp[0], wp[1]], {
                    radius: stopRadiusMeters,
                    color: isStart ? '#4CAF50' : color,
                    weight: 1,
                    opacity: 0.42,
                    fillColor: isStart ? '#4CAF50' : color,
                    fillOpacity: 0.12,
                    interactive: false
                }).addTo(routeMap);
                stopRadiusLayers.push(layer);
            });
        }

        function refreshStopRadiusUi() {
            const showToggle = document.getElementById('showStopRadius');
            const controls = document.getElementById('stopRadiusControls');
            const valueTag = document.getElementById('stopRadiusValue');
            const slider = document.getElementById('stopRadiusSlider');
            const sliderValue = document.getElementById('stopRadiusSliderValue');
            if (!showToggle || !controls || !valueTag || !slider || !sliderValue) return;

            showToggle.checked = !!stopRadiusVisible;
            controls.classList.toggle('visible', !!stopRadiusVisible);
            valueTag.textContent = formatStopRadiusText(stopRadiusMeters);
            sliderValue.textContent = formatStopRadiusText(stopRadiusMeters);

            const max = Number(slider.max || 300);
            const safeForSlider = Math.min(max, Math.max(Number(slider.min || 10), stopRadiusMeters));
            slider.value = String(safeForSlider);
        }

        function applyStopRadiusValue(rawValue) {
            const parsed = Number(rawValue);
            if (!isFinite(parsed) || parsed <= 0) return false;
            stopRadiusMeters = Math.round(parsed);
            refreshStopRadiusUi();
            drawStopRadiusLayers(getStopListEntries());
            return true;
        }

        function initStopRadiusControls() {
            const showToggle = document.getElementById('showStopRadius');
            const slider = document.getElementById('stopRadiusSlider');
            const customInput = document.getElementById('stopRadiusCustom');
            const applyBtn = document.getElementById('applyStopRadiusBtn');
            if (!showToggle || !slider || !customInput || !applyBtn) return;
            if (showToggle.dataset.bound === '1') return;

            showToggle.dataset.bound = '1';
            showToggle.addEventListener('change', () => {
                stopRadiusVisible = !!showToggle.checked;
                refreshStopRadiusUi();
                drawStopRadiusLayers(getStopListEntries());
            });

            slider.addEventListener('input', () => {
                applyStopRadiusValue(slider.value);
            });

            const applyCustom = () => {
                if (!customInput.value.trim()) return;
                const ok = applyStopRadiusValue(customInput.value.trim());
                if (ok) customInput.value = '';
            };
            applyBtn.addEventListener('click', applyCustom);
            customInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') applyCustom();
            });

            refreshStopRadiusUi();
        }

        function normalizeSnapDistance(raw, fallback) {
            const parsed = Number(raw);
            if (!isFinite(parsed) || parsed <= 0) return Math.max(1, Math.round(Number(fallback) || DEFAULT_ROUTE_SNAP_SETTINGS.distance_m));
            return Math.max(1, Math.min(1000, Math.round(parsed)));
        }

        function normalizeGlobalSnapSettings(raw) {
            const src = raw && typeof raw === 'object' ? raw : {};
            return {
                enabled: !!src.enabled,
                distance_m: normalizeSnapDistance(src.distance_m, DEFAULT_ROUTE_SNAP_SETTINGS.distance_m),
                show_range: !!src.show_range
            };
        }

        function normalizeRouteSnapDraft(raw) {
            const src = raw && typeof raw === 'object' ? raw : {};
            return {
                override_global: !!src.override_global,
                enabled: (src.enabled == null) ? !!globalRouteSnapSettings.enabled : !!src.enabled,
                distance_m: normalizeSnapDistance(src.distance_m, globalRouteSnapSettings.distance_m),
                show_range: (src.show_range == null) ? !!globalRouteSnapSettings.show_range : !!src.show_range
            };
        }

        function resetRouteSnapDraftForNewRoute() {
            routeSnapDraft = {
                override_global: false,
                enabled: !!globalRouteSnapSettings.enabled,
                distance_m: normalizeSnapDistance(globalRouteSnapSettings.distance_m, DEFAULT_ROUTE_SNAP_SETTINGS.distance_m),
                show_range: !!globalRouteSnapSettings.show_range
            };
        }

        function getEffectiveRouteSnapSettingsForBuilder() {
            if (routeSnapDraft.override_global) {
                return {
                    enabled: !!routeSnapDraft.enabled,
                    distance_m: normalizeSnapDistance(routeSnapDraft.distance_m, globalRouteSnapSettings.distance_m),
                    show_range: !!routeSnapDraft.show_range
                };
            }
            return normalizeGlobalSnapSettings(globalRouteSnapSettings);
        }

        function clearSnapRangeLayers() {
            if (!routeMap || !snapRangeLayers.length) return;
            snapRangeLayers.forEach((layer) => {
                try { routeMap.removeLayer(layer); } catch (e) {}
            });
            snapRangeLayers = [];
        }

        function getPreviewRouteCoordsForSnapRange() {
            if (routeLine && typeof routeLine.getLatLngs === 'function') {
                const raw = routeLine.getLatLngs();
                const points = (Array.isArray(raw) && raw.length && Array.isArray(raw[0])) ? raw[0] : raw;
                if (Array.isArray(points) && points.length >= 2) {
                    const mapped = points
                        .map((pt) => {
                            if (pt && typeof pt.lat === 'number' && typeof pt.lng === 'number') return [pt.lat, pt.lng];
                            if (Array.isArray(pt) && pt.length >= 2) {
                                const lat = Number(pt[0]);
                                const lng = Number(pt[1]);
                                if (isFinite(lat) && isFinite(lng)) return [lat, lng];
                            }
                            return null;
                        })
                        .filter(Boolean);
                    if (mapped.length >= 2) return mapped;
                }
            }
            if (Array.isArray(currentWaypoints) && currentWaypoints.length >= 2) {
                return currentWaypoints
                    .map((wp) => [Number(wp[0]), Number(wp[1])])
                    .filter((wp) => isFinite(wp[0]) && isFinite(wp[1]));
            }
            return [];
        }

        function metersToPixelsAtLat(meters, lat, zoom) {
            const earthCircumference = 40075016.686;
            const latRad = Number(lat || 0) * Math.PI / 180;
            const metersPerPixel = (earthCircumference * Math.max(0.15, Math.cos(latRad))) / Math.pow(2, Number(zoom || 15) + 8);
            if (!isFinite(metersPerPixel) || metersPerPixel <= 0) return 1;
            return meters / metersPerPixel;
        }

        function drawSnapRangeLayers() {
            clearSnapRangeLayers();
            if (!routeMap) return;
            const effective = getEffectiveRouteSnapSettingsForBuilder();
            if (!effective.enabled || !effective.show_range) return;
            const coords = getPreviewRouteCoordsForSnapRange();
            if (!coords || coords.length < 2) return;
            const color = document.getElementById('routeColor')?.value || '#667eea';
            const avgLat = coords.reduce((sum, wp) => sum + wp[0], 0) / coords.length;
            const zoom = (routeMap && typeof routeMap.getZoom === 'function') ? routeMap.getZoom() : 15;
            const corridorWidthPx = Math.max(4, Math.min(160, metersToPixelsAtLat(effective.distance_m * 2, avgLat, zoom)));
            const corridor = L.polyline(coords, {
                color,
                weight: corridorWidthPx,
                opacity: 0.14,
                lineCap: 'round',
                lineJoin: 'round',
                interactive: false
            }).addTo(routeMap);
            const centerLine = L.polyline(coords, {
                color,
                weight: 2,
                opacity: 0.42,
                dashArray: '8 10',
                lineCap: 'round',
                lineJoin: 'round',
                interactive: false
            }).addTo(routeMap);
            snapRangeLayers.push(corridor, centerLine);
        }

        function getFollowRoadStopLabel(idx) {
            const raw = currentStops[idx] != null ? String(currentStops[idx]).trim() : '';
            if (raw) return raw;
            return idx === 0 ? 'START' : `Stop ${idx}`;
        }

        function renderFollowRoadSegmentsUi() {
            const panel = document.getElementById('followRoadSegmentsPanel');
            if (!panel) return;
            ensureFollowRoadSegments();
            if (drawMode === 'freehand' && currentWaypoints.length > 2) {
                panel.innerHTML = '<div class="follow-road-empty">Freehand mode keeps your drawn path. Switch to curve/straight mode for per-segment road-follow controls.</div>';
                return;
            }
            if (!followRoadSegments.length) {
                panel.innerHTML = '<div class="follow-road-empty">Add START and at least one stop to configure stop-wise road following.</div>';
                return;
            }
            panel.innerHTML = '';
            followRoadSegments.forEach((enabled, segmentIdx) => {
                const row = document.createElement('label');
                row.className = 'follow-road-segment-row';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = !!enabled;
                checkbox.dataset.segment = String(segmentIdx);

                const label = document.createElement('span');
                label.className = 'follow-road-segment-label';
                label.textContent = `${getFollowRoadStopLabel(segmentIdx)} -> ${getFollowRoadStopLabel(segmentIdx + 1)}`;

                const mode = document.createElement('span');
                mode.className = 'follow-road-segment-mode';
                mode.textContent = enabled ? 'ROAD' : 'DIRECT';

                checkbox.addEventListener('change', () => {
                    followRoadSegments[segmentIdx] = !!checkbox.checked;
                    refreshFollowRoadUi();
                    scheduleRouteRender();
                });

                row.appendChild(checkbox);
                row.appendChild(label);
                row.appendChild(mode);
                panel.appendChild(row);
            });
        }

        function refreshFollowRoadUi() {
            ensureFollowRoadSegments();
            const toggle = document.getElementById('followRoadsToggle');
            const value = document.getElementById('followRoadsValue');
            const count = followRoadSegments.length;
            if (!count) {
                if (toggle) {
                    toggle.indeterminate = false;
                    toggle.checked = !!followRoadsEnabled;
                }
                if (value) value.textContent = followRoadsEnabled ? 'ON' : 'OFF';
                renderFollowRoadSegmentsUi();
                return;
            }
            const enabledCount = followRoadSegments.reduce((sum, flag) => sum + (flag ? 1 : 0), 0);
            const allEnabled = enabledCount === count;
            const noneEnabled = enabledCount === 0;
            const mixed = !allEnabled && !noneEnabled;
            if (toggle) {
                toggle.indeterminate = mixed;
                toggle.checked = allEnabled;
            }
            if (value) value.textContent = mixed ? 'MIX' : (allEnabled ? 'ON' : 'OFF');
            if (!mixed) followRoadsEnabled = allEnabled;
            renderFollowRoadSegmentsUi();
        }

        function refreshRouteSnapUi() {
            const globalEnabled = document.getElementById('globalSnapEnabled');
            const globalDistanceValue = document.getElementById('globalSnapDistanceValue');
            const globalSlider = document.getElementById('globalSnapDistanceSlider');
            const globalSliderValue = document.getElementById('globalSnapDistanceSliderValue');
            const globalShowRange = document.getElementById('globalSnapShowRange');
            const overrideToggle = document.getElementById('routeSnapOverride');
            const routeControls = document.getElementById('routeSnapControls');
            const routeEnabled = document.getElementById('routeSnapEnabled');
            const routeDistanceValue = document.getElementById('routeSnapDistanceValue');
            const routeSlider = document.getElementById('routeSnapDistanceSlider');
            const routeSliderValue = document.getElementById('routeSnapDistanceSliderValue');
            const routeShowRange = document.getElementById('routeSnapShowRange');
            if (!globalEnabled || !globalDistanceValue || !globalSlider || !globalSliderValue || !globalShowRange || !overrideToggle || !routeControls || !routeEnabled || !routeDistanceValue || !routeSlider || !routeSliderValue || !routeShowRange) return;

            globalRouteSnapSettings = normalizeGlobalSnapSettings(globalRouteSnapSettings);
            routeSnapDraft = normalizeRouteSnapDraft(routeSnapDraft);

            globalEnabled.checked = !!globalRouteSnapSettings.enabled;
            globalShowRange.checked = !!globalRouteSnapSettings.show_range;
            globalDistanceValue.textContent = formatStopRadiusText(globalRouteSnapSettings.distance_m);
            globalSliderValue.textContent = formatStopRadiusText(globalRouteSnapSettings.distance_m);
            globalSlider.value = String(Math.min(Number(globalSlider.max || 300), Math.max(Number(globalSlider.min || 1), globalRouteSnapSettings.distance_m)));

            overrideToggle.checked = !!routeSnapDraft.override_global;
            routeControls.classList.toggle('visible', !!routeSnapDraft.override_global);
            routeEnabled.checked = !!routeSnapDraft.enabled;
            routeShowRange.checked = !!routeSnapDraft.show_range;
            routeDistanceValue.textContent = formatStopRadiusText(routeSnapDraft.distance_m);
            routeSliderValue.textContent = formatStopRadiusText(routeSnapDraft.distance_m);
            routeSlider.value = String(Math.min(Number(routeSlider.max || 300), Math.max(Number(routeSlider.min || 1), routeSnapDraft.distance_m)));

            drawSnapRangeLayers();
        }

        function updateRouteLineFollowRoadPreview() {
            routeLinePreviewToken += 1;
            const token = routeLinePreviewToken;
            if (!routeMap || !routeLine || currentWaypoints.length < 2 || isFreehandDrawing || currentWaypoints.length > 24) return;
            const waypointsSnapshot = currentWaypoints.map((wp) => [wp[0], wp[1]]);
            const segmentFlagsSnapshot = normalizeFollowRoadSegments(followRoadSegments, waypointsSnapshot.length, followRoadsEnabled);
            if (!segmentFlagsSnapshot.some(Boolean)) {
                try { routeLine.setLatLngs(waypointsSnapshot); } catch (e) {}
                drawSnapRangeLayers();
                return;
            }
            getOSRMRoute(waypointsSnapshot, segmentFlagsSnapshot).then((roadPath) => {
                if (token !== routeLinePreviewToken) return;
                if (!routeLine || !Array.isArray(roadPath) || roadPath.length < 2) return;
                try { routeLine.setLatLngs(roadPath); } catch (e) {}
                drawSnapRangeLayers();
            }).catch(() => {});
        }

        async function loadGlobalRouteSnapSettings() {
            try {
                const res = await fetch('/api/route-snap-settings', { cache: 'no-store' });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'route_snap_settings_load_failed');
                globalRouteSnapSettings = normalizeGlobalSnapSettings(data || {});
                if (!routeSnapDraft.override_global) resetRouteSnapDraftForNewRoute();
            } catch (e) {
                globalRouteSnapSettings = normalizeGlobalSnapSettings(DEFAULT_ROUTE_SNAP_SETTINGS);
                if (!routeSnapDraft.override_global) resetRouteSnapDraftForNewRoute();
            }
            refreshRouteSnapUi();
        }

        async function saveGlobalRouteSnapSettings() {
            const payload = normalizeGlobalSnapSettings(globalRouteSnapSettings);
            try {
                const res = await fetch('/admin/route-snap-settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to save global snap settings');
                globalRouteSnapSettings = normalizeGlobalSnapSettings((data && data.route_snap_settings) || payload);
                if (!routeSnapDraft.override_global) resetRouteSnapDraftForNewRoute();
            } catch (e) {
                alert(e.message || 'Failed to save global snap settings');
            }
            refreshRouteSnapUi();
        }

        function initFollowRoadControls() {
            const toggle = document.getElementById('followRoadsToggle');
            if (!toggle || toggle.dataset.bound === '1') return;
            toggle.dataset.bound = '1';
            toggle.addEventListener('change', () => {
                followRoadsEnabled = !!toggle.checked;
                ensureFollowRoadSegments();
                followRoadSegments = followRoadSegments.map(() => !!followRoadsEnabled);
                refreshFollowRoadUi();
                scheduleRouteRender();
            });
            refreshFollowRoadUi();
        }

        function initRouteSnapControls() {
            const globalEnabled = document.getElementById('globalSnapEnabled');
            const globalSlider = document.getElementById('globalSnapDistanceSlider');
            const globalCustom = document.getElementById('globalSnapDistanceCustom');
            const saveGlobalBtn = document.getElementById('saveGlobalSnapBtn');
            const globalShowRange = document.getElementById('globalSnapShowRange');
            const overrideToggle = document.getElementById('routeSnapOverride');
            const routeEnabled = document.getElementById('routeSnapEnabled');
            const routeSlider = document.getElementById('routeSnapDistanceSlider');
            const routeCustom = document.getElementById('routeSnapDistanceCustom');
            const routeShowRange = document.getElementById('routeSnapShowRange');
            const applyRouteBtn = document.getElementById('applyRouteSnapBtn');
            if (!globalEnabled || !globalSlider || !globalCustom || !saveGlobalBtn || !globalShowRange || !overrideToggle || !routeEnabled || !routeSlider || !routeCustom || !routeShowRange || !applyRouteBtn) return;
            if (globalEnabled.dataset.bound === '1') return;
            globalEnabled.dataset.bound = '1';

            globalEnabled.addEventListener('change', () => {
                globalRouteSnapSettings.enabled = !!globalEnabled.checked;
                refreshRouteSnapUi();
            });
            globalShowRange.addEventListener('change', () => {
                globalRouteSnapSettings.show_range = !!globalShowRange.checked;
                refreshRouteSnapUi();
            });
            globalSlider.addEventListener('input', () => {
                globalRouteSnapSettings.distance_m = normalizeSnapDistance(globalSlider.value, globalRouteSnapSettings.distance_m);
                refreshRouteSnapUi();
            });
            const applyGlobalCustom = () => {
                if (!globalCustom.value.trim()) return;
                globalRouteSnapSettings.distance_m = normalizeSnapDistance(globalCustom.value.trim(), globalRouteSnapSettings.distance_m);
                globalCustom.value = '';
                refreshRouteSnapUi();
            };
            globalCustom.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') applyGlobalCustom();
            });
            saveGlobalBtn.addEventListener('click', async () => {
                applyGlobalCustom();
                await saveGlobalRouteSnapSettings();
            });

            overrideToggle.addEventListener('change', () => {
                routeSnapDraft.override_global = !!overrideToggle.checked;
                refreshRouteSnapUi();
            });
            routeEnabled.addEventListener('change', () => {
                routeSnapDraft.enabled = !!routeEnabled.checked;
                refreshRouteSnapUi();
            });
            routeShowRange.addEventListener('change', () => {
                routeSnapDraft.show_range = !!routeShowRange.checked;
                refreshRouteSnapUi();
            });
            routeSlider.addEventListener('input', () => {
                routeSnapDraft.distance_m = normalizeSnapDistance(routeSlider.value, routeSnapDraft.distance_m);
                refreshRouteSnapUi();
            });
            const applyRouteCustom = () => {
                if (!routeCustom.value.trim()) return;
                routeSnapDraft.distance_m = normalizeSnapDistance(routeCustom.value.trim(), routeSnapDraft.distance_m);
                routeCustom.value = '';
                refreshRouteSnapUi();
            };
            routeCustom.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') applyRouteCustom();
            });
            applyRouteBtn.addEventListener('click', applyRouteCustom);

            refreshRouteSnapUi();
        }

        function finalizeRouteCreation() {
            if (currentWaypoints.length < 2) return;
            ensureStopsArraySize();
            addOrFixStopName(currentWaypoints.length - 1);
            mapMode = 'stops';
            updateSteps();
            updateInstructions();
            refreshFollowRoadUi();
            scheduleRouteRender();
        }

        function resetRouteBuilderState() {
            currentWaypoints = [];
            currentStops = [];
            mapMode = 'start';
            isFreehandDrawing = false;
            freehandLastPoint = null;
            suppressNextClick = false;
            followRoadsEnabled = false;
            followRoadSegments = [];
            resetRouteSnapDraftForNewRoute();
            resetStopHistory();
            routeLinePreviewToken += 1;
            if (routeMap && routeMap.dragging) {
                try { routeMap.dragging.enable(); } catch (e) {}
            }
            updateSteps();
            updateInstructions();
            updateCursorInfo();
            refreshFollowRoadUi();
            refreshRouteSnapUi();
            renderMapWaypoints();
            renderStopsList();
        }

        function handleRouteMapClick(lat, lng) {
            if (drawMode === 'straight') {
                if (currentWaypoints.length === 0) {
                    addWaypointFromMap(lat, lng, { asStop: true });
                } else if (currentWaypoints.length === 1) {
                    addWaypointFromMap(lat, lng, { asStop: true });
                    finalizeRouteCreation();
                } else {
                    pushStopUndoState();
                    currentWaypoints = [currentWaypoints[0], [lat, lng]];
                    currentStops = [currentStops[0] || 'START', currentStops[1] || 'Stop 1'];
                    ensureStopsArraySize();
                    finalizeRouteCreation();
                }
                return;
            }
            if (drawMode === 'curve') {
                addWaypointFromMap(lat, lng, { asStop: true });
            }
        }

        function startFreehand(lat, lng) {
            if (drawMode !== 'freehand') return;
            if (currentWaypoints.length === 0) {
                addWaypointFromMap(lat, lng, { asStop: true });
            } else {
                const last = currentWaypoints[currentWaypoints.length - 1];
                if (!last || pointDistanceMeters(last, [lat, lng]) > FREEHAND_MIN_POINT_M) {
                    addWaypointFromMap(lat, lng, { asStop: false });
                }
            }
            isFreehandDrawing = true;
            freehandLastPoint = [lat, lng];
            suppressNextClick = true;
            if (routeMap && routeMap.dragging) {
                try { routeMap.dragging.disable(); } catch (e) {}
            }
            updateInstructions();
        }

        function extendFreehand(lat, lng) {
            if (!isFreehandDrawing || drawMode !== 'freehand') return;
            if (!freehandLastPoint || pointDistanceMeters(freehandLastPoint, [lat, lng]) >= FREEHAND_MIN_POINT_M) {
                addWaypointFromMap(lat, lng, { asStop: false });
                freehandLastPoint = [lat, lng];
            }
        }

        function stopFreehand(lat, lng) {
            if (!isFreehandDrawing) return;
            isFreehandDrawing = false;
            if (routeMap && routeMap.dragging) {
                try { routeMap.dragging.enable(); } catch (e) {}
            }
            if (typeof lat === 'number' && typeof lng === 'number') {
                const last = currentWaypoints[currentWaypoints.length - 1];
                if (!last || pointDistanceMeters(last, [lat, lng]) > 1) {
                    addWaypointFromMap(lat, lng, { asStop: true });
                }
            }
            freehandLastPoint = null;
            finalizeRouteCreation();
            updateInstructions();
        }

        function initRouteMap() {
            if (routeMap) return;
            const bounds = [[20.339920625677212, 85.7964659296332], [20.37210882553945, 85.83388810783698]];
            routeMap = L.map('routeMap', { maxBounds: bounds, minZoom: 14 }).setView([20.3549, 85.8161], 15);
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; CARTO',
                maxZoom: 19
            }).addTo(routeMap);
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}{r}.png', {
                attribution: '',
                maxZoom: 19
            }).addTo(routeMap);

            routeMap.on('click', (e) => {
                if (suppressNextClick) { suppressNextClick = false; return; }
                if (drawMode === 'freehand') return;
                handleRouteMapClick(e.latlng.lat, e.latlng.lng);
            });

            routeMap.on('mousedown', (e) => {
                if (drawMode !== 'freehand') return;
                startFreehand(e.latlng.lat, e.latlng.lng);
            });
            routeMap.on('mousemove', (e) => {
                if (drawMode !== 'freehand') return;
                extendFreehand(e.latlng.lat, e.latlng.lng);
            });
            routeMap.on('mouseup', (e) => {
                if (drawMode !== 'freehand') return;
                stopFreehand(e.latlng.lat, e.latlng.lng);
            });
            routeMap.on('mouseout', () => {
                if (drawMode !== 'freehand') return;
                if (isFreehandDrawing) stopFreehand();
            });
            routeMap.on('zoomend', () => {
                drawSnapRangeLayers();
            });

            const modeSel = document.getElementById('drawMode');
            if (modeSel) {
                drawMode = modeSel.value || 'curve';
                modeSel.addEventListener('change', () => {
                    drawMode = modeSel.value || 'curve';
                    if (drawMode !== 'freehand' && isFreehandDrawing) stopFreehand();
                    if (drawMode === 'straight' && currentWaypoints.length > 2) {
                        const end = currentWaypoints[currentWaypoints.length - 1];
                        currentWaypoints = [currentWaypoints[0], end];
                        currentStops = [currentStops[0] || 'START', currentStops[currentStops.length - 1] || 'Stop 1'];
                        ensureStopsArraySize();
                        finalizeRouteCreation();
                    } else {
                        updateInstructions();
                        refreshFollowRoadUi();
                        scheduleRouteRender();
                    }
                });
            }

            document.addEventListener('keydown', (e) => {
                const routesTab = document.getElementById('routes');
                if (!routesTab || !routesTab.classList.contains('active')) return;
                if (isTextInputTarget(e.target)) return;
                if ((e.ctrlKey || e.metaKey) && !e.shiftKey && String(e.key || '').toLowerCase() === 'z') {
                    e.preventDefault();
                    undoStopCreation();
                    return;
                }
                if ((e.ctrlKey || e.metaKey) && String(e.key || '').toLowerCase() === 'y') {
                    e.preventDefault();
                    redoStopCreation();
                    return;
                }
                if (e.key !== 'Escape') return;
                if (drawMode === 'freehand' && isFreehandDrawing) {
                    stopFreehand();
                } else {
                    finalizeRouteCreation();
                }
            });

            initStopRadiusControls();
            initFollowRoadControls();
            initRouteSnapControls();
            loadGlobalRouteSnapSettings();
            resetRouteSnapDraftForNewRoute();
            refreshFollowRoadUi();
            refreshRouteSnapUi();
            updateSteps();
            updateInstructions();
            renderStopsList();
        }

        function addWaypointFromMap(lat, lng, opts = {}) {
            const asStop = opts.asStop !== false;
            if (asStop) pushStopUndoState();
            currentWaypoints.push([lat, lng]);
            currentStops.push('');
            ensureStopsArraySize();
            if (currentWaypoints.length === 1) {
                mapMode = 'stops';
                currentStops[0] = 'START';
            } else if (asStop) {
                addOrFixStopName(currentWaypoints.length - 1);
            }
            updateSteps();
            updateInstructions();
            if (asStop) refreshFollowRoadUi();
            scheduleRouteRender();
        }

        function updateSteps() {
            const step1 = document.getElementById('step1');
            const step2 = document.getElementById('step2');
            const step3 = document.getElementById('step3');
            if (!step1 || !step2 || !step3) return;

            step1.classList.remove('active', 'done');
            step2.classList.remove('active', 'done');
            step3.classList.remove('active', 'done');

            if (currentWaypoints.length === 0) {
                step1.classList.add('active');
                return;
            }
            step1.classList.add('done');
            step2.classList.add('active');
            if (currentWaypoints.length >= 2) step3.classList.add('active');
        }

        function updateInstructions() {
            const stopsCount = getNamedStopCount();
            let main = 'Step 1: Click on map to set START point';
            let sub = 'First click anywhere on the map';

            if (mapMode !== 'start') {
                main = 'Step 2: Build route path';
                if (drawMode === 'straight') {
                    sub = (currentWaypoints.length < 2)
                        ? 'Click one END point to complete straight route.'
                        : 'Straight route complete. Click Save Route.';
                } else if (drawMode === 'curve') {
                    sub = `Add 3+ points for bends. Press Esc to finish. Stops: ${stopsCount}`;
                } else {
                    sub = isFreehandDrawing
                        ? 'Drawing freehand... release mouse or press Esc to finalize endpoint stop.'
                        : `Drag to draw freehand path. Press Esc to finish. Stops: ${stopsCount}`;
                }
            }

            document.getElementById('mainInstruction').textContent = main;
            document.getElementById('subInstruction').textContent = sub;
            updateCursorInfo();
        }
        function renderMapWaypoints() {
            if (!routeMap) return;
            const color = document.getElementById('routeColor').value;

            routeMarkers.forEach(m => {
                try { routeMap.removeLayer(m); } catch (e) {}
            });
            routeMarkers = [];

            if (routeLine) {
                try { routeMap.removeLayer(routeLine); } catch (e) {}
                routeLine = null;
            }
            clearSnapRangeLayers();

            const stopEntries = getStopListEntries();
            stopEntries.forEach(({ idx, wp, isStart }) => {
                const bg = isStart ? '#4CAF50' : color;
                const html = isStart
                    ? '<span class="tiny-marker tiny-start"></span>'
                    : `<span class="tiny-marker" style="background:${bg}"></span>`;
                const icon = L.divIcon({ className: 'marker-wrapper', html: html, iconSize: [10, 10], iconAnchor: [5, 5] });
                const marker = L.marker([wp[0], wp[1]], { icon }).addTo(routeMap);
                const label = (currentStops[idx] && String(currentStops[idx]).trim())
                    ? String(currentStops[idx]).trim()
                    : (isStart ? 'START' : `Stop ${idx}`);
                marker.bindPopup(`<b>${label}</b><br>${wp[0].toFixed(4)}, ${wp[1].toFixed(4)}`);
                routeMarkers.push(marker);
            });

            if (currentWaypoints.length > 1) {
                routeLine = L.polyline(currentWaypoints, {
                    color: color,
                    weight: 2.5,
                    opacity: 0.8
                }).addTo(routeMap);
            }

            drawStopRadiusLayers(stopEntries);
            drawSnapRangeLayers();
            updateRouteLineFollowRoadPreview();
        }
        async function getOSRMRoute(waypoints, segmentFollowFlags = null) {
            try {
                if (waypoints.length < 2) return waypoints;
                const segmentCount = Math.max(0, waypoints.length - 1);
                const flags = Array.isArray(segmentFollowFlags)
                    ? segmentFollowFlags.slice(0, segmentCount).map((flag) => !!flag)
                    : Array.from({ length: segmentCount }, () => true);
                while (flags.length < segmentCount) flags.push(!!followRoadsEnabled);

                const merged = [];
                for (let i = 0; i < segmentCount; i++) {
                    const from = waypoints[i];
                    const to = waypoints[i + 1];
                    let segment = null;
                    if (flags[i]) {
                        const coords = `${from[1]},${from[0]};${to[1]},${to[0]}`;
                        const url = `https://router.project-osrm.org/route/v1/driving/${coords}?geometries=geojson`;
                        try {
                            const res = await fetch(url);
                            const data = await res.json();
                            if (data.routes && data.routes[0] && data.routes[0].geometry && Array.isArray(data.routes[0].geometry.coordinates)) {
                                segment = data.routes[0].geometry.coordinates.map(c => [c[1], c[0]]);
                            }
                        } catch (err) {
                            segment = null;
                        }
                    }
                    if (!segment || segment.length < 2) {
                        segment = [from, to];
                    }
                    if (!merged.length) merged.push(...segment);
                    else merged.push(...segment.slice(1));
                }
                return merged.length >= 2 ? merged : waypoints;
            } catch(e) {
                console.error('OSRM error:', e);
                return waypoints;
            }
        }

        function renderStopsList() {
            const list = document.getElementById('stopsList');
            const entries = getStopListEntries();
            document.getElementById('stopCount').textContent = entries.length;

            if (entries.length === 0) {
                list.innerHTML = '<div style="text-align:center; color:#666; padding:20px; font-size:12px">No stops yet - click map to start</div>';
                return;
            }

            list.innerHTML = '';
            entries.forEach(({ idx }) => {
                const isStart = idx === 0;
                const fallback = isStart ? 'START' : `Stop ${idx}`;
                const value = (currentStops[idx] && String(currentStops[idx]).trim()) ? currentStops[idx] : fallback;

                const item = document.createElement('div');
                item.className = `stop-item ${isStart ? 'start' : ''}`;
                item.style.borderLeftColor = isStart ? '#4CAF50' : document.getElementById('routeColor').value;

                item.innerHTML = `
                    <div class="stop-icon">${isStart ? 'S' : 'P'}</div>
                    <input type="text" placeholder="${fallback}" value="${value}" readonly style="cursor:pointer" title="Click to edit">
                    <button class="danger" style="padding:4px 6px; font-size:11px" onclick="removeMapWaypoint(${idx})">x</button>
                `;

                const input = item.querySelector('input');
                input.addEventListener('click', () => {
                    input.removeAttribute('readonly');
                    input.style.cursor = 'text';
                    input.focus();
                });
                input.addEventListener('blur', () => {
                    currentStops[idx] = input.value || fallback;
                    input.setAttribute('readonly', '');
                    input.style.cursor = 'pointer';
                    renderMapWaypoints();
                    renderFollowRoadSegmentsUi();
                });
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') input.blur();
                });

                list.appendChild(item);
            });
        }

        window.removeMapWaypoint = (idx) => {
            if (idx === 0 && currentWaypoints.length > 1) {
                alert('Cannot remove START point');
                return;
            }
            if (idx < 0 || idx >= currentWaypoints.length) return;

            currentWaypoints.splice(idx, 1);
            currentStops.splice(idx, 1);
            ensureStopsArraySize();
            if (currentWaypoints.length === 0) mapMode = 'start';
            if (drawMode === 'freehand' && currentWaypoints.length >= 2) {
                addOrFixStopName(currentWaypoints.length - 1);
            }
            updateSteps();
            updateInstructions();
            refreshFollowRoadUi();
            scheduleRouteRender();
        };

        document.getElementById('clearMapBtn').addEventListener('click', () => {
            if (currentWaypoints.length > 0 && !confirm('Clear all stops?')) return;
            resetRouteBuilderState();
        });

        document.getElementById('routeColor').addEventListener('change', () => {
            renderMapWaypoints();
        });

        document.getElementById('saveRouteBtn').addEventListener('click', async () => {
            const name = document.getElementById('routeName').value.trim();
            const color = document.getElementById('routeColor').value;
            
            if (!name) { alert('Enter route name'); return; }
            if (currentWaypoints.length < 2) { alert('Add at least START + END'); return; }
            if (drawMode === 'straight' && currentWaypoints.length !== 2) {
                alert('Straight mode needs exactly 2 points: start and end.');
                return;
            }
            if (drawMode === 'curve' && currentWaypoints.length < 3) {
                alert('Curve mode needs at least 3 points.');
                return;
            }
            finalizeRouteCreation();
            ensureStopsArraySize();
            const waypointsForSave = currentWaypoints.map((wp) => [wp[0], wp[1]]);
            const followRoadSegmentsForSave = normalizeFollowRoadSegments(followRoadSegments, waypointsForSave.length, followRoadsEnabled);
            const hasRoadFollowing = followRoadSegmentsForSave.some(Boolean);
            let pathPointsForSave = waypointsForSave;
            if (hasRoadFollowing) {
                pathPointsForSave = await getOSRMRoute(waypointsForSave, followRoadSegmentsForSave);
                if (!Array.isArray(pathPointsForSave) || pathPointsForSave.length < 2) {
                    pathPointsForSave = waypointsForSave;
                }
            }
            routeSnapDraft = normalizeRouteSnapDraft(routeSnapDraft);
            
            const route = {
                id: editingRouteId || `route_${Date.now()}`,
                name: name,
                waypoints: waypointsForSave,
                path_points: pathPointsForSave,
                stops: currentStops,
                color: color,
                follow_roads: !!hasRoadFollowing,
                follow_roads_segments: followRoadSegmentsForSave,
                snap_settings: {
                    override_global: !!routeSnapDraft.override_global,
                    enabled: !!routeSnapDraft.enabled,
                    distance_m: normalizeSnapDistance(routeSnapDraft.distance_m, globalRouteSnapSettings.distance_m),
                    show_range: !!routeSnapDraft.show_range
                }
            };
            
            const res = await fetch('/api/route', {
                method: 'POST',
                headers: {'Content-Type':'application/json'},
                body: JSON.stringify(route)
            });
            
            if (res.ok) {
                editingRouteId = null;
                document.getElementById('routeName').value = '';
                resetRouteBuilderState();
                await loadRoutes();
            }
        });

        async function loadRoutes() {
            const [routesRes, busRoutesRes] = await Promise.all([
                fetch('/api/routes'),
                fetch('/api/bus-routes')
            ]);
            const routes = await routesRes.json();
            const busRoutes = await busRoutesRes.json();
            renderRoutes(routes, busRoutes);
        }

        function renderRoutes(routes, busRoutes) {
            const container = document.getElementById('routesList');
            if (routes.length === 0) {
                container.innerHTML = '<div class="empty">No routes yet - create one!</div>';
                return;
            }
            container.innerHTML = '';
            routes.forEach(route => {
                // Determine status: running if any active bus is assigned to this route
                const isRunning = Object.values(busRoutes || {}).some(rid => String(rid) === String(route.id));
                const namedStops = (route.stops || []).filter(s => s && String(s).trim());
                const stopCount = namedStops.length || route.waypoints.length;
                const stopPreview = namedStops.slice(0, 2).join(' ‚Üí ');
                const card = document.createElement('div');
                card.className = 'route-card';
                card.style.borderLeftColor = route.color;
                card.innerHTML = `
                    <div class="route-name">${route.name}</div>
                    <div class="route-info">
                        <div>üõë ${stopCount} stops</div>
                        <div style="margin-top:4px"><span class="route-badge ${isRunning ? 'badge-running' : 'badge-idle'}">${isRunning ? 'Running' : 'Idle'}</span></div>
                        <div style="margin-top:4px; color:#667eea">${stopPreview}</div>
                    </div>
                    <div class="route-actions">
                        <button class="ok" style="background:rgba(102,126,234,0.1)" onclick="editRoute('${route.id}')">‚úèÔ∏è Edit</button>
                        <button class="danger" style="background:rgba(255,123,138,0.05)" onclick="deleteRoute('${route.id}')">üóëÔ∏è Delete</button>
                    </div>
                `;
                container.appendChild(card);
            });
        }

        window.editRoute = async (routeId) => {
            const res = await fetch('/api/routes');
            const routes = await res.json();
            const route = routes.find(r => r.id === routeId);
            if (route) {
                document.querySelector('[data-tab="routes"]').click();
                setTimeout(() => {
                    document.getElementById('routeName').value = route.name;
                    document.getElementById('routeColor').value = route.color;
                    currentWaypoints = JSON.parse(JSON.stringify(route.waypoints));
                    currentStops = JSON.parse(JSON.stringify(route.stops || []));
                    followRoadsEnabled = !!route.follow_roads;
                    followRoadSegments = normalizeFollowRoadSegments(route.follow_roads_segments, currentWaypoints.length, followRoadsEnabled);
                    routeSnapDraft = normalizeRouteSnapDraft(route.snap_settings || {});
                    resetStopHistory();
                    ensureStopsArraySize();
                    editingRouteId = routeId;
                    mapMode = 'stops';
                    updateSteps();
                    updateInstructions();
                    refreshFollowRoadUi();
                    refreshRouteSnapUi();
                    renderMapWaypoints();
                    renderStopsList();
                    window.scrollTo(0, 0);
                }, 200);
            }
        };

        window.deleteRoute = async (routeId) => {
            await fetch(`/api/route/${routeId}`, { method: 'DELETE' });
            await loadRoutes();
        };

        // ==== BUSES ====
        async function loadBuses() {
            const res = await fetch('/api/buses');
            const buses = await res.json();
            renderBuses(buses);
        }

        function renderBuses(buses) {
            const keys = Object.keys(buses).sort((a,b) => parseInt(a)-parseInt(b));
            const container = document.getElementById('busList');
            if (keys.length === 0) {
                container.innerHTML = '<div class="empty">No active transports</div>';
                return;
            }
            // Build table once if not present, else update rows incrementally
            let table = container.querySelector('table');
            if(!table){
                container.innerHTML = '<table><thead><tr><th>Transport</th><th>Latitude</th><th>Longitude</th><th>Last Update</th><th></th></tr></thead><tbody></tbody></table>';
                table = container.querySelector('table');
            }
            const tbody = table.querySelector('tbody');
            const existingRows = new Set(Array.from(tbody.querySelectorAll('tr')).map(r=>r.getAttribute('data-bus')));
            // Add or update rows
            keys.forEach(k=>{
                const b = buses[k];
                let row = tbody.querySelector(`tr[data-bus="${k}"]`);
                if(!row){
                    row = document.createElement('tr');
                    row.setAttribute('data-bus', k);
                    row.innerHTML = `
                        <td><strong>Transport ${k}</strong></td>
                        <td><input class="lat" value="${b.lat}" style="width:140px"></td>
                        <td><input class="lng" value="${b.lng}" style="width:140px"></td>
                        <td class="small muted">${b.lastUpdate || ''}</td>
                        <td class="row-actions"><button class="save ok">Save</button><button class="remove danger">Remove</button></td>
                    `;
                    tbody.appendChild(row);
                    row.querySelector('.save').addEventListener('click', onSaveBus);
                    row.querySelector('.remove').addEventListener('click', onRemoveBus);
                } else {
                    // Skip update if user is editing inputs in this row
                    const activeEl = document.activeElement;
                    if(!(activeEl && row.contains(activeEl))){
                        const latInput = row.querySelector('.lat');
                        const lngInput = row.querySelector('.lng');
                        const lastCell = row.querySelector('.small.muted');
                        if(latInput && String(latInput.value) !== String(b.lat)) latInput.value = b.lat;
                        if(lngInput && String(lngInput.value) !== String(b.lng)) lngInput.value = b.lng;
                        if(lastCell && lastCell.textContent !== (b.lastUpdate||'')) lastCell.textContent = b.lastUpdate || '';
                    }
                }
                existingRows.delete(k);
            });
            // Remove rows for buses no longer present
            existingRows.forEach(k=>{
                const row = tbody.querySelector(`tr[data-bus="${k}"]`);
                if(row){ try{ row.remove(); }catch(e){} }
            });
            // Empty state
            if(tbody.children.length===0){ container.innerHTML = '<div class="empty">No active transports</div>'; }
        }

        async function onSaveBus(e) {
            const row = e.target.closest('tr');
            const busNum = row.getAttribute('data-bus');
            const lat = parseFloat(row.querySelector('.lat').value);
            const lng = parseFloat(row.querySelector('.lng').value);
            if (isNaN(lat) || isNaN(lng)) { alert('Enter valid coordinates'); return; }
            await fetch(`/api/bus/${busNum}`, {
                method: 'POST',
                headers: {'Content-Type':'application/json'},
                body: JSON.stringify({ lat: lat, lng: lng, lastUpdate: new Date().toISOString() })
            });
            await loadBuses();
        }

        async function onRemoveBus(e) {
            const row = e.target.closest('tr');
            const busNum = row.getAttribute('data-bus');
            await fetch(`/api/bus/${busNum}`, { method: 'DELETE' });
            await loadBuses();
        }

        document.getElementById('refreshBtn').addEventListener('click', loadBuses);
        const openAuditLogBtn = document.getElementById('openAuditLogBtn');
        if (openAuditLogBtn) openAuditLogBtn.addEventListener('click', () => activateTab('serverPerf'));
        const openAdminLogBtn = document.getElementById('openAdminLogBtn');
        if (openAdminLogBtn) openAdminLogBtn.addEventListener('click', () => activateTab('adminConsole'));

        const perfRefreshBtn = document.getElementById('perfRefreshBtn');
        if (perfRefreshBtn) perfRefreshBtn.addEventListener('click', loadServerPerformance);
        bindPerfGraphDetailInteractions();
        const auditSaveViewBtn = document.getElementById('auditSaveViewBtn');
        if (auditSaveViewBtn) auditSaveViewBtn.addEventListener('click', () => exportTableView('perfAuditTable', 'audit-log-view'));

        const adminConsoleRefreshBtn = document.getElementById('adminConsoleRefreshBtn');
        if (adminConsoleRefreshBtn) adminConsoleRefreshBtn.addEventListener('click', loadAdminConsole);
        const adminConsoleExportTxtBtn = document.getElementById('adminConsoleExportTxtBtn');
        if (adminConsoleExportTxtBtn) adminConsoleExportTxtBtn.addEventListener('click', () => downloadAdminConsoleExport('txt'));
        const adminConsoleExportJsonBtn = document.getElementById('adminConsoleExportJsonBtn');
        if (adminConsoleExportJsonBtn) adminConsoleExportJsonBtn.addEventListener('click', () => downloadAdminConsoleExport('json'));
        const adminConsoleSaveViewBtn = document.getElementById('adminConsoleSaveViewBtn');
        if (adminConsoleSaveViewBtn) adminConsoleSaveViewBtn.addEventListener('click', () => exportTableView('adminConsoleTable', 'admin-log-view'));

        const perfExportMdBtn = document.getElementById('perfExportMdBtn');
        const perfExportTxtBtn = document.getElementById('perfExportTxtBtn');
        if (perfExportMdBtn) perfExportMdBtn.addEventListener('click', () => downloadPerfExport('md'));
        if (perfExportTxtBtn) perfExportTxtBtn.addEventListener('click', () => downloadPerfExport('txt'));
        if (!CAN_ACCESS_SECURE_ADMIN) {
            if (perfExportMdBtn) { perfExportMdBtn.disabled = true; perfExportMdBtn.title = 'Restricted'; }
            if (perfExportTxtBtn) { perfExportTxtBtn.disabled = true; perfExportTxtBtn.title = 'Restricted'; }
        }
        document.getElementById('clearAllBtn').addEventListener('click', async () => {
            if (!confirm('Clear all transports?')) return;
            await fetch('/api/buses/clear', { method: 'POST' });
            await loadBuses();
        });
        document.getElementById('addBtn').addEventListener('click', async () => {
            const num = document.getElementById('newBusNum').value.trim();
            const lat = parseFloat(document.getElementById('newLat').value);
            const lng = parseFloat(document.getElementById('newLng').value);
            if (!num || isNaN(lat) || isNaN(lng)) { alert('Provide transport number and coords'); return; }
            await fetch(`/api/bus/${num}`, {
                method: 'POST', headers: {'Content-Type':'application/json'},
                body: JSON.stringify({ lat: lat, lng: lng, lastUpdate: new Date().toISOString() })
            });
            document.getElementById('newBusNum').value='';
            document.getElementById('newLat').value='';
            document.getElementById('newLng').value='';
            await loadBuses();
        });

        // Auto-refresh for transports list (paused when SSE connected)
        let busesAutoRefreshId = null;
        let isBusesRefreshing = false;
        let sseConnected = false;
        function startBusesAutoRefresh(){
            stopBusesAutoRefresh();
            busesAutoRefreshId = setInterval(async ()=>{
                const busesTab = document.getElementById('buses');
                const busListEl = document.getElementById('busList');
                if(!busesTab || !busesTab.classList.contains('active')) return;
                if(document.hidden) return;
                if(sseConnected) return; // let SSE drive incremental updates
                if(isBusesRefreshing) return;
                const activeEl = document.activeElement;
                if(activeEl && busListEl && busListEl.contains(activeEl) && (activeEl.tagName==='INPUT' || activeEl.tagName==='BUTTON')) return;
                try{
                    isBusesRefreshing = true;
                    // Soft refresh via incremental update
                    const res = await fetch('/api/buses');
                    const buses = await res.json();
                    renderBuses(buses);
                } finally { isBusesRefreshing = false; }
            }, 6000);
        }
        function stopBusesAutoRefresh(){
            if(busesAutoRefreshId){ try{ clearInterval(busesAutoRefreshId); }catch(e){} busesAutoRefreshId = null; }
        }

        // Initial load and start auto refresh (buses tab is active by default)
        loadBuses();
        startBusesAutoRefresh();
        window.addEventListener('beforeunload', () => {
            stopBusesAutoRefresh();
            stopPerfAutoRefresh();
            stopAdminConsoleAutoRefresh();
        });
        window.addEventListener('resize', () => {
            if (isTabActive('serverPerf')) renderPerfGraphs();
            if (activePerfDetailGraphId) drawPerfDetailGraph();
        });

        // Live updates via SSE
        try{
            const es = new EventSource('/events');
            es.onopen = ()=>{ sseConnected = true; stopBusesAutoRefresh(); };
            es.onmessage = (ev)=>{
                try{
                    const msg = JSON.parse(ev.data);
                    if(msg.type === 'bus_update'){
                        const k = msg.bus; const b = msg.data||{};
                        const table = document.getElementById('busList').querySelector('table');
                        if(table){ renderBuses({ [k]: b }); }
                    } else if(msg.type === 'bus_stop'){
                        const row = document.querySelector(`#busList tr[data-bus="${msg.bus}"]`);
                        if(row) row.remove();
                    } else if(msg.type === 'buses_clear'){
                        document.getElementById('busList').innerHTML = '<div class="empty">No active transports</div>';
                    }
                }catch(e){ /* ignore */ }
            };
            es.onerror = ()=>{ sseConnected = false; startBusesAutoRefresh(); };
        }catch(e){ /* SSE not available, fallback to polling only */ }

        // ==== BUILDINGS MAP ====
        function initBuildingsMap() {
            if (buildingsMap) return;
            const bounds = [[20.339920625677212, 85.7964659296332], [20.37210882553945, 85.83388810783698]];
            buildingsMap = L.map('buildingsMap', { maxBounds: bounds, minZoom: 14 }).setView([20.3549, 85.8161], 15);
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; CARTO',
                maxZoom: 19
            }).addTo(buildingsMap);
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}{r}.png', {
                attribution: '',
                maxZoom: 19
            }).addTo(buildingsMap);

            buildingsMap.on('click', (e) => {
                const lat = e.latlng.lat;
                const lng = e.latlng.lng;
                
                if (pendingHostelName) {
                    addHostelToMap(lat, lng);
                } else if (pendingClassName) {
                    addClassToMap(lat, lng);
                }
            });
            
            renderBuildingMarkers();
        }

        async function addHostelToMap(lat, lng) {
            const name = pendingHostelName;
            const capacity = pendingHostelCapacity || 100;
            
            const res = await fetch('/api/hostel', {
                method: 'POST',
                headers: {'Content-Type':'application/json'},
                body: JSON.stringify({ name, lat, lng, capacity: parseInt(capacity) })
            });
            
            if (res.ok) {
                document.getElementById('hostelName').value = '';
                document.getElementById('hostelCapacity').value = '100';
                pendingHostelName = null;
                pendingHostelCapacity = null;
                document.getElementById('addHostelBtn').textContent = '+ Place on Map';
                document.getElementById('addHostelBtn').style.background = 'rgba(52,211,153,0.1)';
                await loadHostels();
            }
        }

        async function addClassToMap(lat, lng) {
            const name = pendingClassName;
            const department = pendingClassDept || 'Unknown';
            
            const res = await fetch('/api/class', {
                method: 'POST',
                headers: {'Content-Type':'application/json'},
                body: JSON.stringify({ name, lat, lng, department })
            });
            
            if (res.ok) {
                document.getElementById('className').value = '';
                document.getElementById('classDept').value = '';
                pendingClassName = null;
                pendingClassDept = null;
                document.getElementById('addClassBtn').textContent = '+ Place on Map';
                document.getElementById('addClassBtn').style.background = 'rgba(52,211,153,0.1)';
                await loadClasses();
            }
        }

        async function loadHostels() {
            try {
                const res = await fetch('/api/hostels');
                const hostels = await res.json();
                document.getElementById('hostelCount').textContent = hostels.length;
                renderHostelsList(hostels);
            } catch(e) { console.error(e); }
        }

        async function loadClasses() {
            try {
                const res = await fetch('/api/classes');
                const classes = await res.json();
                document.getElementById('classCount').textContent = classes.length;
                renderClassesList(classes);
            } catch(e) { console.error(e); }
        }

        function renderHostelsList(hostels) {
            const container = document.getElementById('hostelsList');
            if (hostels.length === 0) {
                container.innerHTML = '<div class="empty" style="font-size:12px; padding:10px">No hostels yet</div>';
                return;
            }
            
            container.innerHTML = hostels.map(h => `
                <div style="padding:8px; background:#07101a; border-radius:4px; margin-bottom:6px; display:flex; justify-content:space-between; align-items:center; font-size:12px">
                    <div>
                        <div style="font-weight:600">${h.name}</div>
                        <div style="color:#9aa4b2; font-size:11px">${h.capacity} capacity</div>
                    </div>
                    <button onclick="deleteHostel('${h.id}')" style="background:#ff5722; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer; font-size:11px">‚úï</button>
                </div>
            `).join('');
        }

        function renderClassesList(classes) {
            const container = document.getElementById('classesList');
            if (classes.length === 0) {
                container.innerHTML = '<div class="empty" style="font-size:12px; padding:10px">No classes yet</div>';
                return;
            }
            
            container.innerHTML = classes.map(c => `
                <div style="padding:8px; background:#07101a; border-radius:4px; margin-bottom:6px; display:flex; justify-content:space-between; align-items:center; font-size:12px">
                    <div>
                        <div style="font-weight:600">${c.name}</div>
                        <div style="color:#9aa4b2; font-size:11px">${c.department}</div>
                    </div>
                    <button onclick="deleteClass('${c.id}')" style="background:#ff5722; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer; font-size:11px">‚úï</button>
                </div>
            `).join('');
        }

        function renderBuildingMarkers() {
            if (!buildingsMap) return;
            
            Object.values(buildingMarkers).forEach(m => {
                try { buildingsMap.removeLayer(m); } catch(e) {}
            });
            buildingMarkers = {};
            
            fetch('/api/hostels').then(r => r.json()).then(hostels => {
                hostels.forEach(h => {
                    const icon = L.divIcon({ className: 'marker-wrapper', html: '<span class="tiny-marker tiny-hostel"></span>', iconSize:[10,10], iconAnchor:[5,5] });
                    const marker = L.marker([h.lat, h.lng], { icon }).bindPopup(`<b>${h.name}</b><br/>Capacity: ${h.capacity}`).addTo(buildingsMap);
                    buildingMarkers[h.id] = marker;
                });
            });
            
            fetch('/api/classes').then(r => r.json()).then(classes => {
                classes.forEach(c => {
                    const icon = L.divIcon({ className: 'marker-wrapper', html: '<span class="tiny-marker tiny-class"></span>', iconSize:[10,10], iconAnchor:[5,5] });
                    const marker = L.marker([c.lat, c.lng], { icon }).bindPopup(`<b>${c.name}</b><br/>${c.department}`).addTo(buildingsMap);
                    buildingMarkers[c.id] = marker;
                });
            });
        }

        async function deleteHostel(id) {
            await fetch(`/api/hostel/${id}`, { method: 'DELETE' });
            await loadHostels();
            renderBuildingMarkers();
        }

        async function deleteClass(id) {
            await fetch(`/api/class/${id}`, { method: 'DELETE' });
            await loadClasses();
            renderBuildingMarkers();
        }

        document.getElementById('addHostelBtn').addEventListener('click', () => {
            const name = document.getElementById('hostelName').value.trim();
            if (!name) { alert('Enter hostel name'); return; }
            pendingHostelName = name;
            pendingHostelCapacity = document.getElementById('hostelCapacity').value;
            document.getElementById('addHostelBtn').textContent = 'üìç Click on map...';
            document.getElementById('addHostelBtn').style.background = 'rgba(102,126,234,0.2)';
            setTimeout(initBuildingsMap, 100);
        });

        document.getElementById('addClassBtn').addEventListener('click', () => {
            const name = document.getElementById('className').value.trim();
            if (!name) { alert('Enter class name'); return; }
            pendingClassName = name;
            pendingClassDept = document.getElementById('classDept').value;
            document.getElementById('addClassBtn').textContent = 'üìç Click on map...';
            document.getElementById('addClassBtn').style.background = 'rgba(102,126,234,0.2)';
            setTimeout(initBuildingsMap, 100);
        });
    </script>
</body>
</html>
