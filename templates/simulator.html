<!DOCTYPE html>
<html>
<head>
<title>Bus Simulator</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<style>
:root {
  --ui-theme-hue: 0deg;
  --ui-theme-saturation: 120%;
  --bg:#0b0c14;
  --bg-grad-1:rgba(142,105,255,0.34);
  --bg-grad-2:rgba(110,80,228,0.24);
  --text:#eef3ff;
  --text-sub:#a7b0c9;
  --edge:rgba(198,171,255,0.34);
  --glass:linear-gradient(165deg, rgba(255,255,255,0.18), rgba(255,255,255,0.06) 52%, rgba(255,255,255,0.02));
  --glass-soft:linear-gradient(165deg, rgba(255,255,255,0.12), rgba(255,255,255,0.04));
  --ok:#7cf3c0;
  --ok-bg:rgba(124,243,192,0.16);
  --warn:#ffc1d2;
  --warn-bg:rgba(255,130,150,0.15);
}
body {
  margin:0;
  color:var(--text);
  font-family:'Inter','Segoe UI',sans-serif;
  background:
    radial-gradient(circle at 14% 10%, var(--bg-grad-1), transparent 44%),
    radial-gradient(circle at 86% 22%, var(--bg-grad-2), transparent 40%),
    var(--bg);
  filter: hue-rotate(var(--ui-theme-hue)) saturate(var(--ui-theme-saturation));
}
#map { height:100vh; }
.controls {
  position:absolute; top:12px; left:12px;
  padding:16px 18px; border-radius:24px; z-index:1000; min-width:240px;
  border:1px solid var(--edge);
  background-image: var(--glass);
  backdrop-filter:blur(14px) saturate(126%);
  -webkit-backdrop-filter:blur(14px) saturate(126%);
  box-shadow:0 18px 38px rgba(4,10,24,0.34), inset 0 1px 0 rgba(255,255,255,0.16);
}
.controls label { display:block; font-size:12px; color:var(--text-sub); margin-top:8px; }
.controls select, .controls input[type=number] {
  width:100%; padding:7px 10px; border-radius:12px; border:1px solid var(--edge);
  background-image:var(--glass-soft); color:var(--text); font-size:13px; margin-top:2px;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.14);
}
.controls input[type=range] { width:100%; margin-top:2px; }
.speed-row { display:flex; align-items:center; gap:8px; margin-top:4px; }
.speed-row input[type=range] { flex:1; min-width:0; }
.speed-row input[type=number] {
  width:64px; flex:none; padding:4px 6px; border-radius:12px;
  color:var(--ok); font-size:13px; font-weight:600; text-align:center;
  -moz-appearance:textfield;
  appearance:textfield;
}
.speed-row input[type=number]::-webkit-inner-spin-button,
.speed-row input[type=number]::-webkit-outer-spin-button { opacity:1; }
.speed-unit { font-size:11px; color:var(--text-sub); opacity:.72; flex:none; }
.keys-hint { font-size:11px; color:var(--text-sub); margin-top:10px; line-height:1.6; }
.keys-hint kbd {
  background:rgba(255,255,255,0.12); padding:2px 6px; border-radius:8px;
  border:1px solid rgba(212,192,255,0.36); font-family:monospace; font-size:11px;
}
.status-dot { display:inline-block; width:6px; height:6px; border-radius:50%; background:#34d399; margin-right:6px;
  box-shadow:0 0 6px rgba(52,211,153,0.5); }
#syncStatus { font-size:11px; color:var(--text-sub); margin-top:8px; }
#startBtn {
  width:100%; margin-top:12px; padding:9px 0; border:1px solid rgba(124,243,192,0.42); border-radius:999px;
  background:linear-gradient(160deg, var(--ok-bg), rgba(124,243,192,0.07));
  color:var(--ok); font-size:13px; font-weight:600;
  cursor:pointer; transition:all 0.2s;
}
#startBtn:hover:not(:disabled) { transform:translateY(-1px); filter:brightness(1.06); }
#startBtn:disabled { opacity:0.35; cursor:not-allowed; }
#startBtn.running { border-color:rgba(255,130,150,0.45); background:linear-gradient(160deg, var(--warn-bg), rgba(255,130,150,0.08)); color:var(--warn); }
#startBtn.running:hover { filter:brightness(1.06); }
.aligner-toggle {
  display:flex; align-items:center; gap:8px; margin-top:10px;
  padding:8px 10px; border-radius:14px;
  background-image:var(--glass-soft); border:1px solid var(--edge);
}
.aligner-toggle input[type=checkbox] { accent-color:#667eea; width:16px; height:16px; cursor:pointer; }
.aligner-toggle label { font-size:12px; color:var(--text-sub); cursor:pointer; flex:1; }
.aligner-toggle .aligner-badge {
  font-size:10px; padding:2px 6px; border-radius:999px;
  background:rgba(140,115,255,0.20); color:#d8ccff; font-weight:600;
}
.aligner-toggle.active { border-color:rgba(161,140,255,0.54); background:rgba(140,115,255,0.14); }
.aligner-toggle.active .aligner-badge { background:rgba(140,115,255,0.32); }
.auto-follow-panel {
  margin-top:8px; padding:8px 10px; border-radius:14px; display:none;
  background:rgba(124,243,192,0.10); border:1px solid rgba(124,243,192,0.30);
}
.auto-follow-panel.visible { display:block; }
.auto-follow-row { display:flex; align-items:center; gap:8px; }
#autoFollowBtn {
  flex:1; border:1px solid rgba(124,243,192,0.40); border-radius:999px; padding:7px 8px;
  background:linear-gradient(160deg, var(--ok-bg), rgba(124,243,192,0.07)); color:var(--ok); font-size:12px; font-weight:600;
  cursor:pointer; transition:all 0.2s;
}
#autoFollowBtn:hover:not(:disabled) { transform:translateY(-1px); filter:brightness(1.06); }
#autoFollowBtn:disabled { opacity:0.45; cursor:not-allowed; }
#autoFollowBtn.running { border-color:rgba(159,143,255,0.44); background:rgba(140,115,255,0.20); color:#ddd4ff; }
.dir-toggle {
  display:inline-flex; border:1px solid var(--edge); border-radius:999px; overflow:hidden;
}
.dir-btn {
  border:none; padding:7px 8px; min-width:72px;
  background:rgba(255,255,255,0.08); color:var(--text-sub); font-size:11px; cursor:pointer; transition:all 0.2s;
}
.dir-btn + .dir-btn { border-left:1px solid var(--edge); }
.dir-btn.active { background:rgba(140,115,255,0.26); color:#e4dbff; }
.dir-btn:disabled { opacity:0.45; cursor:not-allowed; }
.auto-follow-hint { margin-top:6px; font-size:10px; color:var(--text-sub); }
.load-sim-panel {
  margin-top:10px; padding:8px 10px; border-radius:14px;
  background:rgba(140,115,255,0.10); border:1px solid rgba(140,115,255,0.28);
}
.load-sim-panel label { margin-top:0; }
#loadSimCount {
  margin-top:4px; width:100%; box-sizing:border-box;
  padding:6px 8px; border-radius:12px; border:1px solid var(--edge);
  background-image:var(--glass-soft); color:var(--text); font-size:13px;
}
.load-sim-row { display:flex; align-items:center; gap:8px; margin-top:8px; }
#startLoadSimBtn, #stopLoadSimBtn {
  flex:1; border:1px solid var(--edge); border-radius:999px; padding:7px 8px;
  font-size:12px; font-weight:600; cursor:pointer; transition:all 0.2s;
}
#startLoadSimBtn {
  border-color:rgba(124,243,192,0.40);
  background:linear-gradient(160deg, var(--ok-bg), rgba(124,243,192,0.07)); color:var(--ok);
}
#startLoadSimBtn:hover:not(:disabled) { transform:translateY(-1px); filter:brightness(1.06); }
#stopLoadSimBtn {
  border-color:rgba(255,130,150,0.42);
  background:linear-gradient(160deg, var(--warn-bg), rgba(255,130,150,0.08)); color:var(--warn);
}
#stopLoadSimBtn:hover:not(:disabled) { transform:translateY(-1px); filter:brightness(1.06); }
#startLoadSimBtn:disabled, #stopLoadSimBtn:disabled {
  opacity:0.45; cursor:not-allowed;
}
#loadSimStatus {
  margin-top:6px; font-size:11px; color:var(--text-sub);
}
#studentSimPanel {
  border-radius: 20px !important;
  border: 1px solid var(--edge) !important;
  background: linear-gradient(165deg, rgba(136, 104, 240, 0.22), rgba(58, 45, 104, 0.26)) !important;
  box-shadow: 0 16px 34px rgba(4,10,24,0.30), inset 0 1px 0 rgba(255,255,255,0.12) !important;
  backdrop-filter: blur(14px) saturate(124%) !important;
}
#studentSimPanel #studentSimZone {
  background-image: var(--glass-soft) !important;
  border: 1px solid var(--edge) !important;
  border-radius: 12px !important;
}
/* Solid theme overrides (no transparent/glass surfaces) */
body {
  background: #0b0c14 !important;
}
.controls {
  background: #121a2d !important;
  border: 1px solid #2b3b58 !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
  box-shadow: 0 10px 24px rgba(4, 10, 24, 0.48) !important;
}
.controls select,
.controls input[type=number],
#loadSimCount,
#studentSimPanel #studentSimZone {
  background: #0b1220 !important;
  color: #e6eef8 !important;
  border-color: #2b3b58 !important;
}
.controls select option,
#studentSimPanel #studentSimZone option {
  background: #0b1220 !important;
  color: #e6eef8 !important;
}
.keys-hint kbd {
  background: #1a253b !important;
  border-color: #2b3b58 !important;
  color: #dbeafe !important;
}
.aligner-toggle,
.auto-follow-panel,
.load-sim-panel {
  background: #101a2d !important;
  border-color: #2b3b58 !important;
}
.dir-btn {
  background: #131f33 !important;
  color: #c6d1e5 !important;
}
.dir-btn + .dir-btn {
  border-left-color: #2b3b58 !important;
}
.dir-btn.active {
  background: #22314d !important;
  color: #eef3ff !important;
}
#studentSimPanel {
  background: #171032 !important;
  border: 1px solid #4a3a7c !important;
  box-shadow: 0 10px 26px rgba(10, 4, 28, 0.55) !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
}
#studentSimInfo {
  background: #1d1a3a !important;
  color: #c9bcff !important;
}
.leaflet-control-zoom a {
  background: #111c2e !important;
  color: #e6eef8 !important;
  border-color: #2b3b58 !important;
}
.leaflet-popup-content-wrapper,
.leaflet-popup-tip {
  background: #111c2e !important;
  color: #e6eef8 !important;
  border: 1px solid #2b3b58 !important;
}
</style>
</head>
<body>

<div class="controls">
  <div style="font-weight:600; font-size:14px; margin-bottom:6px;">Bus Simulator</div>

      <label>Bus Number
    <select id="busSelect"><option value="" selected>- Select Bus -</option></select>
  </label>

  <label>Route
    <select id="routeSelect"><option value="" selected>- Select Route -</option></select>
  </label>

  <label>Speed (km/h)
    <div class="speed-row">
      <input type="range" id="speedSlider" min="1" max="200" step="1" value="50"/>
      <input type="number" id="customSpeed" min="1" max="200" step="1" value="50"/>
      <span class="speed-unit">km/h</span>
    </div>
  </label>

  <div class="keys-hint">
    <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> to drive<br>
    <kbd>Shift</kbd> to boost &nbsp; <kbd>Space</kbd> to brake<br>
    <span style="color:#667eea">Aligner:</span> <kbd>W</kbd> forward - <kbd>S</kbd> reverse - <kbd>Space</kbd> brake
  </div>

  <div class="aligner-toggle" id="alignerToggle">
    <input type="checkbox" id="alignerCheck"/>
    <label for="alignerCheck">Aligner - lock to route track</label>
    <span class="aligner-badge">OFF</span>
  </div>

  <div class="auto-follow-panel" id="autoFollowPanel">
    <div class="auto-follow-row">
      <button id="autoFollowBtn" type="button">Auto Follow OFF</button>
      <div class="dir-toggle" role="group" aria-label="Auto follow direction">
        <button id="dirForwardBtn" class="dir-btn active" type="button">Forward</button>
        <button id="dirReverseBtn" class="dir-btn" type="button">Backward</button>
      </div>
    </div>
    <div class="auto-follow-hint">Starts at 12 km/h. Use speed bar to adjust.</div>
  </div>

  <div id="syncStatus"><span class="status-dot" style="background:#667"></span>Waiting to start...</div>
  <div id="updateStats" style="font-size:11px; color:#9aa4b2; margin-top:4px; display:flex; justify-content:space-between">
    <span>Sent: <span id="updateCount" style="color:#34d399;font-weight:600">0</span></span>
    <span>Last: <span id="lastUpdateTime" style="color:#667eea">-</span></span>
  </div>
  <button id="startBtn" disabled>Select bus & route first</button>

  <div class="load-sim-panel">
    <div style="font-weight:700; font-size:13px; color:#c7d2fe; margin-bottom:6px;">Transport Simulator</div>
    <label for="loadSimCount">Transport Count</label>
    <input type="number" id="loadSimCount" min="1" max="50" step="1" value="20"/>
    <div class="load-sim-row">
      <button id="startLoadSimBtn" type="button">Start Load Simulation</button>
      <button id="stopLoadSimBtn" type="button" disabled>Stop Simulation</button>
    </div>
    <div id="loadSimStatus">Load simulation idle</div>
  </div>

  <!-- Student Activity Simulation Panel -->
  <div id="studentSimPanel" style="margin-top:18px; border-radius:18px; background:rgba(40,20,60,0.32); box-shadow:0 4px 32px 0 rgba(102,126,234,0.18),0 1.5px 8px 0 rgba(102,0,255,0.08); border:1.5px solid rgba(180,120,255,0.18); backdrop-filter:blur(18px); padding:18px 18px 14px 18px; position:relative; overflow:hidden;">
    <div style="font-weight:700; font-size:15px; color:#e0d6ff; margin-bottom:8px; letter-spacing:0.01em;">Student Activity Simulation</div>
    <div style="display:flex; align-items:center; gap:12px; margin-bottom:10px;">
      <label style="flex:1; display:flex; align-items:center; gap:8px;">
        <span style="font-size:13px; color:#b7aaff;">Enable Simulation</span>
        <input type="checkbox" id="studentSimEnable" style="accent-color:#a78bfa; width:20px; height:20px; margin-left:4px;">
      </label>
      <span id="studentSimInfo" style="font-size:11px; color:#a78bfa; background:rgba(102,126,234,0.13); border-radius:6px; padding:2px 8px;">Simulated student demand activity</span>
    </div>
    <div style="margin-bottom:10px;">
      <label style="font-size:12px; color:#b7aaff;">Active Students
        <input type="range" id="studentSimCount" min="0" max="500" value="120" style="width:100%; margin-top:2px;">
      </label>
      <div style="font-size:11px; color:#a78bfa; margin-top:2px;">Max 200 visible</div>
    </div>
    <div style="margin-bottom:10px;">
      <label style="font-size:12px; color:#b7aaff;">Movement Speed
        <input type="range" id="studentSimSpeed" min="1" max="10" value="4" style="width:100%; margin-top:2px;">
      </label>
    </div>
    <div style="margin-bottom:10px;">
      <label style="font-size:12px; color:#b7aaff;">Primary Demand Zone
        <select id="studentSimZone" style="width:100%; margin-top:2px; background:#1a1330; color:#e6eef8; border-radius:7px; border:1px solid #a78bfa;">
          <option value="hostels">Hostels</option>
          <option value="classes">Classes</option>
          <option value="mixed" selected>Mixed</option>
        </select>
      </label>
    </div>
    <div style="display:flex; align-items:center; gap:10px; margin-top:8px;">
      <span style="font-size:12px; color:#b7aaff;">Simulated viewers:</span>
      <span id="studentSimViewerCount" style="font-size:15px; color:#fff; font-weight:700; text-shadow:0 0 8px #a78bfa;">0</span>
    </div>
  </div>
</div>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
function normalizeThemeHexColor(value){
  let hex = String(value || '').trim();
  if(/^#[0-9a-fA-F]{3}$/.test(hex)){
    hex = '#' + hex.slice(1).split('').map(ch => ch + ch).join('');
  }
  if(!/^#[0-9a-fA-F]{6}$/.test(hex)) return '#8b64ff';
  return `#${hex.slice(1).toLowerCase()}`;
}
function clampThemeSaturation(value){
  const n = Number(value);
  if(!Number.isFinite(n)) return 120;
  return Math.max(20, Math.min(260, Math.round(n)));
}
function hexToRgb(hex){
  const clean = normalizeThemeHexColor(hex).slice(1);
  return {
    r: parseInt(clean.slice(0, 2), 16),
    g: parseInt(clean.slice(2, 4), 16),
    b: parseInt(clean.slice(4, 6), 16),
  };
}
function rgbToHue(r, g, b){
  const rn = r / 255;
  const gn = g / 255;
  const bn = b / 255;
  const max = Math.max(rn, gn, bn);
  const min = Math.min(rn, gn, bn);
  const d = max - min;
  if(d === 0) return 0;
  let h;
  if(max === rn) h = ((gn - bn) / d) % 6;
  else if(max === gn) h = ((bn - rn) / d) + 2;
  else h = ((rn - gn) / d) + 4;
  return ((h * 60) + 360) % 360;
}
function applyGlobalTheme(theme){
  const accentRgb = hexToRgb(theme && theme.accent_color);
  const baseRgb = hexToRgb('#8b64ff');
  const hueDelta = rgbToHue(accentRgb.r, accentRgb.g, accentRgb.b) - rgbToHue(baseRgb.r, baseRgb.g, baseRgb.b);
  const saturation = clampThemeSaturation(theme && theme.saturation);
  document.documentElement.style.setProperty('--ui-theme-hue', `${hueDelta.toFixed(1)}deg`);
  document.documentElement.style.setProperty('--ui-theme-saturation', `${saturation}%`);
}
async function loadGlobalTheme(){
  try{
    const res = await fetch('/api/ui-theme', { cache: 'no-store' });
    const data = await res.json();
    if(!res.ok) throw new Error(data.error || 'theme_load_failed');
    applyGlobalTheme(data);
  }catch(e){
    applyGlobalTheme({ accent_color: '#8b64ff', saturation: 120 });
  }
}
const THEME_BROADCAST_KEY = 'kiit_ui_theme_broadcast_v1';
window.addEventListener('storage', (e) => {
  if(!e || e.key !== THEME_BROADCAST_KEY || !e.newValue) return;
  try{
    const payload = JSON.parse(e.newValue);
    applyGlobalTheme(payload || {});
  }catch(err){}
});
loadGlobalTheme();

function getSystemSimControls() {
  return {
    startBtn: document.getElementById('systemSimStartBtn'),
    stopBtn: document.getElementById('systemSimStopBtn'),
    driverInput: document.getElementById('systemSimDriverCount'),
    studentInput: document.getElementById('systemSimStudentCount'),
  };
}

document.addEventListener('DOMContentLoaded', () => {
  const { startBtn, stopBtn, driverInput, studentInput } = getSystemSimControls();
  if (!startBtn || !stopBtn || !driverInput || !studentInput) return;

  startBtn.addEventListener('click', async () => {
    if (systemSimRunning) return;
    const driverCount = Math.max(1, Math.min(100, parseInt(driverInput.value, 10) || 20));
    const studentCount = Math.max(1, Math.min(500, parseInt(studentInput.value, 10) || 100));
    setSystemSimStatus('Starting simulation...', true);
    systemSimRunning = true;
    await startSystemDriverSimulation(driverCount);
    startSystemStudentSimulation(studentCount);
    setSystemSimStatus(`Running: ${driverCount} drivers, ${studentCount} students`, true);
  });

  stopBtn.addEventListener('click', () => {
    if (!systemSimRunning) return;
    setSystemSimStatus('Stopping simulation...', false);
    systemSimRunning = false;
    stopSystemDriverSimulation();
    stopSystemStudentSimulation();
    setSystemSimStatus('Idle', false);
  });
});

function startSystemStudentSimulation(studentCount) {
  for (let i = 0; i < studentCount; i++) {
    const busInterval = setInterval(() => {
      fetch('/api/buses').catch(() => {});
      if (Math.random() < 0.15) fetch('/api/routes').catch(() => {});
      if (Math.random() < 0.05) {
        try {
          const es = new EventSource('/events');
          setTimeout(() => es.close(), 1000 + Math.random() * 2000);
        } catch (e) {}
      }
    }, 3000 + Math.floor(Math.random() * 2000));
    systemSimStudentIntervals.push(busInterval);
  }
}

function stopSystemStudentSimulation() {
  for (const interval of systemSimStudentIntervals) clearInterval(interval);
  systemSimStudentIntervals = [];
}

// --- Student Simulation Layer ---
let studentSimLayer = null;
let studentSimDots = [];
let studentSimEnabled = false;
let studentSimCount = 120;
let studentSimSpeed = 4;
let studentSimZone = 'mixed';
let studentSimDemandZones = { hostels: [], classes: [] };
let studentSimLastUpdate = 0;
let studentSimDotColors = ['#a78bfa','#f472b6','#60a5fa','#fbbf24','#34d399','#f87171'];

function getRandomZoneLatLng(zone) {
  const arr = studentSimDemandZones[zone];
  if (!arr.length) return null;
  const idx = Math.floor(Math.random() * arr.length);
  const base = arr[idx];
  // Add small random offset (within ~60m)
  const lat = base[0] + (Math.random()-0.5)*0.0005;
  const lng = base[1] + (Math.random()-0.5)*0.0005;
  return [lat, lng];
}

function createStudentSimDots(n) {
  const dots = [];
  for (let i = 0; i < n; i++) {
    const zone = studentSimZone === 'mixed' ? (Math.random()<0.5?'hostels':'classes') : studentSimZone;
    const pos = getRandomZoneLatLng(zone) || [lat, lng];
    dots.push({
      lat: pos[0],
      lng: pos[1],
      zone,
      color: studentSimDotColors[i%studentSimDotColors.length],
      speed: 0.00005 + Math.random()*0.00012*studentSimSpeed,
      angle: Math.random()*2*Math.PI,
      pulse: Math.random()*Math.PI*2,
      cluster: Math.random()<0.25,
      fade: 0,
      viewing: Math.random()<0.1
    });
  }
  return dots;
}

function updateStudentSimDots() {
  // Animate movement and pulsing
  for (const dot of studentSimDots) {
    // Cluster some dots near stops
    if (dot.cluster && studentSimDemandZones[dot.zone].length) {
      const base = studentSimDemandZones[dot.zone][Math.floor(Math.random()*studentSimDemandZones[dot.zone].length)];
      dot.lat += (base[0]-dot.lat)*0.02 + (Math.random()-0.5)*0.00005;
      dot.lng += (base[1]-dot.lng)*0.02 + (Math.random()-0.5)*0.00005;
    } else {
      dot.lat += Math.cos(dot.angle)*dot.speed*(0.5+Math.random());
      dot.lng += Math.sin(dot.angle)*dot.speed*(0.5+Math.random());
      if (Math.random()<0.04) dot.angle += (Math.random()-0.5)*0.7;
    }
    dot.pulse += 0.08 + Math.random()*0.04;
    dot.fade = Math.min(dot.fade+0.08, 1);
    // Simulate "viewing bus" event
    if (Math.random()<0.002) dot.viewing = !dot.viewing;
  }
}

function renderStudentSimDots() {
  if (!studentSimLayer) return;
  studentSimLayer.clearLayers();
  const maxDots = Math.min(studentSimDots.length, 200);
  for (let i = 0; i < maxDots; i++) {
    const dot = studentSimDots[i];
    const r = 6 + 3*Math.sin(dot.pulse);
    const opacity = 0.45 + 0.45*Math.sin(dot.pulse);
    const color = dot.viewing ? '#fff' : dot.color;
    const glow = dot.viewing ? '0 0 16px #fff, 0 0 8px #a78bfa' : `0 0 8px ${dot.color}`;
    const circle = L.circleMarker([dot.lat, dot.lng], {
      radius: r,
      color: color,
      fillColor: color,
      fillOpacity: 0.18 + 0.5*Math.abs(Math.sin(dot.pulse)),
      opacity: opacity,
      weight: 2,
      interactive: false
    });
    circle._path && (circle._path.style.filter = `drop-shadow(${glow})`);
    studentSimLayer.addLayer(circle);
  }
  document.getElementById('studentSimViewerCount').textContent = maxDots;
}

function studentSimAnimationLoop(now) {
  if (!studentSimEnabled) return;
  if (now-studentSimLastUpdate > 500) {
    updateStudentSimDots();
    renderStudentSimDots();
    studentSimLastUpdate = now;
  }
  requestAnimationFrame(studentSimAnimationLoop);
}

function setStudentSimEnabled(val) {
  studentSimEnabled = val;
  if (val) {
    if (!studentSimLayer) {
      studentSimLayer = L.layerGroup().addTo(map);
      if (typeof studentSimLayer.setZIndex === 'function') {
        studentSimLayer.setZIndex(500);
      }
    }
    studentSimDots = createStudentSimDots(studentSimCount);
    renderStudentSimDots();
    studentSimLastUpdate = performance.now();
    requestAnimationFrame(studentSimAnimationLoop);
  } else {
    if (studentSimLayer) studentSimLayer.clearLayers();
    document.getElementById('studentSimViewerCount').textContent = '0';
  }
}

function updateStudentSimDemandZones() {
  // Use hostel/class locations from admin panel logic if available
  fetch('/api/hostels').then(r=>r.json()).then(hostels=>{
    studentSimDemandZones.hostels = hostels.map(h=>[h.lat,h.lng]);
  });
  fetch('/api/classes').then(r=>r.json()).then(classes=>{
    studentSimDemandZones.classes = classes.map(c=>[c.lat,c.lng]);
  });
}

document.addEventListener('DOMContentLoaded',()=>{
  updateStudentSimDemandZones();
  const enable = document.getElementById('studentSimEnable');
  const count = document.getElementById('studentSimCount');
  const speed = document.getElementById('studentSimSpeed');
  const zone = document.getElementById('studentSimZone');
  enable.addEventListener('change',()=>{
    setStudentSimEnabled(enable.checked);
  });
  count.addEventListener('input',()=>{
    studentSimCount = parseInt(count.value,10)||0;
    if (studentSimEnabled) {
      studentSimDots = createStudentSimDots(studentSimCount);
      renderStudentSimDots();
    }
  });
  speed.addEventListener('input',()=>{
    studentSimSpeed = parseInt(speed.value,10)||1;
    if (studentSimEnabled) {
      for (const dot of studentSimDots) dot.speed = 0.00005 + Math.random()*0.00012*studentSimSpeed;
    }
  });
  zone.addEventListener('change',()=>{
    studentSimZone = zone.value;
    if (studentSimEnabled) {
      studentSimDots = createStudentSimDots(studentSimCount);
      renderStudentSimDots();
    }
  });
});
// --- End Student Simulation Layer ---

// --- System Load Simulation Logic ---
let systemSimDriverIntervals = [];
let systemSimStudentIntervals = [];
let systemSimActiveBusNumbers = [];
let systemSimRunning = false;
let systemSimRoutesCache = [];

function setSystemSimStatus(msg, running) {
  const statusEl = document.getElementById('systemSimStatus');
  const startBtn = document.getElementById('systemSimStartBtn');
  const stopBtn = document.getElementById('systemSimStopBtn');
  if (statusEl) statusEl.textContent = msg;
  if (startBtn) startBtn.disabled = !!running;
  if (stopBtn) stopBtn.disabled = !running;
}

async function startSystemDriverSimulation(driverCount) {
  // Fetch routes once for all drivers
  let routes = systemSimRoutesCache;
  if (!routes.length) {
    try {
      const res = await fetch('/api/routes');
      routes = await res.json();
      systemSimRoutesCache = routes;
    } catch (e) { setSystemSimStatus('Failed to fetch routes', false); return; }
  }
  for (let i = 0; i < driverCount; i++) {
    const busNumber = 100 + i;
    const route = routes[Math.floor(Math.random()*routes.length)];
    if (!route || !route.waypoints || route.waypoints.length < 2) continue;
    const waypoints = route.waypoints;
    let segIdx = 0, t = 0;
    let direction = 1;
    let lat = waypoints[0][0], lng = waypoints[0][1];
    let heading = 0;
    systemSimActiveBusNumbers.push(busNumber);
    // Assign route
    fetch(`/api/bus/${busNumber}/route`, {
      method: 'POST', headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ routeId: route.id })
    }).catch(()=>{});
    // Movement interval
    const interval = setInterval(() => {
      // Move along waypoints
      const a = waypoints[segIdx], b = waypoints[segIdx+1];
      if (!a || !b) return;
      const segDx = b[0]-a[0], segDy = b[1]-a[1];
      const segLen = Math.sqrt(segDx*segDx + segDy*segDy);
      const speed = 0.00012; // slow, realistic
      t += speed;
      if (t >= 1) { t = 0; segIdx++; if (segIdx >= waypoints.length-1) { segIdx = 0; } }
      lat = a[0] + t*(b[0]-a[0]);
      lng = a[1] + t*(b[1]-a[1]);
      heading = Math.atan2(b[1]-a[1], b[0]-a[0]) * 180/Math.PI;
      // Send update
      fetch(`/api/bus/${busNumber}`, {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ lat, lng, heading, lastUpdate: new Date().toISOString() })
      }).catch(()=>{});
    }, 2000 + Math.floor(Math.random()*400)); // randomize a bit
    systemSimDriverIntervals.push(interval);
  }
}

function stopSystemDriverSimulation() {
  for (const interval of systemSimDriverIntervals) clearInterval(interval);
  systemSimDriverIntervals = [];
  // Delete all simulated buses
  for (const busNumber of systemSimActiveBusNumbers) {
    fetch(`/api/bus/${busNumber}`, { method: 'DELETE' }).catch(()=>{});
  }
  systemSimActiveBusNumbers = [];
}
// --- Gamepad Status Indicator ---
let gamepadStatusEl = document.createElement('div');
gamepadStatusEl.style.cssText = 'position:absolute;top:8px;right:8px;background:rgba(18,24,38,0.92);color:#34d399;padding:6px 12px;border-radius:8px;font-size:13px;z-index:1001;border:1px solid #34d399;';
gamepadStatusEl.textContent = 'Controller: Not Connected';
document.body.appendChild(gamepadStatusEl);

const GAMEPAD_API_AVAILABLE =
    typeof navigator.getGamepads === 'function' ||
    typeof navigator.webkitGetGamepads === 'function';
const GAMEPAD_ALLOWED_CONTEXT = window.isSecureContext || location.hostname === 'localhost' || location.hostname === '127.0.0.1';

if (!GAMEPAD_API_AVAILABLE) {
    gamepadStatusEl.style.borderColor = '#fb7185';
    gamepadStatusEl.style.color = '#fb7185';
    gamepadStatusEl.textContent = 'Controller: Not Supported';
} else if (!GAMEPAD_ALLOWED_CONTEXT) {
    gamepadStatusEl.style.borderColor = '#f59e0b';
    gamepadStatusEl.style.color = '#f59e0b';
    gamepadStatusEl.textContent = 'Controller: HTTPS Required';
}

function getGamepadsSafe() {
    try {
        if (typeof navigator.getGamepads === 'function') return navigator.getGamepads() || [];
        if (typeof navigator.webkitGetGamepads === 'function') return navigator.webkitGetGamepads() || [];
    } catch (e) {}
    return [];
}

function getButtonValue(pad, index) {
    const btn = pad && pad.buttons ? pad.buttons[index] : null;
    return btn && typeof btn.value === 'number' ? Math.max(0, Math.min(1, btn.value)) : 0;
}

function getAxisValue(pad, index) {
    const axis = pad && pad.axes ? pad.axes[index] : null;
    return typeof axis === 'number' ? axis : 0;
}

function axisToTrigger(axisValue) {
    return Math.max(0, Math.min(1, (axisValue + 1) / 2));
}

function getTriggerValue(pad, primaryButton, fallbackAxes) {
    let value = getButtonValue(pad, primaryButton);
    if (value > 0) return value;
    for (const axisIdx of fallbackAxes) {
        value = Math.max(value, axisToTrigger(getAxisValue(pad, axisIdx)));
    }
    return value;
}

// --- Efficient Gamepad Panel Update ---
let lastGamepadPanel = '';
let lastGamepadPanelTime = 0;
function renderGamepadPanel(eager) {
    // Only update at most every 80ms unless forced (eager=true)
    const now = performance.now();
    if (!eager && now - lastGamepadPanelTime < 80) return;
    lastGamepadPanelTime = now;
    let html = '';
    if (!GAMEPAD_API_AVAILABLE) {
        gamepadStatusEl.innerHTML = `<b style='color:#fb7185;font-size:13px;'>Controller API not supported</b>`;
        return;
    }
    if (!GAMEPAD_ALLOWED_CONTEXT) {
        gamepadStatusEl.innerHTML = `<b style='color:#f59e0b;font-size:13px;'>Controller requires HTTPS</b>`;
        return;
    }
    const pads = getGamepadsSafe();
    let pad = null;
    for (let i = 0; i < pads.length; i++) {
        if (pads[i]) { pad = pads[i]; break; }
    }
    if (pad) {
        // Show only RT, LT, and left stick axes
        const RT = getTriggerValue(pad, 7, [5, 2]);
        const LT = getTriggerValue(pad, 6, [4, 3]);
        const LX = getAxisValue(pad, 0).toFixed(2);
        const LY = getAxisValue(pad, 1).toFixed(2);
        html += `<b style='color:#34d399;font-size:13px;'>Controller</b><br>`;
        html += `<span style='font-size:12px;color:#9aa4b2;'>RT: <b style='color:#34d399;'>${RT.toFixed(2)}</b> &nbsp; LT: <b style='color:#34d399;'>${LT.toFixed(2)}</b></span><br>`;
        html += `<span style='font-size:12px;color:#9aa4b2;'>L-Stick: <b style='color:#34d399;'>X:${LX} Y:${LY}</b></span>`;
    } else {
        html += `<b style='color:#fb7185;font-size:13px;'>No Controller</b>`;
    }
    if (html !== lastGamepadPanel) {
        gamepadStatusEl.innerHTML = html;
        lastGamepadPanel = html;
    }
}

// Update panel at most every 80ms, not every frame
setInterval(() => renderGamepadPanel(false), 80);
// Also update eagerly on connect/disconnect
window.addEventListener('gamepadconnected', () => renderGamepadPanel(true));
window.addEventListener('gamepaddisconnected', () => renderGamepadPanel(true));

// --- State ---
let lat = 20.3549, lng = 85.8161;
let bus = null;
let currentRouteId = null;
let simRunning = false;
const DEFAULT_MAP_ZOOM = 17;

// Physics
const BOOST = 2.5;           // shift multiplier
const GAMEPAD_DUAL_TRIGGER_BOOST = 3; // LT + RT multiplier

// --- Aligner state ---
let alignerEnabled = false;
let alignerRouteCoords = null; // [[lat,lng], ...] from OSRM
let alignerSegIdx = 0;         // current segment index on route
let alignerT = 0;              // fractional progress along current segment (0..1)
let alignerMoving = false;     // true while W is held
let autoFollowEnabled = false; // automatic route following
let autoFollowDirection = 1;   // 1 = forward, -1 = backward

// Aligner UI
const alignerCheck = document.getElementById('alignerCheck');
const alignerToggleEl = document.getElementById('alignerToggle');
const alignerBadge = alignerToggleEl.querySelector('.aligner-badge');
const autoFollowPanel = document.getElementById('autoFollowPanel');
const autoFollowBtn = document.getElementById('autoFollowBtn');
const dirForwardBtn = document.getElementById('dirForwardBtn');
const dirReverseBtn = document.getElementById('dirReverseBtn');

function refreshAutoFollowUI() {
  const showPanel = alignerEnabled;
  const routeReady = !!(alignerRouteCoords && alignerRouteCoords.length >= 2);
  const canRun = showPanel && routeReady;

  autoFollowPanel.classList.toggle('visible', showPanel);
  if (!canRun) autoFollowEnabled = false;

  autoFollowBtn.disabled = !canRun;
  autoFollowBtn.classList.toggle('running', autoFollowEnabled);
  autoFollowBtn.textContent = autoFollowEnabled ? 'Auto Follow ON' : 'Auto Follow OFF';

  dirForwardBtn.disabled = !canRun;
  dirReverseBtn.disabled = !canRun;
  dirForwardBtn.classList.toggle('active', autoFollowDirection === 1);
  dirReverseBtn.classList.toggle('active', autoFollowDirection === -1);
}

function setAutoFollowDirection(dir) {
  autoFollowDirection = dir >= 0 ? 1 : -1;
  refreshAutoFollowUI();
}

autoFollowBtn.addEventListener('click', () => {
  if (!alignerEnabled || !alignerRouteCoords || alignerRouteCoords.length < 2) return;
  autoFollowEnabled = !autoFollowEnabled;
  if (autoFollowEnabled) setSpeed(12);
  refreshAutoFollowUI();
});
dirForwardBtn.addEventListener('click', () => setAutoFollowDirection(1));
dirReverseBtn.addEventListener('click', () => setAutoFollowDirection(-1));

alignerCheck.addEventListener('change', () => {
  alignerEnabled = alignerCheck.checked;
  alignerToggleEl.classList.toggle('active', alignerEnabled);
  alignerBadge.textContent = alignerEnabled ? 'ON' : 'OFF';
  if (!alignerEnabled) autoFollowEnabled = false;
  if (alignerEnabled && alignerRouteCoords && alignerRouteCoords.length >= 2) {
    snapToNearestRoutePoint();
  }
  refreshAutoFollowUI();
});

function calcDist(lat1, lng1, lat2, lng2) {
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLng = (lng2 - lng1) * Math.PI / 180;
  const x = dLng * Math.cos((lat1 + lat2) * 0.5 * Math.PI / 180);
  return 6371000 * Math.sqrt(dLat * dLat + x * x);
}

function snapToNearestRoutePoint() {
  if (!alignerRouteCoords || alignerRouteCoords.length < 2) return;
  let bestDist = Infinity, bestSeg = 0, bestT = 0;
  for (let i = 0; i < alignerRouteCoords.length - 1; i++) {
    const a = alignerRouteCoords[i], b = alignerRouteCoords[i + 1];
    // Project point onto segment
    const dx = b[0] - a[0], dy = b[1] - a[1];
    const lenSq = dx * dx + dy * dy;
    let t = lenSq > 0 ? ((lat - a[0]) * dx + (lng - a[1]) * dy) / lenSq : 0;
    t = Math.max(0, Math.min(1, t));
    const px = a[0] + t * dx, py = a[1] + t * dy;
    const d = calcDist(lat, lng, px, py);
    if (d < bestDist) { bestDist = d; bestSeg = i; bestT = t; }
  }
  alignerSegIdx = bestSeg;
  alignerT = bestT;
  // Actually move marker to snapped position
  const a = alignerRouteCoords[bestSeg], b = alignerRouteCoords[bestSeg + 1];
  lat = a[0] + bestT * (b[0] - a[0]);
  lng = a[1] + bestT * (b[1] - a[1]);
  marker.setLatLng([lat, lng]);
}

// --- Map ---
const map = L.map("map").setView([lat, lng], DEFAULT_MAP_ZOOM);
L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', { maxZoom:19 }).addTo(map);
L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}{r}.png', { maxZoom:19 }).addTo(map);

const marker = L.circleMarker([lat, lng], {
  radius: 8, color: '#34d399', weight: 3, fillColor: '#34d399', fillOpacity: 0.9
}).addTo(map);

// Trail for visual feedback
const trail = L.polyline([], { color: '#34d39955', weight: 2, dashArray: '4,4' }).addTo(map);
const trailPoints = [];
const MAX_TRAIL = 200;

// --- Route display on map ---
let routePolyline = null;
let routeStopMarkers = [];
let allRoutesData = [];

// --- Load Simulation Mode ---
const LOAD_SIM_START_BUS_NUMBER = 100;
const LOAD_SIM_TICK_MS = 500;
const LOAD_SIM_MAX_COUNT = 50;

const activeSimulatedBuses = {};
const loadSimulationTimers = {};
let spawnedBusNumbers = [];
let loadSimulationRunning = false;
let loadSimulationBusy = false;

const loadSimCountInput = document.getElementById('loadSimCount');
const startLoadSimBtn = document.getElementById('startLoadSimBtn');
const stopLoadSimBtn = document.getElementById('stopLoadSimBtn');
const loadSimStatusEl = document.getElementById('loadSimStatus');

function setLoadSimStatus(message, isError) {
  loadSimStatusEl.textContent = message;
  loadSimStatusEl.style.color = isError ? '#fb7185' : '#9aa4b2';
}

function refreshLoadSimControls() {
  startLoadSimBtn.disabled = loadSimulationBusy || loadSimulationRunning;
  stopLoadSimBtn.disabled = loadSimulationBusy || !loadSimulationRunning;
}

function clampLoadSimCount(value) {
  const n = Number.isFinite(value) ? Math.round(value) : 0;
  return Math.max(1, Math.min(LOAD_SIM_MAX_COUNT, n || 1));
}

function sanitizeWaypoints(route) {
  if (!route || !Array.isArray(route.waypoints)) return [];
  return route.waypoints
    .map(wp => [Number(wp[0]), Number(wp[1])])
    .filter(wp => Number.isFinite(wp[0]) && Number.isFinite(wp[1]));
}

function pickRandomRoute(routes) {
  if (!routes.length) return null;
  return routes[Math.floor(Math.random() * routes.length)];
}

function computeHeading(a, b, direction) {
  const dx = b[1] - a[1];
  const dy = b[0] - a[0];
  const heading = (Math.atan2(dx, dy) * 180 / Math.PI + 360) % 360;
  return direction >= 0 ? heading : (heading + 180) % 360;
}

function updateSimulatedBusPose(state) {
  const a = state.waypoints[state.segmentIdx];
  const b = state.waypoints[state.segmentIdx + 1];
  if (!a || !b) return;

  const t = Math.max(0, Math.min(1, state.t));
  let latPos = a[0] + (b[0] - a[0]) * t;
  let lngPos = a[1] + (b[1] - a[1]) * t;

  const latMid = (a[0] + b[0]) * 0.5;
  const metersPerLng = Math.max(1, 111320 * Math.cos(latMid * Math.PI / 180));
  const segEast = (b[1] - a[1]) * metersPerLng;
  const segNorth = (b[0] - a[0]) * 111320;
  const segLen = Math.sqrt(segEast * segEast + segNorth * segNorth);

  if (segLen > 0.001) {
    const perpEast = -segNorth / segLen;
    const perpNorth = segEast / segLen;
    state.swayPhase += state.swayStep;
    const swayMeters = Math.sin(state.swayPhase) * state.swayAmplitude;
    latPos += (perpNorth * swayMeters) / 111320;
    lngPos += (perpEast * swayMeters) / metersPerLng;
  }

  state.lat = latPos;
  state.lng = lngPos;
  state.heading = computeHeading(a, b, state.direction);

  const dLat = b[0] - a[0];
  const dLng = b[1] - a[1];
  const vecMag = Math.sqrt(dLat * dLat + dLng * dLng) || 1;
  const sign = state.direction >= 0 ? 1 : -1;
  state.directionVector = {
    lat: sign * dLat / vecMag,
    lng: sign * dLng / vecMag
  };
}

function advanceSimulatedBus(state, dtSec) {
  if (!state || !Array.isArray(state.waypoints) || state.waypoints.length < 2) return;

  state.speedPhase += state.speedPhaseStep;
  const variedKmh = Math.max(4, state.baseSpeedKmh * (0.92 + 0.16 * Math.sin(state.speedPhase)));
  let remainingMeters = (variedKmh / 3.6) * dtSec;
  let guard = 0;

  while (remainingMeters > 0.001 && guard < 128) {
    guard++;
    const a = state.waypoints[state.segmentIdx];
    const b = state.waypoints[state.segmentIdx + 1];
    if (!a || !b) break;

    const segLen = calcDist(a[0], a[1], b[0], b[1]);
    if (segLen < 0.05) {
      if (state.direction >= 0) {
        if (state.segmentIdx >= state.waypoints.length - 2) {
          state.segmentIdx = state.waypoints.length - 2;
          state.t = 1;
          state.direction = -1;
        } else {
          state.segmentIdx += 1;
          state.t = 0;
        }
      } else {
        if (state.segmentIdx <= 0) {
          state.segmentIdx = 0;
          state.t = 0;
          state.direction = 1;
        } else {
          state.segmentIdx -= 1;
          state.t = 1;
        }
      }
      continue;
    }

    if (state.direction >= 0) {
      const distToEnd = (1 - state.t) * segLen;
      if (remainingMeters >= distToEnd) {
        remainingMeters -= distToEnd;
        if (state.segmentIdx >= state.waypoints.length - 2) {
          state.segmentIdx = state.waypoints.length - 2;
          state.t = 1;
          state.direction = -1;
        } else {
          state.segmentIdx += 1;
          state.t = 0;
        }
      } else {
        state.t += remainingMeters / segLen;
        remainingMeters = 0;
      }
    } else {
      const distToStart = state.t * segLen;
      if (remainingMeters >= distToStart) {
        remainingMeters -= distToStart;
        if (state.segmentIdx <= 0) {
          state.segmentIdx = 0;
          state.t = 0;
          state.direction = 1;
        } else {
          state.segmentIdx -= 1;
          state.t = 1;
        }
      } else {
        state.t -= remainingMeters / segLen;
        remainingMeters = 0;
      }
    }
  }

  state.t = Math.max(0, Math.min(1, state.t));
  updateSimulatedBusPose(state);
}

function sendSimulatedBusUpdate(state) {
  if (!state || state.inFlight) return Promise.resolve(false);
  state.inFlight = true;
  const payload = {
    lat: state.lat,
    lng: state.lng,
    routeId: state.routeId,
    heading: state.heading,
    lastUpdate: new Date().toISOString()
  };
  return fetch(`/api/bus/${state.busNumber}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  }).catch(() => {}).finally(() => {
    state.inFlight = false;
  });
}

function tickSimulatedBus(busNumber) {
  const state = activeSimulatedBuses[busNumber];
  if (!state || !loadSimulationRunning) return;
  advanceSimulatedBus(state, LOAD_SIM_TICK_MS / 1000);
  sendSimulatedBusUpdate(state);
}

function createSimulatedBusState(busNumber, route) {
  const waypoints = sanitizeWaypoints(route);
  if (waypoints.length < 2) return null;

  const spawnIdx = Math.floor(Math.random() * waypoints.length);
  const direction = Math.random() < 0.5 ? 1 : -1;
  let segmentIdx = 0;
  let t = 0;

  if (direction >= 0) {
    if (spawnIdx >= waypoints.length - 1) {
      segmentIdx = waypoints.length - 2;
      t = 1;
    } else {
      segmentIdx = spawnIdx;
      t = 0;
    }
  } else {
    if (spawnIdx <= 0) {
      segmentIdx = 0;
      t = 0;
    } else {
      segmentIdx = spawnIdx - 1;
      t = 1;
    }
  }

  const state = {
    busNumber,
    routeId: route.id,
    waypoints,
    segmentIdx,
    t,
    direction,
    lat: waypoints[spawnIdx][0],
    lng: waypoints[spawnIdx][1],
    heading: 0,
    directionVector: { lat: 0, lng: 0 },
    baseSpeedKmh: 10 + Math.random() * 8,
    speedPhase: Math.random() * Math.PI * 2,
    speedPhaseStep: 0.08 + Math.random() * 0.1,
    swayAmplitude: 1 + Math.random() * 2.5,
    swayPhase: Math.random() * Math.PI * 2,
    swayStep: 0.06 + Math.random() * 0.08,
    inFlight: false
  };
  updateSimulatedBusPose(state);
  return state;
}

async function stopLoadSimulation() {
  const busesToStop = spawnedBusNumbers.slice();
  if (!busesToStop.length && !loadSimulationRunning) {
    setLoadSimStatus('Load simulation idle', false);
    refreshLoadSimControls();
    return;
  }

  loadSimulationBusy = true;
  loadSimulationRunning = false;
  refreshLoadSimControls();
  setLoadSimStatus('Stopping simulation...', false);

  busesToStop.forEach(busNumber => {
    const timer = loadSimulationTimers[busNumber];
    if (timer) clearInterval(timer);
    delete loadSimulationTimers[busNumber];
    delete activeSimulatedBuses[busNumber];
  });

  await Promise.allSettled(
    busesToStop.map(busNumber => fetch(`/api/bus/${busNumber}`, { method: 'DELETE' }).catch(() => {}))
  );

  spawnedBusNumbers = [];
  loadSimulationBusy = false;
  setLoadSimStatus('Load simulation stopped', false);
  refreshLoadSimControls();
}

async function startLoadSimulation() {
  if (loadSimulationBusy || loadSimulationRunning) return;

  loadSimulationBusy = true;
  refreshLoadSimControls();

  const desiredCount = clampLoadSimCount(parseInt(loadSimCountInput.value, 10));
  loadSimCountInput.value = String(desiredCount);
  setLoadSimStatus('Fetching routes...', false);

  let routes = [];
  try {
    const res = await fetch('/api/routes');
    routes = await res.json();
  } catch (e) {
    loadSimulationBusy = false;
    setLoadSimStatus('Failed to fetch routes', true);
    refreshLoadSimControls();
    return;
  }

  const availableRoutes = (Array.isArray(routes) ? routes : []).filter(r => sanitizeWaypoints(r).length >= 2);
  if (!availableRoutes.length) {
    loadSimulationBusy = false;
    setLoadSimStatus('No routes available for load simulation', true);
    refreshLoadSimControls();
    return;
  }

  loadSimulationBusy = false;
  refreshLoadSimControls();
  await stopLoadSimulation();

  loadSimulationRunning = true;
  refreshLoadSimControls();
  setLoadSimStatus(`Starting ${desiredCount} transports...`, false);

  const setupTasks = [];
  for (let i = 0; i < desiredCount; i++) {
    const busNumber = LOAD_SIM_START_BUS_NUMBER + i;
    const route = pickRandomRoute(availableRoutes);
    const state = createSimulatedBusState(busNumber, route);
    if (!state) continue;

    activeSimulatedBuses[busNumber] = state;
    spawnedBusNumbers.push(busNumber);
    loadSimulationTimers[busNumber] = setInterval(() => tickSimulatedBus(busNumber), LOAD_SIM_TICK_MS);

    const assignTask = fetch(`/api/bus/${busNumber}/route`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ routeId: state.routeId })
    }).catch(() => {}).then(() => sendSimulatedBusUpdate(state));
    setupTasks.push(assignTask);
  }

  await Promise.allSettled(setupTasks);
  setLoadSimStatus(`Load simulation running: ${spawnedBusNumbers.length} transports`, false);
  refreshLoadSimControls();
}

async function osrmRoute(waypoints) {
  if (waypoints.length < 2) return waypoints;
  try {
    const coords = waypoints.map(wp => `${wp[1]},${wp[0]}`).join(';');
    const res = await fetch(`https://router.project-osrm.org/route/v1/driving/${coords}?geometries=geojson`);
    const data = await res.json();
    if (data.routes && data.routes[0]) return data.routes[0].geometry.coordinates.map(c => [c[1], c[0]]);
  } catch(e) {}
  return waypoints;
}

function clearRouteDisplay() {
  if (routePolyline) { map.removeLayer(routePolyline); routePolyline = null; }
  routeStopMarkers.forEach(m => map.removeLayer(m));
  routeStopMarkers = [];
}

async function showRouteOnMap(routeId) {
  clearRouteDisplay();
  alignerRouteCoords = null;
  refreshAutoFollowUI();
  if (!routeId) return;
  const route = allRoutesData.find(r => String(r.id) === String(routeId));
  if (!route || !route.waypoints || route.waypoints.length < 2) return;

  // Teleport simulator marker to route start as soon as a route is selected.
  const routeStart = route.waypoints[0];
  if (Array.isArray(routeStart) && routeStart.length >= 2) {
    lat = Number(routeStart[0]);
    lng = Number(routeStart[1]);
    alignerSegIdx = 0;
    alignerT = 0;
    marker.setLatLng([lat, lng]);
    trailPoints.length = 0;
    trail.setLatLngs([]);
    try { map.panTo([lat, lng], { animate: true, duration: 0.25 }); } catch (e) {}
  }

  const coords = await osrmRoute(route.waypoints);
  alignerRouteCoords = coords; // cache for aligner
  if (coords && coords.length >= 2) {
    lat = coords[0][0];
    lng = coords[0][1];
    alignerSegIdx = 0;
    alignerT = 0;
    marker.setLatLng([lat, lng]);
  }
  refreshAutoFollowUI();
  routePolyline = L.polyline(coords, {
    color: route.color || '#667eea', weight: 4, opacity: 0.7, dashArray: '8,6'
  }).addTo(map);
  // Bring trail and marker above the route line
  trail.bringToFront();
  marker.bringToFront();

  route.waypoints.forEach((wp, idx) => {
    const name = (route.stops && route.stops[idx]) || `Stop ${idx+1}`;
    const dot = L.circleMarker(wp, {
      radius: 5, color: route.color || '#667eea', weight: 2,
      fillColor: '#fff', fillOpacity: 0.9
    }).addTo(map);
    dot.bindTooltip(name, { direction: 'top', offset: [0, -8] });
    routeStopMarkers.push(dot);
  });
}

// --- Controls ---
function updateStartBtn() {
  const btn = document.getElementById('startBtn');
  if (simRunning) {
    btn.textContent = 'Stop Simulation';
    btn.className = 'running';
    btn.disabled = false;
  } else if (bus && currentRouteId) {
    btn.textContent = 'Start Simulation';
    btn.className = '';
    btn.disabled = false;
  } else {
    btn.textContent = 'Select bus & route first';
    btn.className = '';
    btn.disabled = true;
  }
}

function initBusSelect() {
  const sel = document.getElementById("busSelect");
  for (let i = 1; i <= 20; i++) {
    const o = document.createElement("option");
    o.value = i; o.text = "Bus " + i;
    sel.appendChild(o);
  }
  sel.onchange = () => {
    bus = sel.value ? parseInt(sel.value) : null;
    updateStartBtn();
  };
}

async function initRouteSelect() {
  try {
    const res = await fetch("/api/routes");
    const routes = await res.json();
    allRoutesData = routes;
    const sel = document.getElementById("routeSelect");
    routes.forEach(r => {
      const o = document.createElement("option");
      o.value = r.id; o.text = r.name;
      sel.appendChild(o);
    });
    sel.onchange = () => {
      currentRouteId = sel.value || null;
      showRouteOnMap(currentRouteId).then(() => {
        if (alignerEnabled && alignerRouteCoords && alignerRouteCoords.length >= 2) {
          snapToNearestRoutePoint();
        }
      });
      updateStartBtn();
      if (currentRouteId && bus && simRunning) {
        fetch(`/api/bus/${bus}/route`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ routeId: currentRouteId })
        }).catch(() => {});
      }
    };
  } catch (e) { console.warn("Failed to load routes:", e); }
}

// Speed controls - slider and number input are synced (both in km/h)
const speedSlider = document.getElementById('speedSlider');
const customSpeedInput = document.getElementById('customSpeed');
let targetKmh = 50; // current speed in km/h

function setSpeed(kmh) {
  kmh = Math.max(1, Math.min(200, Math.round(kmh)));
  targetKmh = kmh;
  speedSlider.value = kmh;
  customSpeedInput.value = kmh;
}

speedSlider.addEventListener('input', () => { setSpeed(parseFloat(speedSlider.value)); });
customSpeedInput.addEventListener('input', () => { setSpeed(parseFloat(customSpeedInput.value) || 1); });
customSpeedInput.addEventListener('change', () => { setSpeed(parseFloat(customSpeedInput.value) || 1); });

// Try to center on user location
navigator.geolocation.getCurrentPosition((pos) => {
  if (currentRouteId) return;
  lat = pos.coords.latitude;
  lng = pos.coords.longitude;
  map.setView([lat, lng], DEFAULT_MAP_ZOOM);
  marker.setLatLng([lat, lng]);
});

// --- Input ---
const keys = {};
document.addEventListener("keydown", e => {
  // Don't capture keys when typing in an input field
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
  keys[e.key.toLowerCase()] = true;
  if (['w','a','s','d',' '].includes(e.key.toLowerCase()) || e.key === 'Shift') e.preventDefault();
});
document.addEventListener("keyup", e => { keys[e.key.toLowerCase()] = false; });

// --- Gamepad Helpers ---
function deadzone(val, threshold = 0.1) {
    return Math.abs(val) < threshold ? 0 : val;
}
function normalizeTrigger(val) {
    return Math.max(0, Math.min(1, val));
}

// --- Gamepad Input Handler ---
class GamepadHandler {
    constructor() {
        this.gamepadIndex = null;
        window.addEventListener('gamepadconnected', e => {
            this.gamepadIndex = e.gamepad.index;
        });
        window.addEventListener('gamepaddisconnected', e => {
            if (this.gamepadIndex === e.gamepad.index) this.gamepadIndex = null;
        });
    }
    getInput() {
        if (!GAMEPAD_API_AVAILABLE || !GAMEPAD_ALLOWED_CONTEXT) return null;
        const pads = getGamepadsSafe();
        const pad = this.gamepadIndex !== null ? pads[this.gamepadIndex] : pads[0];
        if (!pad) return null;
        const RT = normalizeTrigger(getTriggerValue(pad, 7, [5, 2]));
        const LT = normalizeTrigger(getTriggerValue(pad, 6, [4, 3]));
        const steer = deadzone(getAxisValue(pad, 0));
        return { RT, LT, steer };
    }
    isActive() {
        return this.getInput() !== null;
    }
}

const gamepadHandler = new GamepadHandler();
let gamepadHeading = 0;

// Add more robust polling and debug output
function pollGamepadConnection() {
    if (!GAMEPAD_API_AVAILABLE || !GAMEPAD_ALLOWED_CONTEXT) {
        gamepadHandler.gamepadIndex = null;
        return;
    }
    const pads = getGamepadsSafe();
    let found = false;
    for (let i = 0; i < pads.length; i++) {
        if (pads[i]) {
            found = true;
            gamepadHandler.gamepadIndex = i;
            break;
        }
    }
    if (!found) gamepadHandler.gamepadIndex = null;
}

function primeGamepadDetection() {
    pollGamepadConnection();
    renderGamepadPanel(true);
}
window.addEventListener('pointerdown', primeGamepadDetection, { once: true });
window.addEventListener('keydown', primeGamepadDetection, { once: true });

// --- Animation Loop ---
let lastFrame = performance.now();
let lastSend = 0;
const SEND_INTERVAL = 200; // ms between server updates when moving
const IDLE_SEND_INTERVAL = 5000; // ms between server updates when stationary
let lastSentLat = null, lastSentLng = null;
let isMoving = false;
let updatesSent = 0;
let currentHeading = 0; // degrees, 0 = north, clockwise

function animate(now) {
    pollGamepadConnection();
    const dt = Math.min(0.1, (now - lastFrame) / 1000); // cap at 100ms to avoid jumps
    lastFrame = now;

    const boost = keys["shift"] ? BOOST : 1;
    const speedDegPerSec = (targetKmh / 3.6) / 111320; // convert km/h to degrees/sec

    if (alignerEnabled && alignerRouteCoords && alignerRouteCoords.length >= 2) {
        // --- ALIGNER MODE: move along route track ---
        // Use gamepad if available, else keyboard
        let goForward = false, goReverse = false;
        if (autoFollowEnabled) {
            goForward = autoFollowDirection === 1;
            goReverse = autoFollowDirection === -1;
        } else if (gamepadHandler.isActive()) {
            const input = gamepadHandler.getInput();
            goForward = input.RT > 0.1 && input.LT < 0.1;
            goReverse = input.LT > 0.1 && input.RT < 0.1;
        } else {
            goForward = !!keys["w"] && !keys[" "];
            goReverse = !!keys["s"] && !keys[" "];
        }
        alignerMoving = goForward || goReverse;

        if (alignerMoving) {
            // Distance to travel this frame in degrees
            const alignerBoost = autoFollowEnabled ? 1 : boost;
            let remaining = speedDegPerSec * alignerBoost * dt;

            if (goForward) {
                // --- Forward along route (increasing segment index) ---
                while (remaining > 0 && alignerSegIdx < alignerRouteCoords.length - 1) {
                    const a = alignerRouteCoords[alignerSegIdx];
                    const b = alignerRouteCoords[alignerSegIdx + 1];
                    const segDx = b[0] - a[0], segDy = b[1] - a[1];
                    const segLen = Math.sqrt(segDx * segDx + segDy * segDy);
                    if (segLen === 0) { alignerSegIdx++; alignerT = 0; continue; }

                    const remainingInSeg = (1 - alignerT) * segLen;
                    if (remaining >= remainingInSeg) {
                        remaining -= remainingInSeg;
                        alignerSegIdx++;
                        alignerT = 0;
                    } else {
                        alignerT += remaining / segLen;
                        remaining = 0;
                    }
                }
                // Clamp at end of route
                if (alignerSegIdx >= alignerRouteCoords.length - 1) {
                    alignerSegIdx = alignerRouteCoords.length - 2;
                    alignerT = 1;
                }
            } else {
                // --- Reverse along route (decreasing segment index) ---
                while (remaining > 0 && (alignerSegIdx > 0 || alignerT > 0)) {
                    const a = alignerRouteCoords[alignerSegIdx];
                    const b = alignerRouteCoords[alignerSegIdx + 1];
                    const segDx = b[0] - a[0], segDy = b[1] - a[1];
                    const segLen = Math.sqrt(segDx * segDx + segDy * segDy);
                    if (segLen === 0) { if (alignerSegIdx > 0) { alignerSegIdx--; alignerT = 1; } else { alignerT = 0; } continue; }

                    const travelledInSeg = alignerT * segLen;
                    if (remaining >= travelledInSeg) {
                        remaining -= travelledInSeg;
                        if (alignerSegIdx > 0) { alignerSegIdx--; alignerT = 1; }
                        else { alignerT = 0; remaining = 0; }
                    } else {
                        alignerT -= remaining / segLen;
                        remaining = 0;
                    }
                }
            }

            // Compute actual position
            const a = alignerRouteCoords[alignerSegIdx];
            const b = alignerRouteCoords[alignerSegIdx + 1];
            lat = a[0] + alignerT * (b[0] - a[0]);
            lng = a[1] + alignerT * (b[1] - a[1]);
            marker.setLatLng([lat, lng]);

            // Compute heading from movement direction (forward or reverse along segment)
            const hDx = b[1] - a[1], hDy = b[0] - a[0];
            const fwdHeading = (Math.atan2(hDx, hDy) * 180 / Math.PI + 360) % 360;
            currentHeading = goReverse ? (fwdHeading + 180) % 360 : fwdHeading;

            trailPoints.push([lat, lng]);
            if (trailPoints.length > MAX_TRAIL) trailPoints.shift();
            trail.setLatLngs(trailPoints);
        }

        isMoving = alignerMoving;
    } else {
        // --- NORMAL MODE: WASD or Gamepad free movement ---
        let dx = 0, dy = 0;
        let useGamepad = gamepadHandler.isActive();
        if (useGamepad) {
            const input = gamepadHandler.getInput();
            // Only move if both RT and LT are pressed, and use left stick for direction
            if (input.RT > 0.1 && input.LT > 0.1) {
                dx = input.steer;
                const pads = getGamepadsSafe();
                const pad = gamepadHandler.gamepadIndex !== null ? pads[gamepadHandler.gamepadIndex] : pads[0];
                let stickY = pad && pad.axes.length > 1 ? -deadzone(pad.axes[1]) : 0;
                const mag = Math.sqrt(dx * dx + stickY * stickY) || 1;
                dx /= mag; stickY /= mag;
                // 3x speed boost when both triggers are pressed
                const speed = input.RT * speedDegPerSec * GAMEPAD_DUAL_TRIGGER_BOOST * dt;
                lat += stickY * speed;
                lng += dx * speed;
                currentHeading = (Math.atan2(dx, stickY) * 180 / Math.PI + 360) % 360;
                marker.setLatLng([lat, lng]);
                trailPoints.push([lat, lng]);
                if (trailPoints.length > MAX_TRAIL) trailPoints.shift();
                trail.setLatLngs(trailPoints);
                isMoving = true;
            } else if (input.RT > 0.1) {
                // Only RT pressed: normal speed
                dx = input.steer;
                const pads = getGamepadsSafe();
                const pad = gamepadHandler.gamepadIndex !== null ? pads[gamepadHandler.gamepadIndex] : pads[0];
                let stickY = pad && pad.axes.length > 1 ? -deadzone(pad.axes[1]) : 0;
                const mag = Math.sqrt(dx * dx + stickY * stickY) || 1;
                dx /= mag; stickY /= mag;
                const speed = input.RT * speedDegPerSec * dt;
                lat += stickY * speed;
                lng += dx * speed;
                currentHeading = (Math.atan2(dx, stickY) * 180 / Math.PI + 360) % 360;
                marker.setLatLng([lat, lng]);
                trailPoints.push([lat, lng]);
                if (trailPoints.length > MAX_TRAIL) trailPoints.shift();
                trail.setLatLngs(trailPoints);
                isMoving = true;
            } else {
                isMoving = false;
            }
        } else {
            // ...existing WASD movement code...
            dx = 0; dy = 0;
            let boostVal = keys["shift"] ? 2 : 1;
            if (keys["w"]) dy = 1;
            if (keys["s"]) dy = -1;
            if (keys["d"]) dx = 1;
            if (keys["a"]) dx = -1;
            const mag = Math.sqrt(dx * dx + dy * dy) || 1;
            dx /= mag; dy /= mag;
            isMoving = (dx !== 0 || dy !== 0);
            if (isMoving) {
                currentHeading = (Math.atan2(dx, dy) * 180 / Math.PI + 360) % 360;
                lat += dy * speedDegPerSec * boostVal * dt;
                lng += dx * speedDegPerSec * boostVal * dt;
                marker.setLatLng([lat, lng]);
                trailPoints.push([lat, lng]);
                if (trailPoints.length > MAX_TRAIL) trailPoints.shift();
                trail.setLatLngs(trailPoints);
            }
        }
    }

    // Soft camera follow - pan only when near edge
    try {
        const px = map.latLngToContainerPoint([lat, lng]);
        const sz = map.getSize();
        const m = 60;
        if (px.x < m || px.x > sz.x - m || px.y < m || px.y > sz.y - m) {
            map.panTo([lat, lng], { animate: true, duration: 0.3 });
        }
    } catch (e) {}

    // Send updates to server - fast when moving, slow heartbeat when idle
    const sendInterval = isMoving ? SEND_INTERVAL : IDLE_SEND_INTERVAL;
    if (simRunning && bus && now - lastSend >= sendInterval) {
        // Skip if position hasn't changed (within ~1m) and not first send
        const posChanged = lastSentLat === null ||
            Math.abs(lat - lastSentLat) > 0.00001 ||
            Math.abs(lng - lastSentLng) > 0.00001;
        // Always send at heartbeat interval even if not moved (keeps bus alive on server)
        if (posChanged || now - lastSend >= IDLE_SEND_INTERVAL) {
            lastSend = now;
            lastSentLat = lat; lastSentLng = lng;
            const payload = { lat, lng, lastUpdate: new Date().toISOString(), heading: currentHeading };
            if (currentRouteId) payload.routeId = currentRouteId;
            fetch(`/api/bus/${bus}`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload)
            }).then(() => {
                updatesSent++;
                document.getElementById('syncStatus').innerHTML = '<span class="status-dot"></span>Synced';
                document.getElementById('updateCount').textContent = updatesSent;
                document.getElementById('lastUpdateTime').textContent = new Date().toLocaleTimeString();
            }).catch(() => {
                document.getElementById('syncStatus').innerHTML = '<span class="status-dot" style="background:#fb7185"></span>Offline';
            });
        }
    }

    requestAnimationFrame(animate);
}

initBusSelect();
initRouteSelect();
refreshAutoFollowUI();
refreshLoadSimControls();

loadSimCountInput.addEventListener('change', () => {
  loadSimCountInput.value = String(clampLoadSimCount(parseInt(loadSimCountInput.value, 10)));
});
startLoadSimBtn.addEventListener('click', () => {
  startLoadSimulation().catch(() => {
    loadSimulationBusy = false;
    loadSimulationRunning = false;
    refreshLoadSimControls();
    setLoadSimStatus('Load simulation failed', true);
  });
});
stopLoadSimBtn.addEventListener('click', () => {
  stopLoadSimulation().catch(() => {
    loadSimulationBusy = false;
    refreshLoadSimControls();
    setLoadSimStatus('Failed to stop simulation', true);
  });
});

// Start/Stop button
document.getElementById('startBtn').addEventListener('click', () => {
    if (simRunning) {
        simRunning = false;
        // Notify server to remove this bus
        if (bus) {
            fetch(`/api/bus/${bus}`, { method: 'DELETE' }).catch(() => {});
        }
        document.getElementById('syncStatus').innerHTML = '<span class="status-dot" style="background:#667"></span>Stopped';
    } else {
        if (!bus || !currentRouteId) return;
        simRunning = true;
        // Assign route on server
        fetch(`/api/bus/${bus}/route`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ routeId: currentRouteId })
        }).catch(() => {});
        document.getElementById('syncStatus').innerHTML = '<span class="status-dot"></span>Syncing...';
    }
    updateStartBtn();
});

requestAnimationFrame(animate);
</script>
</body>
</html>

