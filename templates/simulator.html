<!DOCTYPE html>
<html>
<head>
<title>Bus Simulator</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<style>
body { margin:0; background:#0f0f23; color:#e6eef8; font-family:'Segoe UI',sans-serif; }
#map { height:100vh; }
.controls {
  position:absolute; top:12px; left:12px; background:rgba(18,24,38,0.92);
  padding:14px 16px; border-radius:12px; z-index:1000; min-width:220px;
  border:1px solid rgba(255,255,255,0.08); backdrop-filter:blur(12px);
  box-shadow:0 8px 32px rgba(0,0,0,0.5);
}
.controls label { display:block; font-size:12px; color:#9aa4b2; margin-top:8px; }
.controls select, .controls input[type=number] {
  width:100%; padding:6px 8px; border-radius:6px; border:1px solid rgba(255,255,255,0.1);
  background:#0f0f23; color:#e6eef8; font-size:13px; margin-top:2px;
}
.controls input[type=range] { width:100%; margin-top:2px; }
.speed-row { display:flex; align-items:center; gap:8px; margin-top:4px; }
.speed-row input[type=range] { flex:1; min-width:0; }
.speed-row input[type=number] {
  width:64px; flex:none; padding:4px 6px; border-radius:6px;
  border:1px solid rgba(255,255,255,0.1); background:#0f0f23;
  color:#34d399; font-size:13px; font-weight:600; text-align:center;
  -moz-appearance:textfield;
  appearance:textfield;
}
.speed-row input[type=number]::-webkit-inner-spin-button,
.speed-row input[type=number]::-webkit-outer-spin-button { opacity:1; }
.speed-unit { font-size:11px; color:#667; flex:none; }
.keys-hint { font-size:11px; color:#667; margin-top:10px; line-height:1.6; }
.keys-hint kbd {
  background:rgba(255,255,255,0.08); padding:2px 6px; border-radius:4px;
  border:1px solid rgba(255,255,255,0.15); font-family:monospace; font-size:11px;
}
.status-dot { display:inline-block; width:6px; height:6px; border-radius:50%; background:#34d399; margin-right:6px;
  box-shadow:0 0 6px rgba(52,211,153,0.5); }
#syncStatus { font-size:11px; color:#9aa4b2; margin-top:8px; }
#startBtn {
  width:100%; margin-top:12px; padding:8px 0; border:none; border-radius:8px;
  background:rgba(52,211,153,0.15); color:#34d399; font-size:13px; font-weight:600;
  cursor:pointer; transition:all 0.2s;
}
#startBtn:hover:not(:disabled) { background:rgba(52,211,153,0.25); }
#startBtn:disabled { opacity:0.35; cursor:not-allowed; }
#startBtn.running { background:rgba(251,113,133,0.15); color:#fb7185; }
#startBtn.running:hover { background:rgba(251,113,133,0.25); }
.aligner-toggle {
  display:flex; align-items:center; gap:8px; margin-top:10px;
  padding:8px 10px; border-radius:8px;
  background:rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.06);
}
.aligner-toggle input[type=checkbox] { accent-color:#667eea; width:16px; height:16px; cursor:pointer; }
.aligner-toggle label { font-size:12px; color:#9aa4b2; cursor:pointer; flex:1; }
.aligner-toggle .aligner-badge {
  font-size:10px; padding:2px 6px; border-radius:4px;
  background:rgba(102,126,234,0.15); color:#667eea; font-weight:600;
}
.aligner-toggle.active { border-color:rgba(102,126,234,0.4); background:rgba(102,126,234,0.08); }
.aligner-toggle.active .aligner-badge { background:rgba(102,126,234,0.25); }
</style>
</head>
<body>

<div class="controls">
  <div style="font-weight:600; font-size:14px; margin-bottom:6px;">üöç Bus Simulator</div>

  <label>Bus Number
    <select id="busSelect"><option value="" selected>‚Äî Select Bus ‚Äî</option></select>
  </label>

  <label>Route
    <select id="routeSelect"><option value="" selected>‚Äî Select Route ‚Äî</option></select>
  </label>

  <label>Speed (km/h)
    <div class="speed-row">
      <input type="range" id="speedSlider" min="1" max="200" step="1" value="50"/>
      <input type="number" id="customSpeed" min="1" max="200" step="1" value="50"/>
      <span class="speed-unit">km/h</span>
    </div>
  </label>

  <div class="keys-hint">
    <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> to drive<br>
    <kbd>Shift</kbd> to boost &nbsp; <kbd>Space</kbd> to brake<br>
    <span style="color:#667eea">Aligner:</span> <kbd>W</kbd> forward ¬∑ <kbd>S</kbd> reverse ¬∑ <kbd>Space</kbd> brake
  </div>

  <div class="aligner-toggle" id="alignerToggle">
    <input type="checkbox" id="alignerCheck"/>
    <label for="alignerCheck">üõ§Ô∏è Aligner ‚Äî lock to route track</label>
    <span class="aligner-badge">OFF</span>
  </div>

  <div id="syncStatus"><span class="status-dot" style="background:#667"></span>Waiting to start...</div>
  <div id="updateStats" style="font-size:11px; color:#9aa4b2; margin-top:4px; display:flex; justify-content:space-between">
    <span>Sent: <span id="updateCount" style="color:#34d399;font-weight:600">0</span></span>
    <span>Last: <span id="lastUpdateTime" style="color:#667eea">‚Äî</span></span>
  </div>
  <button id="startBtn" disabled>Select bus & route first</button>
</div>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
// --- Gamepad Status Indicator ---
let gamepadStatusEl = document.createElement('div');
gamepadStatusEl.style.cssText = 'position:absolute;top:8px;right:8px;background:rgba(18,24,38,0.92);color:#34d399;padding:6px 12px;border-radius:8px;font-size:13px;z-index:1001;border:1px solid #34d399;';
gamepadStatusEl.textContent = 'Controller: Not Connected';
document.body.appendChild(gamepadStatusEl);

const GAMEPAD_API_AVAILABLE =
    typeof navigator.getGamepads === 'function' ||
    typeof navigator.webkitGetGamepads === 'function';
const GAMEPAD_ALLOWED_CONTEXT = window.isSecureContext || location.hostname === 'localhost' || location.hostname === '127.0.0.1';

if (!GAMEPAD_API_AVAILABLE) {
    gamepadStatusEl.style.borderColor = '#fb7185';
    gamepadStatusEl.style.color = '#fb7185';
    gamepadStatusEl.textContent = 'Controller: Not Supported';
} else if (!GAMEPAD_ALLOWED_CONTEXT) {
    gamepadStatusEl.style.borderColor = '#f59e0b';
    gamepadStatusEl.style.color = '#f59e0b';
    gamepadStatusEl.textContent = 'Controller: HTTPS Required';
}

function getGamepadsSafe() {
    try {
        if (typeof navigator.getGamepads === 'function') return navigator.getGamepads() || [];
        if (typeof navigator.webkitGetGamepads === 'function') return navigator.webkitGetGamepads() || [];
    } catch (e) {}
    return [];
}

function getButtonValue(pad, index) {
    const btn = pad && pad.buttons ? pad.buttons[index] : null;
    return btn && typeof btn.value === 'number' ? Math.max(0, Math.min(1, btn.value)) : 0;
}

function getAxisValue(pad, index) {
    const axis = pad && pad.axes ? pad.axes[index] : null;
    return typeof axis === 'number' ? axis : 0;
}

function axisToTrigger(axisValue) {
    return Math.max(0, Math.min(1, (axisValue + 1) / 2));
}

function getTriggerValue(pad, primaryButton, fallbackAxes) {
    let value = getButtonValue(pad, primaryButton);
    if (value > 0) return value;
    for (const axisIdx of fallbackAxes) {
        value = Math.max(value, axisToTrigger(getAxisValue(pad, axisIdx)));
    }
    return value;
}

// --- Efficient Gamepad Panel Update ---
let lastGamepadPanel = '';
let lastGamepadPanelTime = 0;
function renderGamepadPanel(eager) {
    // Only update at most every 80ms unless forced (eager=true)
    const now = performance.now();
    if (!eager && now - lastGamepadPanelTime < 80) return;
    lastGamepadPanelTime = now;
    let html = '';
    if (!GAMEPAD_API_AVAILABLE) {
        gamepadStatusEl.innerHTML = `<b style='color:#fb7185;font-size:13px;'>Controller API not supported</b>`;
        return;
    }
    if (!GAMEPAD_ALLOWED_CONTEXT) {
        gamepadStatusEl.innerHTML = `<b style='color:#f59e0b;font-size:13px;'>Controller requires HTTPS</b>`;
        return;
    }
    const pads = getGamepadsSafe();
    let pad = null;
    for (let i = 0; i < pads.length; i++) {
        if (pads[i]) { pad = pads[i]; break; }
    }
    if (pad) {
        // Show only RT, LT, and left stick axes
        const RT = getTriggerValue(pad, 7, [5, 2]);
        const LT = getTriggerValue(pad, 6, [4, 3]);
        const LX = getAxisValue(pad, 0).toFixed(2);
        const LY = getAxisValue(pad, 1).toFixed(2);
        html += `<b style='color:#34d399;font-size:13px;'>Controller</b><br>`;
        html += `<span style='font-size:12px;color:#9aa4b2;'>RT: <b style='color:#34d399;'>${RT.toFixed(2)}</b> &nbsp; LT: <b style='color:#34d399;'>${LT.toFixed(2)}</b></span><br>`;
        html += `<span style='font-size:12px;color:#9aa4b2;'>L-Stick: <b style='color:#34d399;'>X:${LX} Y:${LY}</b></span>`;
    } else {
        html += `<b style='color:#fb7185;font-size:13px;'>No Controller</b>`;
    }
    if (html !== lastGamepadPanel) {
        gamepadStatusEl.innerHTML = html;
        lastGamepadPanel = html;
    }
}

// Update panel at most every 80ms, not every frame
setInterval(() => renderGamepadPanel(false), 80);
// Also update eagerly on connect/disconnect
window.addEventListener('gamepadconnected', () => renderGamepadPanel(true));
window.addEventListener('gamepaddisconnected', () => renderGamepadPanel(true));

// --- State ---
let lat = 20.3549, lng = 85.8161;
let bus = null;
let currentRouteId = null;
let simRunning = false;

// Physics
const BOOST = 2.5;           // shift multiplier
const GAMEPAD_DUAL_TRIGGER_BOOST = 3; // LT + RT multiplier

// --- Aligner state ---
let alignerEnabled = false;
let alignerRouteCoords = null; // [[lat,lng], ...] from OSRM
let alignerSegIdx = 0;         // current segment index on route
let alignerT = 0;              // fractional progress along current segment (0..1)
let alignerMoving = false;     // true while W is held

// Aligner UI
const alignerCheck = document.getElementById('alignerCheck');
const alignerToggleEl = document.getElementById('alignerToggle');
const alignerBadge = alignerToggleEl.querySelector('.aligner-badge');

alignerCheck.addEventListener('change', () => {
  alignerEnabled = alignerCheck.checked;
  alignerToggleEl.classList.toggle('active', alignerEnabled);
  alignerBadge.textContent = alignerEnabled ? 'ON' : 'OFF';
  if (alignerEnabled && alignerRouteCoords && alignerRouteCoords.length >= 2) {
    snapToNearestRoutePoint();
  }
});

function calcDist(lat1, lng1, lat2, lng2) {
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLng = (lng2 - lng1) * Math.PI / 180;
  const x = dLng * Math.cos((lat1 + lat2) * 0.5 * Math.PI / 180);
  return 6371000 * Math.sqrt(dLat * dLat + x * x);
}

function snapToNearestRoutePoint() {
  if (!alignerRouteCoords || alignerRouteCoords.length < 2) return;
  let bestDist = Infinity, bestSeg = 0, bestT = 0;
  for (let i = 0; i < alignerRouteCoords.length - 1; i++) {
    const a = alignerRouteCoords[i], b = alignerRouteCoords[i + 1];
    // Project point onto segment
    const dx = b[0] - a[0], dy = b[1] - a[1];
    const lenSq = dx * dx + dy * dy;
    let t = lenSq > 0 ? ((lat - a[0]) * dx + (lng - a[1]) * dy) / lenSq : 0;
    t = Math.max(0, Math.min(1, t));
    const px = a[0] + t * dx, py = a[1] + t * dy;
    const d = calcDist(lat, lng, px, py);
    if (d < bestDist) { bestDist = d; bestSeg = i; bestT = t; }
  }
  alignerSegIdx = bestSeg;
  alignerT = bestT;
  // Actually move marker to snapped position
  const a = alignerRouteCoords[bestSeg], b = alignerRouteCoords[bestSeg + 1];
  lat = a[0] + bestT * (b[0] - a[0]);
  lng = a[1] + bestT * (b[1] - a[1]);
  marker.setLatLng([lat, lng]);
}

// --- Map ---
const map = L.map("map").setView([lat, lng], 16);
L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', { maxZoom:19 }).addTo(map);
L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}{r}.png', { maxZoom:19 }).addTo(map);

const marker = L.circleMarker([lat, lng], {
  radius: 8, color: '#34d399', weight: 3, fillColor: '#34d399', fillOpacity: 0.9
}).addTo(map);

// Trail for visual feedback
const trail = L.polyline([], { color: '#34d39955', weight: 2, dashArray: '4,4' }).addTo(map);
const trailPoints = [];
const MAX_TRAIL = 200;

// --- Route display on map ---
let routePolyline = null;
let routeStopMarkers = [];
let allRoutesData = [];

async function osrmRoute(waypoints) {
  if (waypoints.length < 2) return waypoints;
  try {
    const coords = waypoints.map(wp => `${wp[1]},${wp[0]}`).join(';');
    const res = await fetch(`https://router.project-osrm.org/route/v1/driving/${coords}?geometries=geojson`);
    const data = await res.json();
    if (data.routes && data.routes[0]) return data.routes[0].geometry.coordinates.map(c => [c[1], c[0]]);
  } catch(e) {}
  return waypoints;
}

function clearRouteDisplay() {
  if (routePolyline) { map.removeLayer(routePolyline); routePolyline = null; }
  routeStopMarkers.forEach(m => map.removeLayer(m));
  routeStopMarkers = [];
}

async function showRouteOnMap(routeId) {
  clearRouteDisplay();
  alignerRouteCoords = null;
  if (!routeId) return;
  const route = allRoutesData.find(r => String(r.id) === String(routeId));
  if (!route || !route.waypoints || route.waypoints.length < 2) return;

  const coords = await osrmRoute(route.waypoints);
  alignerRouteCoords = coords; // cache for aligner
  routePolyline = L.polyline(coords, {
    color: route.color || '#667eea', weight: 4, opacity: 0.7, dashArray: '8,6'
  }).addTo(map);
  // Bring trail and marker above the route line
  trail.bringToFront();
  marker.bringToFront();

  route.waypoints.forEach((wp, idx) => {
    const name = (route.stops && route.stops[idx]) || `Stop ${idx+1}`;
    const dot = L.circleMarker(wp, {
      radius: 5, color: route.color || '#667eea', weight: 2,
      fillColor: '#fff', fillOpacity: 0.9
    }).addTo(map);
    dot.bindTooltip(name, { direction: 'top', offset: [0, -8] });
    routeStopMarkers.push(dot);
  });
}

// --- Controls ---
function updateStartBtn() {
  const btn = document.getElementById('startBtn');
  if (simRunning) {
    btn.textContent = '‚èπ Stop Simulation';
    btn.className = 'running';
    btn.disabled = false;
  } else if (bus && currentRouteId) {
    btn.textContent = '‚ñ∂ Start Simulation';
    btn.className = '';
    btn.disabled = false;
  } else {
    btn.textContent = 'Select bus & route first';
    btn.className = '';
    btn.disabled = true;
  }
}

function initBusSelect() {
  const sel = document.getElementById("busSelect");
  for (let i = 1; i <= 20; i++) {
    const o = document.createElement("option");
    o.value = i; o.text = "Bus " + i;
    sel.appendChild(o);
  }
  sel.onchange = () => {
    bus = sel.value ? parseInt(sel.value) : null;
    updateStartBtn();
  };
}

async function initRouteSelect() {
  try {
    const res = await fetch("/api/routes");
    const routes = await res.json();
    allRoutesData = routes;
    const sel = document.getElementById("routeSelect");
    routes.forEach(r => {
      const o = document.createElement("option");
      o.value = r.id; o.text = r.name;
      sel.appendChild(o);
    });
    sel.onchange = () => {
      currentRouteId = sel.value || null;
      showRouteOnMap(currentRouteId).then(() => {
        if (alignerEnabled && alignerRouteCoords && alignerRouteCoords.length >= 2) {
          snapToNearestRoutePoint();
        }
      });
      updateStartBtn();
      if (currentRouteId && bus && simRunning) {
        fetch(`/api/bus/${bus}/route`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ routeId: currentRouteId })
        }).catch(() => {});
      }
    };
  } catch (e) { console.warn("Failed to load routes:", e); }
}

// Speed controls ‚Äî slider and number input are synced (both in km/h)
const speedSlider = document.getElementById('speedSlider');
const customSpeedInput = document.getElementById('customSpeed');
let targetKmh = 50; // current speed in km/h

function setSpeed(kmh) {
  kmh = Math.max(1, Math.min(200, Math.round(kmh)));
  targetKmh = kmh;
  speedSlider.value = kmh;
  customSpeedInput.value = kmh;
}

speedSlider.addEventListener('input', () => { setSpeed(parseFloat(speedSlider.value)); });
customSpeedInput.addEventListener('input', () => { setSpeed(parseFloat(customSpeedInput.value) || 1); });
customSpeedInput.addEventListener('change', () => { setSpeed(parseFloat(customSpeedInput.value) || 1); });

// Try to center on user location
navigator.geolocation.getCurrentPosition((pos) => {
  lat = pos.coords.latitude;
  lng = pos.coords.longitude;
  map.setView([lat, lng], 16);
  marker.setLatLng([lat, lng]);
});

// --- Input ---
const keys = {};
document.addEventListener("keydown", e => {
  // Don't capture keys when typing in an input field
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
  keys[e.key.toLowerCase()] = true;
  if (['w','a','s','d',' '].includes(e.key.toLowerCase()) || e.key === 'Shift') e.preventDefault();
});
document.addEventListener("keyup", e => { keys[e.key.toLowerCase()] = false; });

// --- Gamepad Helpers ---
function deadzone(val, threshold = 0.1) {
    return Math.abs(val) < threshold ? 0 : val;
}
function normalizeTrigger(val) {
    return Math.max(0, Math.min(1, val));
}

// --- Gamepad Input Handler ---
class GamepadHandler {
    constructor() {
        this.gamepadIndex = null;
        window.addEventListener('gamepadconnected', e => {
            this.gamepadIndex = e.gamepad.index;
        });
        window.addEventListener('gamepaddisconnected', e => {
            if (this.gamepadIndex === e.gamepad.index) this.gamepadIndex = null;
        });
    }
    getInput() {
        if (!GAMEPAD_API_AVAILABLE || !GAMEPAD_ALLOWED_CONTEXT) return null;
        const pads = getGamepadsSafe();
        const pad = this.gamepadIndex !== null ? pads[this.gamepadIndex] : pads[0];
        if (!pad) return null;
        const RT = normalizeTrigger(getTriggerValue(pad, 7, [5, 2]));
        const LT = normalizeTrigger(getTriggerValue(pad, 6, [4, 3]));
        const steer = deadzone(getAxisValue(pad, 0));
        return { RT, LT, steer };
    }
    isActive() {
        return this.getInput() !== null;
    }
}

const gamepadHandler = new GamepadHandler();
let gamepadHeading = 0;

// Add more robust polling and debug output
function pollGamepadConnection() {
    if (!GAMEPAD_API_AVAILABLE || !GAMEPAD_ALLOWED_CONTEXT) {
        gamepadHandler.gamepadIndex = null;
        return;
    }
    const pads = getGamepadsSafe();
    let found = false;
    for (let i = 0; i < pads.length; i++) {
        if (pads[i]) {
            found = true;
            gamepadHandler.gamepadIndex = i;
            break;
        }
    }
    if (!found) gamepadHandler.gamepadIndex = null;
}

function primeGamepadDetection() {
    pollGamepadConnection();
    renderGamepadPanel(true);
}
window.addEventListener('pointerdown', primeGamepadDetection, { once: true });
window.addEventListener('keydown', primeGamepadDetection, { once: true });

// --- Animation Loop ---
let lastFrame = performance.now();
let lastSend = 0;
const SEND_INTERVAL = 200; // ms between server updates when moving
const IDLE_SEND_INTERVAL = 5000; // ms between server updates when stationary
let lastSentLat = null, lastSentLng = null;
let isMoving = false;
let updatesSent = 0;
let currentHeading = 0; // degrees, 0 = north, clockwise

function animate(now) {
    pollGamepadConnection();
    const dt = Math.min(0.1, (now - lastFrame) / 1000); // cap at 100ms to avoid jumps
    lastFrame = now;

    const boost = keys["shift"] ? BOOST : 1;
    const speedDegPerSec = (targetKmh / 3.6) / 111320; // convert km/h to degrees/sec

    if (alignerEnabled && alignerRouteCoords && alignerRouteCoords.length >= 2) {
        // --- ALIGNER MODE: move along route track ---
        // Use gamepad if available, else keyboard
        let goForward = false, goReverse = false;
        if (gamepadHandler.isActive()) {
            const input = gamepadHandler.getInput();
            goForward = input.RT > 0.1 && input.LT < 0.1;
            goReverse = input.LT > 0.1 && input.RT < 0.1;
        } else {
            goForward = !!keys["w"] && !keys[" "];
            goReverse = !!keys["s"] && !keys[" "];
        }
        alignerMoving = goForward || goReverse;

        if (alignerMoving) {
            // Distance to travel this frame in degrees
            let remaining = speedDegPerSec * boost * dt;

            if (goForward) {
                // --- Forward along route (increasing segment index) ---
                while (remaining > 0 && alignerSegIdx < alignerRouteCoords.length - 1) {
                    const a = alignerRouteCoords[alignerSegIdx];
                    const b = alignerRouteCoords[alignerSegIdx + 1];
                    const segDx = b[0] - a[0], segDy = b[1] - a[1];
                    const segLen = Math.sqrt(segDx * segDx + segDy * segDy);
                    if (segLen === 0) { alignerSegIdx++; alignerT = 0; continue; }

                    const remainingInSeg = (1 - alignerT) * segLen;
                    if (remaining >= remainingInSeg) {
                        remaining -= remainingInSeg;
                        alignerSegIdx++;
                        alignerT = 0;
                    } else {
                        alignerT += remaining / segLen;
                        remaining = 0;
                    }
                }
                // Clamp at end of route
                if (alignerSegIdx >= alignerRouteCoords.length - 1) {
                    alignerSegIdx = alignerRouteCoords.length - 2;
                    alignerT = 1;
                }
            } else {
                // --- Reverse along route (decreasing segment index) ---
                while (remaining > 0 && (alignerSegIdx > 0 || alignerT > 0)) {
                    const a = alignerRouteCoords[alignerSegIdx];
                    const b = alignerRouteCoords[alignerSegIdx + 1];
                    const segDx = b[0] - a[0], segDy = b[1] - a[1];
                    const segLen = Math.sqrt(segDx * segDx + segDy * segDy);
                    if (segLen === 0) { if (alignerSegIdx > 0) { alignerSegIdx--; alignerT = 1; } else { alignerT = 0; } continue; }

                    const travelledInSeg = alignerT * segLen;
                    if (remaining >= travelledInSeg) {
                        remaining -= travelledInSeg;
                        if (alignerSegIdx > 0) { alignerSegIdx--; alignerT = 1; }
                        else { alignerT = 0; remaining = 0; }
                    } else {
                        alignerT -= remaining / segLen;
                        remaining = 0;
                    }
                }
            }

            // Compute actual position
            const a = alignerRouteCoords[alignerSegIdx];
            const b = alignerRouteCoords[alignerSegIdx + 1];
            lat = a[0] + alignerT * (b[0] - a[0]);
            lng = a[1] + alignerT * (b[1] - a[1]);
            marker.setLatLng([lat, lng]);

            // Compute heading from movement direction (forward or reverse along segment)
            const hDx = b[1] - a[1], hDy = b[0] - a[0];
            const fwdHeading = (Math.atan2(hDx, hDy) * 180 / Math.PI + 360) % 360;
            currentHeading = goReverse ? (fwdHeading + 180) % 360 : fwdHeading;

            trailPoints.push([lat, lng]);
            if (trailPoints.length > MAX_TRAIL) trailPoints.shift();
            trail.setLatLngs(trailPoints);
        }

        isMoving = alignerMoving;
    } else {
        // --- NORMAL MODE: WASD or Gamepad free movement ---
        let dx = 0, dy = 0;
        let useGamepad = gamepadHandler.isActive();
        if (useGamepad) {
            const input = gamepadHandler.getInput();
            // Only move if both RT and LT are pressed, and use left stick for direction
            if (input.RT > 0.1 && input.LT > 0.1) {
                dx = input.steer;
                const pads = getGamepadsSafe();
                const pad = gamepadHandler.gamepadIndex !== null ? pads[gamepadHandler.gamepadIndex] : pads[0];
                let stickY = pad && pad.axes.length > 1 ? -deadzone(pad.axes[1]) : 0;
                const mag = Math.sqrt(dx * dx + stickY * stickY) || 1;
                dx /= mag; stickY /= mag;
                // 3x speed boost when both triggers are pressed
                const speed = input.RT * speedDegPerSec * GAMEPAD_DUAL_TRIGGER_BOOST * dt;
                lat += stickY * speed;
                lng += dx * speed;
                currentHeading = (Math.atan2(dx, stickY) * 180 / Math.PI + 360) % 360;
                marker.setLatLng([lat, lng]);
                trailPoints.push([lat, lng]);
                if (trailPoints.length > MAX_TRAIL) trailPoints.shift();
                trail.setLatLngs(trailPoints);
                isMoving = true;
            } else if (input.RT > 0.1) {
                // Only RT pressed: normal speed
                dx = input.steer;
                const pads = getGamepadsSafe();
                const pad = gamepadHandler.gamepadIndex !== null ? pads[gamepadHandler.gamepadIndex] : pads[0];
                let stickY = pad && pad.axes.length > 1 ? -deadzone(pad.axes[1]) : 0;
                const mag = Math.sqrt(dx * dx + stickY * stickY) || 1;
                dx /= mag; stickY /= mag;
                const speed = input.RT * speedDegPerSec * dt;
                lat += stickY * speed;
                lng += dx * speed;
                currentHeading = (Math.atan2(dx, stickY) * 180 / Math.PI + 360) % 360;
                marker.setLatLng([lat, lng]);
                trailPoints.push([lat, lng]);
                if (trailPoints.length > MAX_TRAIL) trailPoints.shift();
                trail.setLatLngs(trailPoints);
                isMoving = true;
            } else {
                isMoving = false;
            }
        } else {
            // ...existing WASD movement code...
            dx = 0; dy = 0;
            let boostVal = keys["shift"] ? 2 : 1;
            if (keys["w"]) dy = 1;
            if (keys["s"]) dy = -1;
            if (keys["d"]) dx = 1;
            if (keys["a"]) dx = -1;
            const mag = Math.sqrt(dx * dx + dy * dy) || 1;
            dx /= mag; dy /= mag;
            isMoving = (dx !== 0 || dy !== 0);
            if (isMoving) {
                currentHeading = (Math.atan2(dx, dy) * 180 / Math.PI + 360) % 360;
                lat += dy * speedDegPerSec * boostVal * dt;
                lng += dx * speedDegPerSec * boostVal * dt;
                marker.setLatLng([lat, lng]);
                trailPoints.push([lat, lng]);
                if (trailPoints.length > MAX_TRAIL) trailPoints.shift();
                trail.setLatLngs(trailPoints);
            }
        }
    }

    // Soft camera follow ‚Äî pan only when near edge
    try {
        const px = map.latLngToContainerPoint([lat, lng]);
        const sz = map.getSize();
        const m = 60;
        if (px.x < m || px.x > sz.x - m || px.y < m || px.y > sz.y - m) {
            map.panTo([lat, lng], { animate: true, duration: 0.3 });
        }
    } catch (e) {}

    // Send updates to server ‚Äî fast when moving, slow heartbeat when idle
    const sendInterval = isMoving ? SEND_INTERVAL : IDLE_SEND_INTERVAL;
    if (simRunning && bus && now - lastSend >= sendInterval) {
        // Skip if position hasn't changed (within ~1m) and not first send
        const posChanged = lastSentLat === null ||
            Math.abs(lat - lastSentLat) > 0.00001 ||
            Math.abs(lng - lastSentLng) > 0.00001;
        // Always send at heartbeat interval even if not moved (keeps bus alive on server)
        if (posChanged || now - lastSend >= IDLE_SEND_INTERVAL) {
            lastSend = now;
            lastSentLat = lat; lastSentLng = lng;
            const payload = { lat, lng, lastUpdate: new Date().toISOString(), heading: currentHeading };
            if (currentRouteId) payload.routeId = currentRouteId;
            fetch(`/api/bus/${bus}`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload)
            }).then(() => {
                updatesSent++;
                document.getElementById('syncStatus').innerHTML = '<span class="status-dot"></span>Synced';
                document.getElementById('updateCount').textContent = updatesSent;
                document.getElementById('lastUpdateTime').textContent = new Date().toLocaleTimeString();
            }).catch(() => {
                document.getElementById('syncStatus').innerHTML = '<span class="status-dot" style="background:#fb7185"></span>Offline';
            });
        }
    }

    requestAnimationFrame(animate);
}

initBusSelect();
initRouteSelect();

// Start/Stop button
document.getElementById('startBtn').addEventListener('click', () => {
    if (simRunning) {
        simRunning = false;
        // Notify server to remove this bus
        if (bus) {
            fetch(`/api/bus/${bus}`, { method: 'DELETE' }).catch(() => {});
        }
        document.getElementById('syncStatus').innerHTML = '<span class="status-dot" style="background:#667"></span>Stopped';
    } else {
        if (!bus || !currentRouteId) return;
        simRunning = true;
        // Assign route on server
        fetch(`/api/bus/${bus}/route`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ routeId: currentRouteId })
        }).catch(() => {});
        document.getElementById('syncStatus').innerHTML = '<span class="status-dot"></span>Syncing...';
    }
    updateStartBtn();
});

requestAnimationFrame(animate);
</script>
</body>
</html>
